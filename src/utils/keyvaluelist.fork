#  libfork, a base library for the Fork language
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2014, 2015
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the
#  licenses expressed under Section 1.12 of the MPL v2.

# A KeyValueList is a linked list that exports the sametionalities as a map.
# The KeyValueList provides a costant traversal performance and easy deletion
# at the expense of random access time and search.
# The main reason for its usage is that
# 1. the base:Map deletion code has weird bugs
# 2. this structure mantains the insertion order, adding new values at the end
# 3. it's cheap to iterate on it.


import base
import mem
import text
import utils


func kvClone(kv ptr utils:KVList) ptr utils:KVList
  mut ret = utils:kvNew(kv'cmp)

  mut len = utils:kvLen(kv)
  mut i uintptr = 0

  while i < len
    mut elem = utils:kvGetAt(kv, i)
    utils:kvPut(ret, elem'key, elem'value)

    i++
  /while

  return ret
/func


func kvContains(kv ptr utils:KVList, key data) bool
  mut discard data
  return utils:kvGetPos(kv, key, ptr discard) >= 0
/func

decl kvFreeContents func(kv ptr utils:KVList)


func kvDeinit(kv ptr utils:KVList)
  kvFreeContents(kv)
  base:listDeinitAll(ptr kv'list, ptr base:pairFree)
/func


func kvInit(kv ptr utils:KVList, cmp base:comparer) ptr utils:KVList
  mem:memset(kv, 0, size(utils:KVList))

  base:listInit(ptr kv'list)
  kv'cmp = cmp

  return kv
/func


func kvNew(cmp base:comparer) ptr utils:KVList
  return utils:kvInit(cast<ptr utils:KVList>(mem:alloc(size(utils:KVList))), cmp)
/func


func kvFirst(kv ptr utils:KVList) ptr base:Pair
  return base:listLen(ptr kv'list) > 0 => cast<ptr base:Pair>(val base:listGet(ptr kv'list, 0)) || null
/func


func kvFree(kv ptr utils:KVList)
  if kv != null
    utils:kvDeinit(kv)
    mem:free(kv)
  /if
/func


func kvFreePairContents(kv ptr utils:KVList, pair ptr base:Pair)
  if kv'freeKey != null
    kv'freeKey(pair'key)
  /if

  if kv'freeVal != null
    kv'freeVal(pair'value)
  /if
/func


func kvFreeContents(kv ptr utils:KVList)
  mut len = utils:kvLen(kv)
  mut i uintptr = 0

  while i < len
    kvFreePairContents(kv, utils:kvGetAt(kv, i))

    i++
  /while
/func


func kvGet(kv ptr utils:KVList, key data, value ptr data) bool
  return utils:kvGetPos(kv, key, value) >= 0
/func


func kvGetAt(kv ptr utils:KVList, index uintptr) ptr base:Pair
  mut ret = base:listGet(ptr kv'list, index)
  return ret != null => cast<ptr base:Pair>(val ret) || null
/func


func kvGetPairAndPos(kv ptr utils:KVList, key data, pair ptr ptr base:Pair) intptr
  mut len = utils:kvLen(kv)
  mut i intptr = 0

  while i < len
    mut keyValuePair = utils:kvGetAt(kv, i)

    if kv'cmp(keyValuePair'key, key) == 0
      val pair = keyValuePair

      return i
    /if

    i++
  /while

  return -1
/func


func kvGetPos(kv ptr utils:KVList, key data, value ptr data) intptr
  mut pair ptr base:Pair
  mut pos = kvGetPairAndPos(kv, key, ptr pair)

  if pos < 0
    return -1
  /if

  val value = pair'value

  return pos
/func


func kvLen(kv ptr utils:KVList) uintptr
  return base:listLen(ptr kv'list)
/func


func kvPrint(kv ptr utils:KVList)
  if kv == null
    base:outln("<null>")
  else

    base:out("[ ")

    mut len = utils:kvLen(kv)
    mut i uintptr = 0

    while i < len
      if i > 0
        base:out(", ")
      /if

      mut pair = utils:kvGetAt(kv, i)

      base:out(cast<ptr uint8>(pair'key))
      base:out(": ")
      base:out(cast<ptr uint8>(pair'value))

      i++
    /while

    base:out(" ]")

  /if
/func


func kvPut(kv ptr utils:KVList, key data, value data)
  mut pair ptr base:Pair
  mut pos = kvGetPairAndPos(kv, key, ptr pair)

  if pos < 0
    base:listAppend(ptr kv'list, base:pairNew(key, value))
  else
    kvFreePairContents(kv, pair)

    pair'key = key
    pair'value = value
  /if
/func


func kvRemove(kv ptr utils:KVList, key data) bool
  mut pair ptr base:Pair

  mut pos = kvGetPairAndPos(kv, key, ptr pair)

  if pos >= 0
    kvFreePairContents(kv, pair)

    base:listRemove(ptr kv'list, pos, ptr base:pairFree)

    return true
  /if

  return false
/func


func kvSetFreeFuncs(kv ptr utils:KVList, freeKey ptr func(item data), freeVal ptr func(item data))
  kv'freeKey = freeKey
  kv'freeVal = freeVal
/func


func strkvInit(kv ptr utils:KVList) ptr utils:KVList
  return utils:kvInit(kv, ptr text:strcompare)
/func


func strkvNew() ptr utils:KVList
  return utils:kvNew(ptr text:strcompare)
/func
