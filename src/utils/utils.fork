#  libfork, a base library for the Fork language
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2014, 2015
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the
#  licenses expressed under Section 1.12 of the MPL v2.

import base
import lex
import utils


func charIsIdVal(ch uint8) bool
  if (ch >= 48) and (ch <= 57) #is a number
    return true
  /if

  if (ch >= 65) and (ch <= 90) #is an uppercase letter
    return true
  /if

  if (ch >= 97) and (ch <= 122) #is a lowcase letter
    return true
  /if

  if ch == 95 #is a `_`
    return true
  /if

  return false
/func


func charIsControl(ch uint8) bool
  return ch < 20 or ch > 126
/func


func charIsPar(ch uint8) bool
  #40 == `(`, 41 == `)`, 91 == `[`, 93 == `]`
  return ch == 40 or ch == 41 or ch == 91 or ch == 93
/func


func charIsWhite(ch uint8) bool
  #32 == ` `, 10 == `\n`, 13 == `\r`, 12 == `\f`, 11 == `\v`, 9 == `\t`
  return ch == 32 or ch == 10 or ch == 13 or ch == 12 or ch == 11 or ch == 9
/func


func charIsSym(ch uint8) bool
  return !charIsIdVal(ch) and !charIsPar(ch) and !charIsWhite(ch)
/func


func issueFree(issue ptr utils:Issue)
  if issue != null
    base:free(issue'filename)
    base:free(issue'message)
  /if
/func


func issueNew(gravity uint8, where utils:Line, filename, message ptr uint8)  ptr utils:Issue
  mut issue = cast<ptr utils:Issue>(base:zalloc(size(utils:Issue)))

  issue'gravity = gravity
  issue'where = where
  issue'filename = base:strclone(filename)
  issue'message = base:strclone(message)

  return issue
/func


func issueGravityToStr(issueGravity uint8) ptr uint8
  if issueGravity == utils:ISSUE_ERR
    return "error"
  /if

  if issueGravity == utils:ISSUE_WARN
    return "warning"
  /if

  if issueGravity == utils:ISSUE_INFO
    return "info"
  /if

  return "<UNKNOWN_ISSUE_LEVEL>"
/func


func issueToError(issue ptr utils:Issue) ptr base:Error
  mut lineno [21] uint8
  mut pos [21] uint8

  base:numtostr(issue'where'line, ptr lineno[0], 21)
  base:numtostr(issue'where'pos, ptr pos[0], 21)

  mut toglue [10] ptr uint8
  toglue[0] = issue'filename
  toglue[1] = ":"
  toglue[2] = ptr lineno[0]
  toglue[3] = ":"
  toglue[4] = ptr pos[0]
  toglue[5] = ": "
  toglue[6] = issueGravityToStr(issue'gravity)
  toglue[7] = ": "
  toglue[8] = issue'message
  toglue[9] = null

  mut ret = base:errorGlue(ptr toglue[0])

  utils:issueFree(issue)

  return ret
/func


func issueWriteOut(issue ptr utils:Issue, outFn ptr func(err ptr uint8))
  outFn(issue'filename)
  outFn(":")


  mut buf [21] uint8
  base:numtostr(issue'where'line, ptr buf[0], 21)

  outFn(ptr buf[0])
  outFn(":")

  base:numtostr(issue'where'pos, ptr buf[0], 21)

  outFn(ptr buf[0])
  outFn(": ")

  outFn(issueGravityToStr(issue'gravity))
  outFn(": ")
  outFn(issue'message)
  outFn("\n")
/func


func charCanBeInString(ch uint8, escape bool) bool
  if !escape and ch == 34 # `"`
    return false #if the matching " is found, then stop
  /if

  return !charIsControl(ch)
/func


func strIsUInt(str ptr uint8) bool
  while val str != 0
    if (val str < 48) or (val str > 57) # current letter is not an ASCII number
      return false
    /if

    str++
  /while

  return true
/func


func incRef(refc data)
  if refc != null
    cast<ptr utils:Ref>(refc)'count++
  /if
/func


func decRef(refc data)
  if refc != null
    mut ref = cast<ptr utils:Ref>(refc)
    ref'count--
    if ref'count < 1
      ref'freeFunc(refc)
    /if
  /if
/func


func tokenizerFree(tkz ptr utils:Tokenizer)
  if tkz != null
    base:free(tkz'str)
    base:free(tkz)
  /if
/func


func tokenizerNew(str ptr uint8, ch uint8) ptr utils:Tokenizer
  mut tkz = cast<ptr utils:Tokenizer>(base:zalloc(size(utils:Tokenizer)))
  tkz'str = base:strclone(str)
  tkz'strlen = base:strlen(str)
  tkz'splitChar = ch

  return tkz
/func


func tokenizerNext(tkz ptr utils:Tokenizer) ptr uint8
  if tkz'begin == tkz'strlen
    return null
  /if

  mut initialBegin = tkz'begin

  while tkz'str[tkz'begin] != tkz'splitChar and tkz'begin < tkz'strlen
    tkz'begin++
  /while

  mut nextLen = tkz'begin - initialBegin
  mut ret = cast<ptr uint8>(base:zalloc(nextLen + 1)) # + 1 is for the null end. God I hate C

  base:strncpy(ret, tkz'str + initialBegin, nextLen)

  if tkz'str[tkz'begin] == tkz'splitChar
    tkz'begin++
  /if

  return ret
/func


func listContains(list ptr base:List, value ptr uint8) bool
  mut i uintptr = 0
  mut len = base:listLen(list)


  mut clone = val list

  # this fixes a weird bug in base:List that I haven't found yet.
  base:listSeekZero(list)

  while i < len
    mut ptrElem = base:listGet(list, i)
    mut elem = cast<ptr uint8>(val ptrElem)

    if base:strequals(elem, value)
      return true
    /if

    i++
  /while

  return false
/func


func listDumpHierarchyIntoCS(list ptr base:List, cs ptr base:Charstash)
  mut len = base:listLen(list)

  base:csAppendStr(cs, "(")

  if len > 1

    mut i = cast<intptr>(len)

    while i > 0
      i--

      base:csAppendStr(cs, cast<ptr uint8>(val base:listGet(list, i)))

      base:csAppendStr(cs, " => ")
    /while

    base:csAppendStr(cs, cast<ptr uint8>(val base:listGet(list, len - 1)))
  else
    base:csAppendStr(cs, "alias of itself")
  /if

  base:csAppendStr(cs, ")")
/func


mut ISSUE_ERR  uint8 = 10
mut ISSUE_WARN uint8 = 20
mut ISSUE_INFO uint8 = 30
