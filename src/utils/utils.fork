#  Second Step - Experimental Fork Compiler
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2014
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the
#  licenses expressed under Section 1.12 of the MPL v2.

import lex
import spring
import utils


func charIsIdVal(ch uint8) bool
  if (ch >= 48) and (ch <= 57) #is a number
    return true
  /if

  if (ch >= 65) and (ch <= 90) #is an uppercase letter
    return true
  /if

  if (ch >= 97) and (ch <= 122) #is a lowcase letter
    return true
  /if

  if ch == 95 #is a `_`
    return true
  /if

  return false
/func


func charIsControl(ch uint8) bool
  return ch < 20 or ch > 126
/func


func charIsPar(ch uint8) bool
  #40 == `(`, 41 == `)`, 91 == `[`, 93 == `]`
  return ch == 40 or ch == 41 or ch == 91 or ch == 93
/func


func charIsWhite(ch uint8) bool
  #32 == ` `, 10 == `\n`, 13 == `\r`, 12 == `\f`, 11 == `\v`
  return ch == 32 or ch == 10 or ch == 13 or ch == 12 or ch == 11
/func


func charIsSym(ch uint8) bool
  return !charIsIdVal(ch) and !charIsPar(ch) and !charIsWhite(ch)
/func


func issueFree(issue ptr utils:Issue)
  if issue != null
    spring:free(issue'filename)
    spring:free(issue'message)
  /if
/func


func issueNew(gravity uint8, where utils:Line, filename, message ptr uint8)  ptr utils:Issue
  mut issue = cast<ptr utils:Issue>(spring:zalloc(size(utils:Issue)))

  issue'gravity = gravity
  issue'where = where
  issue'filename = spring:strclone(filename)
  issue'message = spring:strclone(message)

  return issue
/func


func issueGravityToStr(issueGravity uint8) ptr uint8
  if issueGravity == utils:ISSUE_ERR
    return "error"
  /if

  if issueGravity == utils:ISSUE_WARN
    return "warning"
  /if

  if issueGravity == utils:ISSUE_INFO
    return "info"
  /if

  return "<UNKNOWN_ISSUE_LEVEL>"
/func


func issueToError(issue ptr utils:Issue) ptr spring:Error
  mut lineno [21] uint8
  mut pos [21] uint8

  spring:numtostr(issue'where'line, lineno, 21)
  spring:numtostr(issue'where'pos, pos, 21)

  mut toglue [10] ptr uint8
  toglue[0] = issue'filename
  toglue[1] = ":"
  toglue[2] = lineno
  toglue[3] = ":"
  toglue[4] = pos
  toglue[5] = ": "
  toglue[6] = issueGravityToStr(issue'gravity)
  toglue[7] = ": "
  toglue[8] = issue'message
  toglue[9] = null

  mut ret = spring:errorGlue(toglue)

  utils:issueFree(issue)

  return ret
/func


func issueWriteOut(issue ptr utils:Issue, outFn ptr func(err ptr uint8))
  outFn(issue'filename)
  outFn(":")


  mut buf [21] uint8
  spring:numtostr(issue'where'line, buf, 21)

  outFn(buf)
  outFn(":")

  spring:numtostr(issue'where'pos, buf, 21)

  outFn(buf)
  outFn(": ")

  outFn(issueGravityToStr(issue'gravity))
  outFn(": ")
  outFn(issue'message)
  outFn("\n")
/func


func error(lineno ptr utils:LexLineno, msg ptr uint8) ptr utils:Issue
  mut line utils:Line
  line'line = lineno'lineno
  line'pos = lineno'pos

  return utils:issueNew(utils:ISSUE_ERR, line, lineno'filename, msg)
/func


func errorMism(lineno ptr utils:LexLineno, exp ptr uint8, got ptr uint8) ptr utils:Issue

  mut toglue [5] ptr uint8
  toglue[0] = "expected "
  toglue[1] = exp
  toglue[2] = ", got "
  toglue[3] = got
  toglue[4] = null

  mut glued = spring:strglue(toglue)
  mut ret =  utils:error(lineno, glued)

  spring:free(glued)

  return ret
/func


func charCanBeInString(ch uint8, escape bool) bool
  if !escape and ch == 34 # `"`
    return false #if the matching " is found, then stop
  /if

  return !charIsControl(ch)
/func


func strIsUInt(str ptr uint8) bool
  while val str != 0
    if (val str < 48) or (val str > 57) # current letter is not an ASCII number
      return false
    /if

    str++
  /while

  return true
/func


func incRef(refc data)
  if refc != null
    cast<ptr utils:Ref>(refc)'count++
  /if
/func


func decRef(refc data)
  if refc != null
    mut ref = cast<ptr utils:Ref>(refc)
    ref'count--
    if ref'count < 1
      ref'freeFunc(refc)
    /if
  /if
/func


func tokenizerFree(tkz ptr utils:Tokenizer)
  if tkz != null
    spring:free(tkz'str)
    spring:free(tkz)
  /if
/func


func tokenizerNew(str ptr uint8, ch uint8) ptr utils:Tokenizer
  mut tkz = cast<ptr utils:Tokenizer>(spring:zalloc(size(utils:Tokenizer)))
  tkz'str = spring:strclone(str)
  tkz'strlen = spring:strlen(str)
  tkz'splitChar = ch

  return tkz
/func


func tokenizerNext(tkz ptr utils:Tokenizer) ptr uint8
  if tkz'begin == tkz'strlen
    return null
  /if

  mut initialBegin = tkz'begin

  while tkz'str[tkz'begin] != tkz'splitChar and tkz'begin < tkz'strlen
    tkz'begin++
  /while

  mut nextLen = tkz'begin - initialBegin
  mut ret = cast<ptr uint8>(spring:zalloc(nextLen))

  spring:strncpy(ret, tkz'str + initialBegin, nextLen)

  return ret
/func


func linenoClone(lineno ptr utils:LexLineno) ptr utils:LexLineno
  return utils:linenoNew(spring:strclone(lineno'filename), lineno'lineno, lineno'pos)
/func


func linenoFree(lineno ptr utils:LexLineno)
  if lineno != null
    spring:free(lineno'filename)
    spring:free(lineno)
  /if
/func


func linenoNew(filename ptr uint8, lineno, pos uint16) ptr utils:LexLineno
  mut ret = cast<ptr utils:LexLineno>(spring:alloc(size(utils:LexLineno)))

  ret'filename = filename
  ret'lineno = lineno
  ret'pos = pos

  return ret
/func


func issueFromLexError(err ptr spring:Error, lineno ptr utils:LexLineno) ptr utils:Issue
  if err == null
    return null
  /if

  mut where utils:Line
  where'line = lineno'lineno
  where'pos = lineno'pos

  mut ret = utils:issueNew(utils:ISSUE_ERR, where, lineno'filename, err'msg)

  spring:errorFree(err)

  return ret
/func


mut ISSUE_ERR  uint8 = 10
mut ISSUE_WARN uint8 = 20
mut ISSUE_INFO uint8 = 30
