#  libfork, a base library for the Fork language
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2014, 2015
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the
#  licenses expressed under Section 1.12 of the MPL v2.


import ast
import err
import lex
import list
import mem
import parser
import text
import utils


func charIsIdVal(ch uint8) bool
  if (ch >= 48) and (ch <= 57) #is a number
    return true
  /if

  if (ch >= 65) and (ch <= 90) #is an uppercase letter
    return true
  /if

  if (ch >= 97) and (ch <= 122) #is a lowcase letter
    return true
  /if

  if ch == 95 #is a `_`
    return true
  /if

  return false
/func


func charIsControl(ch uint8) bool
  return ch < 20 or ch > 126
/func


func charIsPar(ch uint8) bool
  #40 == `(`, 41 == `)`, 91 == `[`, 93 == `]`
  return ch == 40 or ch == 41 or ch == 91 or ch == 93
/func


func charIsWhite(ch uint8) bool
  #32 == ` `, 10 == `\n`, 13 == `\r`, 12 == `\f`, 11 == `\v`, 9 == `\t`
  return ch == 32 or ch == 10 or ch == 13 or ch == 12 or ch == 11 or ch == 9
/func


func charIsSym(ch uint8) bool
  return !charIsIdVal(ch) and !charIsPar(ch) and !charIsWhite(ch)
/func


func issueFree(issue ptr parser:Issue)
  if issue != null
    mem:free(issue'filename)
    mem:free(issue'message)
  /if
/func


func issueNew(gravity uint8, where ast:Line, filename, message ptr uint8)  ptr parser:Issue
  mut issue = cast<ptr parser:Issue>(mem:zalloc(size(parser:Issue)))

  issue'gravity = gravity
  issue'where = where
  issue'filename = text:strclone(filename)
  issue'message = text:strclone(message)

  return issue
/func


func issueGravityToStr(issueGravity uint8) ptr uint8
  if issueGravity == parser:ISSUE_ERR
    return "error"
  /if

  if issueGravity == parser:ISSUE_WARN
    return "warning"
  /if

  if issueGravity == parser:ISSUE_INFO
    return "info"
  /if

  return "<UNKNOWN_ISSUE_LEVEL>"
/func


func issueToError(issue ptr parser:Issue) ptr err:Error
  mut lineno [21] uint8
  mut pos [21] uint8

  text:numtostr(issue'where'line, ptr lineno[0], 21)
  text:numtostr(issue'where'pos, ptr pos[0], 21)

  mut toglue [10] ptr uint8
  toglue[0] = issue'filename
  toglue[1] = ":"
  toglue[2] = ptr lineno[0]
  toglue[3] = ":"
  toglue[4] = ptr pos[0]
  toglue[5] = ": "
  toglue[6] = issueGravityToStr(issue'gravity)
  toglue[7] = ": "
  toglue[8] = issue'message
  toglue[9] = null

  mut ret = err:errorGlue(ptr toglue[0])

  parser:issueFree(issue)

  return ret
/func


func issueWriteOut(issue ptr parser:Issue, outFn ptr func(err ptr uint8))
  outFn(issue'filename)
  outFn(":")


  mut buf [21] uint8
  text:numtostr(issue'where'line, ptr buf[0], 21)

  outFn(ptr buf[0])
  outFn(":")

  text:numtostr(issue'where'pos, ptr buf[0], 21)

  outFn(ptr buf[0])
  outFn(": ")

  outFn(issueGravityToStr(issue'gravity))
  outFn(": ")
  outFn(issue'message)
  outFn("\n")
/func


func charCanBeInString(ch uint8, escape bool) bool
  if !escape and ch == 34 # `"`
    return false #if the matching " is found, then stop
  /if

  return !charIsControl(ch)
/func


func strIsUInt(str ptr uint8) bool
  while val str != 0
    if (val str < 48) or (val str > 57) # current letter is not an ASCII number
      return false
    /if

    str++
  /while

  return true
/func


func listContains(list ptr list:List, value ptr uint8) bool
  mut i uintptr = 0
  mut len = list:listLen(list)


  mut clone = val list

  # this fixes a weird bug in list:List that I haven't found yet.
  list:listSeekZero(list)

  while i < len
    mut ptrElem = list:listGet(list, i)
    mut elem = cast<ptr uint8>(val ptrElem)

    if text:strequals(elem, value)
      return true
    /if

    i++
  /while

  return false
/func


func listDumpHierarchyIntoCS(list ptr list:List, cs ptr text:Charstash)
  mut len = list:listLen(list)

  text:csAppendStr(cs, "(")

  if len > 1

    mut i = cast<intptr>(len)

    while i > 0
      i--

      text:csAppendStr(cs, cast<ptr uint8>(val list:listGet(list, i)))

      text:csAppendStr(cs, " => ")
    /while

    text:csAppendStr(cs, cast<ptr uint8>(val list:listGet(list, len - 1)))
  else
    text:csAppendStr(cs, "alias of itself")
  /if

  text:csAppendStr(cs, ")")
/func


mut ISSUE_ERR  uint8 = 10
mut ISSUE_WARN uint8 = 20
mut ISSUE_INFO uint8 = 30
