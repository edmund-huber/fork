#  libfork, a base library for the Fork language
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2015, 2016
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the
#  licenses expressed under Section 1.12 of the MPL v2.


module parser


import ast
import buffer
import err
import fs
import kv
import list
import map
import mem
import memutils
import vect


alias Parser struct (
  fordPaths ptr list:List,
  imports ptr map:Map,
  importsTPool ptr memutils:FreePool,
  currentFile ptr uint8,
  builtins ptr map:Map
)


# Parser init/deinit functions

decl func free(prs ptr Parser)
decl func new() ptr Parser


# Parser methods

decl method Parser.getImport(name ptr uint8) ptr Ford

decl method Parser.importAll(imports ptr list:List) ptr ast:Issues
decl method Parser.matchBuiltin(name ptr uint8) ptr ast:Type

decl method Parser.parseDirectory(dirName ptr uint8) {pmod ptr ast:PModule,
                                                       issues ptr ast:Issues}

decl method Parser.parseFile(fileName ptr uint8) {root ptr ast:PNode,
                                                   issues ptr ast:Issues}

decl method Parser.setCurrentFile(filename ptr uint8)


# .ford generation

decl func makeFord(pmod ptr ast:PModule) ptr buffer:Buffer
decl func writeFord(name,path ptr uint8,
                    genData ptr buffer:Buffer,
                    extra ptr uint8,
                    extraLen uintptr) ptr err:Error


# Ford methods (creation and member)

decl method Parser.findFord(name ptr uint8) {imp ptr Ford, err ptr err:Error}

decl method Parser.loadFord(path ptr uint8) {imp ptr Ford, err ptr err:Error}


alias Ford struct(
  name ptr uint8,
  imports ptr vect:Vect,
  aliases,decls ptr ast:Symtable,
  extra ptr uint8,
  extraLen uint32
)

# Ford functions
decl func fordFree(ford ptr Ford)

### synt

decl func parse(filename ptr uint8) {file ptr ast:PNode, iss ptr ast:Issue}
decl func parseModule(path ptr uint8) {pmod ptr ast:PModule, isss ptr ast:Issues}

# private (in theory)

alias ParseState struct(
  filename ptr uint8,
  err ptr ast:Issue,
  prs ptr Parser,
  lex ptr ast:Lexer,
  next ptr ast:Token,
  last ptr fs:Lineno,
  moduleName ptr uint8
)

decl method ParseState.discardNext()
decl method ParseState.expect(ttype uint16) ptr ast:Token
decl method ParseState.expectDiscard(ttype uint16) bool
decl method ParseState.next() ptr ast:Token
decl method ParseState.parseExpr() ptr ast:PExpr
decl method ParseState.parseType() ptr ast:PType

decl func isBinary(tok ptr ast:Token) bool
decl func isUnary(tok ptr ast:Token) bool



### sema

alias Resolver struct (
  prs ptr Parser,
  curRoot ptr ast:PRoot,
  aliases,decls ptr kv:KVList,
  issues ptr ast:Issues
)


decl func resolverDeinit(rsv ptr Resolver)


decl method Resolver.collect(prs ptr Parser,
                             pmod ptr ast:PModule,
                             issues ptr ast:Issues) ptr kv:KVList

decl method Resolver.findAliasImport(moduleName,name ptr uint8) ptr ast:Type

decl method Resolver.findMethod(node ptr ast:PNode,
                     typeModule,typeName,methodName ptr uint8) ptr ast:Type

decl method Resolver.findRecAlias(scope ptr ast:PNode, ralias ptr ast:Type) ptr ast:Type
decl method Resolver.findSymModule(moduleName, name ptr uint8) ptr ast:Type

decl method Resolver.registerAlias(pdecl ptr ast:PDecl) ptr ast:Type

decl method Resolver.registerDecl(pdecl ptr ast:PDecl,
                                  name ptr uint8,
                                  type ptr ast:Type,
                                  declType uint16) ptr ast:Type

decl method Resolver.registerTopDecl(pdecl ptr ast:PDecl) ptr ast:Type


decl method Resolver.resolveDeclType(name ptr uint8,
                                     node ptr ast:PNode,
                                     recList ptr list:List) ptr ast:Type

decl method Resolver.resolveType(ptype ptr ast:PType) ptr ast:Type

decl method Resolver.resolveTypeName(name ptr uint8) ptr ast:Type


decl method Resolver.setCurrentRoot(root ptr ast:PRoot)

decl method Resolver.typeIsAssignable(scope ptr ast:PNode, dest,src ptr ast:Type) bool
decl method Resolver.typeIsCastable(scope ptr ast:PNode, dest,src ptr ast:Type) bool
decl method Resolver.typeChooseLarger(scope ptr ast:PNode, dest,src ptr ast:Type) bool

decl method Resolver.validateExprRecl(pexpr ptr ast:PExpr,
                                      recList ptr list:List) ptr ast:Type

decl method Resolver.validateExpr(pexpr ptr ast:PExpr) ptr ast:Type

decl method Resolver.validateFunc(pdecl ptr ast:PDecl,
                                  funcType ptr ast:Type) bool

# validates the AST, and returns a list of the issues found.
decl func validateAst(prs ptr Parser,
                      root ptr ast:PNode) ptr ast:Issues

decl func validateModuleAst(prs ptr Parser,
                            pmod ptr ast:PModule) ptr ast:Issues


decl method ast:PExpr.isCompileConst() bool
decl method ast:PNode.findAliasLocal(name ptr uint8) ptr ast:Type
