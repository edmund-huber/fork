#  libfork, a base library for the Fork language
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2015
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the
#  licenses expressed under Section 1.12 of the MPL v2.


module ast


import cs
import err
import fs
import hash
import io
import kv
import list
import map
import mem
import memutils
import txt
import vect


# PType and PTypeDescr do not represent a type, but its parse-time representation.
# Per example, uint16 and PType are bot "id-types", because they are syntactically presented by
# an identifier at parsing time, while being really very different (a struct and an integer).

alias PType struct (
  refc memutils:Ref,
  name, moduleName ptr uint8,
  descr ptr PTypeDescr,
  begin, end txt:Line
)

decl method PType.dump()


alias PTypeDescr struct (
  refc memutils:Ref,
  type uint16,
  # if type is PTYPE_PTR or PTYPE_LOC, this is the type returned by dereferencing.
  # if type is PTYPE_FUNC, this is the return type of the function
  retType ptr PType,
  # if type is PTYPE_FUNC, this is the arguments list
  # if type is PTYPE_STRUCT, this is the fields list
  arguments ptr list:List,
  #if type is PTYPE_LOC, this is the number of items allocated
  length uintptr
)

decl method PTypeDescr.dump()


alias PSymbol struct(
  refc memutils:Ref,
  name ptr uint8,
  type ptr PType
)


# Type represents a well formed, semantically valid type.
# An instance of this is the product of type validation by sema.

alias Type struct(
  # which type macroclass this instance represents.
  type uint16,

  # eventual alias (module and name) of the current type.
  moduleName, name ptr uint8,

  # if integer, this represent its signedness.
  isSigned bool,

  # size of this type. Set on creation. -1 if recursive.
  # functions have no size.
  # alignment of this type. Set on creation. -1 if recursive.
  typeSize, typeAlign intptr,

  # number of items, in case this is a location.
  itemCount uintptr,

  # the type the current instance evaluates to when an operation like function invocation or derefereciation is made.
  # For pointers, this is the type of the expression obtained with val.
  # For functions, this is the value of the expression obtained invoking the function.
  retType ptr Type,

  # The members that compose this type.
  # For functions, these are the parameters.
  # For structures, these are the members.
  members ptr kv:KVList,

  # if this type is builtin
  builtin bool,

  # where the original type was defined.
  begin, end txt:Line
)


decl func typeFree(type ptr Type)


decl method Type.dump(cs ptr cs:Charstash)
decl method Type.equals(other ptr Type) bool
decl method Type.isBool() bool
decl method Type.isData() bool
decl method Type.isEmpty() bool
decl method Type.isFunc() bool
decl method Type.isInt() bool
decl method Type.isLoc() bool
decl method Type.isNull() bool
decl method Type.isPtr() bool
decl method Type.isStruct() bool
decl method Type.summarize(cs ptr cs:Charstash)


alias Symbol struct(
  name ptr uint8,
  type ptr Type
)


decl method Symbol.dump(cs ptr cs:Charstash)
decl method Symbol.equals(other ptr Symbol) bool
decl method Symbol.summarize(cs ptr cs:Charstash)



alias DeclInfo struct(
  declType uint16,
  declOnly,funcParam bool,
  type ptr Type
)

alias MethodInfo struct(
  typeModule,typeName,name ptr uint8,
  type ptr Type
)

decl func methodInfoHash(mi ptr MethodInfo) uintptr


alias Symtable struct(
  syms ptr kv:KVList
)

decl func stabFree(stab ptr Symtable)
decl func stabNew() ptr Symtable


decl method Symtable.add(name ptr uint8,
                         isDecl,funcParam bool,
                         type ptr Type,
                         symType uint16)

decl method Symtable.get(name ptr uint8) ptr DeclInfo
decl method Symtable.typeof(name ptr uint8) ptr Type


decl func declDump(prefix,name ptr uint8, type ptr Type)
# end symbols

# begin pnode

alias PNode struct(
  type uint16,
  value uintptr,
  parent ptr PNode,
  leaves ptr list:List,
  begin, end txt:Line,
  validated bool
)

decl func pnodeFree(pnode ptr PNode)

# pnode methods
decl method PNode.dump()

decl method PNode.findPBlock() ptr PNode
decl method PNode.findPRoot() ptr PRoot
decl method PNode.findStab() ptr Symtable
decl method PNode.findSym(name ptr uint8) ptr Type
decl method PNode.findSymLocal(name ptr uint8) ptr Type

decl method PNode.isBlock() bool
decl method PNode.isBreakContinue() bool
decl method PNode.isDecl() bool
decl method PNode.isMulDecl() bool
decl method PNode.isMutOrDecl() bool
decl method PNode.isExpr() bool
decl method PNode.isIf() bool
decl method PNode.isReturn() bool
decl method PNode.isRoot() bool
decl method PNode.isWhile() bool


alias PBlock struct(
  node PNode,
  syms ptr Symtable
)


alias StringDef struct(
  name ptr uint8,
  begin,end txt:Line
)


alias PDecl struct(
  node PNode,
  sym ptr PSymbol,
  isDecl bool,
  methodTypeModule,methodType ptr uint8
)


alias PMulDecl struct(
  node PNode,
  syms ptr list:List
)


alias PRoot struct(
  node PBlock,
  moduleName ptr StringDef,
  fileName ptr uint8,
  imports ptr list:List,
  aliases ptr Symtable,
  typePool ptr memutils:FreePool,
  entryNode ptr PDecl,
  pmodule ptr PModule
)

decl method PRoot.hasImported(name ptr uint8) bool

alias PExpr struct(
  node PNode,
  opType uint16,
  constant bool,
  type,sizeType ptr Type
)


alias PModule struct(
  name ptr uint8,
  roots ptr vect:Vect,
  entryNode ptr PNode
)


decl method PModule.dump()

decl func pmoduleFree(pmod ptr PModule)


decl func declKey(pdecl ptr PDecl) ptr uint8
decl func methodKey(typeModule,typeName,methodName ptr uint8) ptr uint8


alias Issue struct (
  gravity uint8,
  where txt:Line,
  filename,message ptr uint8
)


decl func issueFree(issue ptr Issue)
decl func issueNew(gravity uint8, where txt:Line, filename, message ptr uint8) ptr Issue
decl func issueToError(issue ptr Issue) ptr err:Error

decl method Issue.writeOut(out ptr func(err ptr uint8))


alias Issues struct (
  list list:List,
  errLen uintptr
)


decl func issuesFree(iss ptr Issues)
decl func issuesNew() ptr Issues


decl method Issues.add(issue ptr Issue)
decl method Issues.addAll(iss ptr Issues)
decl method Issues.errLen() uintptr
decl method Issues.error(where txt:Line, filename, message ptr uint8)
decl method Issues.get(i uintptr) ptr Issue
decl method Issues.len() uintptr


decl mut ISSUE_ERR uint8
decl mut ISSUE_WARN uint8
decl mut ISSUE_INFO uint8


decl mut PROOT      uint16
decl mut PENTRY     uint16
decl mut PEXPR      uint16
decl mut PFUNCTION  uint16
decl mut PALIAS     uint16
decl mut PMUT       uint16
decl mut PMUTEXP    uint16
decl mut PBREAK     uint16
decl mut PCONTINUE  uint16
decl mut PRETURN    uint16
decl mut PIF        uint16
decl mut PIFELSE    uint16
decl mut PWHILE     uint16
decl mut PBLOCK     uint16
decl mut PMETHOD    uint16

#end pnode

# symbols

decl mut PTYPE_FUNC   uint16
decl mut PTYPE_ID     uint16
decl mut PTYPE_PTR    uint16
decl mut PTYPE_STRUCT uint16
decl mut PTYPE_LOC    uint16


decl mut TYPE_EMPTY     uint16
decl mut TYPE_FUNC      uint16
decl mut TYPE_PTR       uint16
decl mut TYPE_STRUCT    uint16
decl mut TYPE_LOC       uint16
decl mut TYPE_BOOL      uint16
decl mut TYPE_INT       uint16
decl mut TYPE_DATA      uint16
decl mut TYPE_RECALIAS  uint16
decl mut TYPE_NULL      uint16


# astfn

decl func psymbolNew(name ptr uint8, type ptr PType) ptr PSymbol

decl func ptypeNew(name,moduleName ptr uint8, descr ptr PTypeDescr) ptr PType

decl func ptypeDescrNew(ptype uint16, retPType ptr PType, params ptr list:List) ptr PTypeDescr
decl func ptypeDescrNewLoc(innerPType ptr PType, length uintptr) ptr PTypeDescr

decl func symbolClone(sym ptr Symbol) ptr Symbol
decl func symbolFree(sym ptr Symbol)
decl func symbolNew(name ptr uint8, type ptr Type) ptr Symbol

decl func builtinSetNew() ptr map:Map

decl func typeClone(pool ptr memutils:FreePool, type ptr Type) ptr Type
decl func typeNewFunc(pool ptr memutils:FreePool, moduleName, name ptr uint8, retVal ptr Type, members ptr kv:KVList) ptr Type
decl func typeNewLoc(pool ptr memutils:FreePool, moduleName, name ptr uint8, itemCount uintptr, retVal ptr Type) ptr Type
decl func typeNewPtr(pool ptr memutils:FreePool, moduleName, name ptr uint8, retVal ptr Type) ptr Type
decl func typeNewRecursiveAlias(pool ptr memutils:FreePool, moduleName, name ptr uint8) ptr Type
decl func typeNewStruct(pool ptr memutils:FreePool, moduleName, name ptr uint8, members ptr kv:KVList) ptr Type
decl func typeSetAlias(type ptr Type, moduleName, name ptr uint8)
decl func typeSetBoundaries(type ptr Type, begin,end txt:Line)


decl func declInfoFree(declInfo ptr DeclInfo)
decl func declInfoNew(declType uint16, declOnly,funcParam bool, type ptr Type) ptr DeclInfo


decl func strdefFree(strdef ptr StringDef)
decl func strdefNew(name ptr uint8, begin,end txt:Line) ptr StringDef


decl func pnodeAppendChild(parent ptr PNode, child ptr PNode) ptr PNode
decl func pnodeNew(ptype uint16, value uintptr) ptr PNode

decl func pblockNew() ptr PBlock

decl func pdeclNew(ptype uint16, sym ptr PSymbol, isDecl bool) ptr PDecl

decl func pmuldeclNew(ptype uint16, syms ptr list:List) ptr PMulDecl

decl func pexprNew(tok ptr Token, lhs,rhs ptr PExpr, begin,end txt:Line) ptr PExpr
decl func pexprNewTernary(tok ptr Token, lhs,mid,rhs ptr PExpr, begin,end txt:Line) ptr PExpr
decl func pexprNewSingle(tok ptr Token) ptr PExpr

decl func prootNew(modName ptr StringDef, imports ptr list:List, fileName ptr uint8) ptr PRoot

decl func pmoduleAdd(pmod ptr PModule, root ptr PRoot) bool
decl func pmoduleNew() ptr PModule


## lexer

decl func lineMake(lexl ptr fs:Lineno) txt:Line

decl func issueFromLexError(err ptr err:Error, lineno ptr fs:Lineno) ptr Issue

alias StringTok struct(
  str ptr uint8,
  begin,end,line uintptr
)

alias Lexer struct (
  file ptr io:Stream,
  lineno ptr fs:Lineno,
  error ptr err:Error,
  saved ptr StringTok,
  peek uint8,
  newline, firstLineTok, firstLineLetter bool
)

alias Token struct (
  type uint16,
  endPos uintptr,
  value uintptr,
  lineno ptr fs:Lineno
)


decl func lexerClose(lex ptr Lexer)
decl func lexerEof(lex ptr Lexer) bool
decl func lexerError(lex ptr Lexer) ptr err:Error

decl func lexerFromStream(stream ptr io:Stream,
                          name ptr uint8) {lex ptr Lexer, err ptr err:Error}

decl func lexerNew(name ptr uint8) {lex ptr Lexer, err ptr err:Error}
decl func lexerNext(lex ptr Lexer) ptr Token

decl func tokenFree(tok ptr Token)
decl func tokenNew(type uint16, value uintptr, line ptr fs:Lineno, end uintptr) ptr Token
decl func tokenStr(tok ptr Token) ptr uint8

decl func ttypeStr(tt uint16) ptr uint8

decl func error(line ptr fs:Lineno, msg ptr uint8) ptr Issue
decl func errorMism(line ptr fs:Lineno, got ptr uint8, expected ptr uint8) ptr Issue
decl func errorLex(lex ptr Lexer, msg ptr uint8) ptr err:Error

decl func tokExtractBegin(tok ptr Token) txt:Line
decl func tokExtractEnd(tok ptr Token) txt:Line

decl func tokDiscardEnd(tok ptr Token) txt:Line
decl func tokDiscardBegin(tok ptr Token) txt:Line


## tokens


decl mut EOF uint16
decl mut NEWLINE uint16
decl mut ALIAS uint16
decl mut AMPER uint16
decl mut AND uint16
decl mut APOS uint16
decl mut ASSIGN uint16
decl mut BREAK uint16
decl mut CAST uint16
decl mut CBRAC uint16
decl mut CCURLY uint16
decl mut COLON uint16
decl mut COMMA uint16
decl mut CONTINUE uint16
decl mut CPAR uint16
decl mut DEC uint16
decl mut DECL uint16
decl mut DIFFERENT uint16
decl mut DIV uint16
decl mut DOT uint16
decl mut DQUEST uint16
decl mut ELSE uint16
decl mut ENDENTRY uint16
decl mut ENDFUNC uint16
decl mut ENDIF uint16
decl mut ENDMETHOD uint16
decl mut ENDWHILE uint16
decl mut ENTRY uint16
decl mut EQUAL uint16
decl mut FALSE uint16
decl mut FATARROW uint16
decl mut FUNC uint16
decl mut ID uint16
decl mut IF uint16
decl mut IMPORT uint16
decl mut INC uint16
decl mut MAJEQ uint16
decl mut MAJOR uint16
decl mut ME uint16
decl mut METHOD uint16
decl mut MINEQ uint16
decl mut MINOR uint16
decl mut MINUS uint16
decl mut MOD uint16
decl mut MODULE uint16
decl mut MUT uint16
decl mut NOT uint16
decl mut NULL uint16
decl mut NUMBER uint16
decl mut OBRAC uint16
decl mut OCURLY uint16
decl mut OPAR uint16
decl mut OR uint16
decl mut PIPE uint16
decl mut PLUS uint16
decl mut POW uint16
decl mut PTR uint16
decl mut QUEST uint16
decl mut RETURN uint16
decl mut SEPARATOR uint16
decl mut SHIFTL uint16
decl mut SHIFTR uint16
decl mut SIZE uint16
decl mut STRING uint16
decl mut STRUCT uint16
decl mut TIMES uint16
decl mut TRUE uint16
decl mut TWOCOLONS uint16
decl mut UMINUS uint16
decl mut VAL uint16
decl mut WHILE uint16
decl mut XOR uint16
