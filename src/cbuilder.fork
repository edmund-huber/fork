#  ctrans, Fork to C transpiler
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2015
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the
#  licenses expressed under Section 1.12 of the MPL v2.


module ctrans


import ast
import ctrans
import err
import io
import kv
import list
import mem
import proc
import tokens
import txt
import tty


func translDump(tr ptr ctrans:Transl, stream ptr io:Stream) ptr err:Error
  if tr'header
    # first-step is buggy like shit, must use trigraphs because
    # `#` gets deleted by the lexer
    io:streamWrite(stream, "??=ifndef ford$$")
    io:streamWrite(stream, tr'modName )
    io:streamWrite(stream, "_h\n")

    io:streamWrite(stream, "??=define ford$$")
    io:streamWrite(stream, tr'modName)
    io:streamWrite(stream, "_h\n\n\n")
  /if

  io:streamWrite(stream, "??=include <stdint.h>\n\n")

  #just in case, you know.
  io:streamWrite(stream, "??=undef NULL\n\n")

  mut includes = txt:csUnwrap(tr'includes)
  io:streamWrite(stream, includes)
  mem:free(includes)

  io:streamWrite(stream, "\n\n")

  mut typedefs = txt:csUnwrap(tr'typedefs)
  io:streamWrite(stream, typedefs)
  mem:free(typedefs)

  io:streamWrite(stream, "\n\n")

  mut externs = txt:csUnwrap(tr'externs)
  io:streamWrite(stream, externs)
  mem:free(externs)

  io:streamWrite(stream, "\n\n")

  mut vars = txt:csUnwrap(tr'vars)
  io:streamWrite(stream, vars)
  mem:free(vars)

  io:streamWrite(stream, "\n\n")

  mut funcs = txt:csUnwrap(tr'funcs)
  io:streamWrite(stream, funcs)
  mem:free(funcs)

  io:streamWrite(stream, "\n\n")

  if tr'header
    io:streamWrite(stream, "\n\n??=endif //ford$$")
    io:streamWrite(stream, tr'modName)
    io:streamWrite(stream, "_h\n\n")
  /if

  return io:streamError(stream)
/func


func translFordInc(tr ptr ctrans:Transl, fordName ptr uint8)
  txt:csAppendStr(tr'includes, "??=include <ford$$")
  txt:csAppendStr(tr'includes, fordName)
  txt:csAppendLine(tr'includes, ".h>")
/func


func translInit(tr ptr ctrans:Transl, header bool, name ptr uint8)
  tr'includes = txt:csNew(40)
  tr'typedefs = txt:csNew(300)
  tr'externs = txt:csNew(300)
  tr'vars = txt:csNew(300)
  tr'funcs = txt:csNew(300)

  tr'header = header
  tr'modName = name
/func


func nullSafestreq(str1,str2 ptr uint8) bool
  return (str1 != null and str2 != null) => txt:strequals(str1, str2) || str1 == str2
/func


func symMod(cs ptr txt:Charstash, modName,name ptr uint8)
  if modName != null
    txt:csAppendStr(cs, modName)
    txt:csAppendStr(cs, "$")
  /if

  txt:csAppendStr(cs, name)
/func


alias LRStr struct(
  left,right ptr txt:Charstash
)


func lrNew() LRStr
  mut ret LRStr

  ret'left  = txt:csNew(20)
  ret'right = txt:csNew(20)

  return ret
/func


func lrDump(lr LRStr, cs ptr txt:Charstash)
  mut left = txt:csUnwrap(lr'left)
  txt:csAppendStr(cs, left)
  mem:free(left)

  mut right = txt:csUnwrap(lr'right)
  txt:csAppendStr(cs, right)
  mem:free(right)
/func


decl csymType func(lr LRStr, type ptr ast:Type, full bool)
decl csymGen func(lr LRStr,
                  moduleName,name ptr uint8,
                  type ptr ast:Type,
                  tdf bool)
decl csym func(cs ptr txt:Charstash,
               moduleName,name ptr uint8,
               type ptr ast:Type,
               tdf bool)

func csymTypeWrap(cs ptr txt:Charstash, type ptr ast:Type)
  mut lr = lrNew()
  csymType(lr, type, false)
  lrDump(lr, cs)
/func


func csymFuncType(lr LRStr, type ptr ast:Type)
  csymType(lr, type'retType, false)

  mut paramsCs = txt:csNew(30)

  mut i uintptr = 0
  mut len = kv:kvLen(type'members)

  txt:csAppendStr(paramsCs, "(")

  while i < len
    if i != 0
      txt:csAppendWord(paramsCs, ",")
    /if

    mut pair = kv:kvGetAt(type'members, i)
    csym(paramsCs, null, cast<ptr uint8>(pair'key), cast<ptr ast:Type>(pair'value), false)
    i++
  /while

  txt:csAppendStr(paramsCs, ")")

  mut params = txt:csUnwrap(paramsCs)

  txt:csPrependStr(lr'right, params)

  mem:free(params)
/func


func csymPtrArrType(lr LRStr, type ptr ast:Type)
  mut tofn = type'retType'type == ast:TYPE_FUNC

  csymType(lr, type'retType, false)

  if tofn
    txt:csAppendStr(lr'left, "(")
  /if

  if type'type == ast:TYPE_PTR
    txt:csAppendStr(lr'left, "*")
  /if

  if tofn
    txt:csPrependStr(lr'right, ")")
  /if

  if type'type == ast:TYPE_LOC
    txt:csPrependStr(lr'right, "]")
    txt:csPrependInt(lr'right, type'itemCount)
    txt:csPrependStr(lr'right, "[")
  /if
/func


func csymStructType(cs ptr txt:Charstash, type ptr ast:Type)
  txt:csAppendWord(cs, "struct")

  if type'name != null
    symMod(cs, type'moduleName, type'name)
  /if

  txt:csAppendLine(cs, " {")

  mut i uintptr = 0
  mut len = kv:kvLen(type'members)

  while i < len
    mut pair = kv:kvGetAt(type'members, i)

    txt:csAppendStr(cs, "  ")
    csym(cs, null, cast<ptr uint8>(pair'key), cast<ptr ast:Type>(pair'value), false)
    txt:csAppendLine(cs, ";")

    i++
  /while

  txt:csAppendStr(cs, "} ")
/func


func csymType(lr LRStr, type ptr ast:Type, full bool)

  if type == null or type'type == ast:TYPE_EMPTY
    txt:csAppendStr(lr'left, "void ")
    return
  /if

  if !full and type'name != null and (type'type == ast:TYPE_STRUCT or type'type == ast:TYPE_FUNC)
    symMod(lr'left, type'moduleName, type'name)
    txt:csAppendStr(lr'left, " ")
    return
  /if

  if type'type == ast:TYPE_BOOL
    txt:csAppendStr(lr'left, "_Bool ")
  else
    if type'type == ast:TYPE_DATA
      txt:csAppendStr(lr'left, "void *")
    else
      if type'type == ast:TYPE_FUNC
        csymFuncType(lr, type)
      else
        if type'type == ast:TYPE_INT
          if !type'isSigned
            txt:csAppendStr(lr'left, "u")
          /if

          txt:csAppendStr(lr'left, "int")
          txt:csAppendInt(lr'left, type'typeSize * 8)
          txt:csAppendStr(lr'left, "_t ")
        else
          if type'type == ast:TYPE_LOC or type'type == ast:TYPE_PTR
            csymPtrArrType(lr, type)
          else
            if type'type == ast:TYPE_NULL
              tty:errln("UNREACHABLE - TYPE NULL CAN'T BE VALID")
              proc:abort()
            else
              if type'type == ast:TYPE_RECALIAS
                txt:csAppendStr(lr'left, "struct ")
                symMod(lr'left, type'moduleName, type'name)
                txt:csAppendStr(lr'left, " ")
              else
                csymStructType(lr'left, type)
              /if
            /if
          /if
        /if
      /if
    /if
  /if
/func


func csymGen(lr LRStr,
             moduleName,name ptr uint8,
             type ptr ast:Type,
             tdf bool)

  csymType(lr, type, tdf)
  symMod(lr'left, moduleName, name)
/func


func csym(cs ptr txt:Charstash,
          moduleName,name ptr uint8,
          type ptr ast:Type,
          tdf bool)

  mut lr = lrNew()
  csymGen(lr, moduleName, name, type, tdf)
  lrDump(lr, cs)

/func


func translExtern(tr ptr ctrans:Transl, sym ptr uint8)
  txt:csAppendWord(tr'externs, "extern")
  txt:csAppendStr(tr'externs, sym)
  txt:csAppendLine(tr'externs, ";")
/func


func pad(cs ptr txt:Charstash, p uintptr)
  mut i uintptr = 0

  while i < p
    txt:csAppend(cs, 32)

    i++
  /while
/func


func dbgLine(cs ptr txt:Charstash, fname ptr uint8, line,p uintptr)
  txt:csAppendStr(cs, "\n")

  pad(cs, p)

  txt:csAppendStr(cs, "??=line ")
  txt:csAppendInt(cs, line)
  txt:csAppendStr(cs, " \"")

  mut pwd = proc:getenv("PWD")

  txt:csAppendStr(cs, pwd)
  txt:csAppendStr(cs, "/")
  txt:csAppendStr(cs, fname)
  txt:csAppendLine(cs, "\"")
/func


alias BlTrans struct(
  decls,vars,stmts ptr list:List
)


alias LineStr struct(
  line ast:Line,
  str ptr uint8
)


func lsFree(ls ptr LineStr)
  mem:free(ls'str)
  mem:free(ls)
/func


func lsNew(line ast:Line, str ptr uint8) ptr LineStr
  mut ls = cast<ptr LineStr>(mem:alloc(size(LineStr)))

  ls'line = line
  ls'str = str

  return ls
/func


func blDump(blt BlTrans, cs ptr txt:Charstash, fname ptr uint8, p uintptr)
  mut i uintptr = 0
  mut dLen = list:listLen(blt'decls)

  while i < dLen
    mut dcl = cast<ptr LineStr>(val list:listGet(blt'decls, i))

    dbgLine(cs, fname, dcl'line'line, p)

    pad(cs, p)

    txt:csAppendWord(cs, "extern")
    txt:csAppendStr(cs, dcl'str)
    txt:csAppendLine(cs, ";")

    lsFree(dcl)

    i++
  /while

  mut vLen = list:listLen(blt'vars)

  i = 0

  while i < vLen
    mut var = cast<ptr LineStr>(val list:listGet(blt'vars, i))

    dbgLine(cs, fname, var'line'line, p)

    pad(cs, p)

    txt:csAppendStr(cs, var'str)
    txt:csAppendLine(cs, ";")

    lsFree(var)

    i++
  /while

  if dLen + vLen > 0
    txt:csAppendLine(cs, "\n")
  /if

  mut sLen = list:listLen(blt'stmts)

  i = 0

  while i < sLen
    mut stmt = cast<ptr LineStr>(val list:listGet(blt'stmts, i))

    dbgLine(cs, fname, stmt'line'line, p)

    pad(cs, p)

    txt:csAppendStr(cs, stmt'str)
    txt:csAppendLine(cs, ";")

    lsFree(stmt)

    i++
  /while

  list:listFree(blt'decls)
  list:listFree(blt'vars)
  list:listFree(blt'stmts)
/func


func blNew() BlTrans
  mut ret BlTrans

  ret'decls = list:listNew()
  ret'vars = list:listNew()
  ret'stmts = list:listNew()

  return ret
/func


decl translBlock func(cs ptr txt:Charstash,
                      root ptr ast:PRoot,
                      block ptr ast:PBlock,
                      fname ptr uint8,
                      p uintptr)


func isBinOp(tok uint16) bool
  return (tok mod 10) < 2
/func


func opConv(tok uint16) ptr uint8
  if tok == tokens:AMPER or tok == tokens:PTR
    return "&"
  /if

  if tok == tokens:AND
    return "&&"
  /if

  if tok == tokens:ASSIGN
    return "="
  /if

  if tok == tokens:DIFFERENT
    return "!="
  /if

  if tok == tokens:DIV
    return "/"
  /if

  if tok == tokens:EQUAL
    return "=="
  /if

  if tok == tokens:MAJEQ
    return ">="
  /if

  if tok == tokens:MAJOR
    return ">"
  /if

  if tok == tokens:MINEQ
    return "<="
  /if

  if tok == tokens:MINOR
    return "<"
  /if

  if tok == tokens:MINUS or tok == tokens:UMINUS
    return "-"
  /if

  if tok == tokens:MOD
    return "%"
  /if

  if tok == tokens:NOT
    return "!"
  /if

  if tok == tokens:OR
    return "||"
  /if

  if tok == tokens:PIPE
    return "|"
  /if

  if tok == tokens:PLUS
    return "+"
  /if

  if tok == tokens:TIMES or tok == tokens:VAL
    return "*"
  /if

  if tok == tokens:XOR
    return "^"
  /if

  tty:errln("UNREACHABLE")
  tty:outint(tok)
  proc:abort()

  return null
/func


func translStringEscape(cs ptr txt:Charstash, str ptr uint8)
  while val str != 0
    if val str == 7
      txt:csAppendStr(cs, "\\a")
    /if

    if val str == 8
      txt:csAppendStr(cs, "\\b")
    /if

    if val str == 12
      txt:csAppendStr(cs, "\\f")
    /if

    if val str == 10
      txt:csAppendStr(cs, "\\n")
    /if

    if val str == 13
      txt:csAppendStr(cs, "\\r")
    /if

    if val str == 9
      txt:csAppendStr(cs, "\\t")
    /if

    if val str == 11
      txt:csAppendStr(cs, "\\v")
    /if

    if val str == 92
      # first-step lexer is CRAP
      txt:csAppend(cs, 92)
      txt:csAppend(cs, 92)
    /if

    if val str == 39
      txt:csAppendStr(cs, "\\'")
    /if

    if val str == 34
      txt:csAppendStr(cs, "\\\"")
    /if

    if val str == 63
      txt:csAppendStr(cs, "\\?")
    /if

    str++
  /while
/func


func translExpr(cs ptr txt:Charstash, root ptr ast:PRoot, pexpr ptr ast:PExpr)

  mut value = pexpr'node'value

  if pexpr'opType == tokens:NUMBER
    txt:csAppendInt(cs, value)
    txt:csAppendStr(cs, "U")

    return
  /if

  if pexpr'opType == tokens:STRING
    txt:csAppendStr(cs, "\"")
    translStringEscape(cs, cast<ptr uint8>(value))
    txt:csAppendStr(cs, "\"")

    return
  /if

  if pexpr'opType == tokens:ID
    txt:csAppendStr(cs, cast<ptr uint8>(value))

    return
  /if

  if pexpr'opType == tokens:NULLPTR
    txt:csAppendStr(cs, "(void*) 0")

    return
  /if

  if pexpr'opType == tokens:TRUE
    txt:csAppendStr(cs, "1")

    return
  /if

  if pexpr'opType == tokens:FALSE
    txt:csAppendStr(cs, "0")

    return
  /if

  if pexpr'opType == tokens:COLON
    mut modName = cast<ptr uint8>(cast<ptr ast:PNode>(val list:listGet(pexpr'node'leaves, 0))'value)
    mut name = cast<ptr uint8>(cast<ptr ast:PNode>(val list:listGet(pexpr'node'leaves, 1))'value)

    symMod(cs, modName, name)

    return
  /if

  if pexpr'opType == tokens:APOS
    mut e1 = cast<ptr ast:PExpr>(val list:listGet(pexpr'node'leaves, 0))
    mut e2 = cast<ptr ast:PExpr>(val list:listGet(pexpr'node'leaves, 1))

    translExpr(cs, root, e1)

    txt:csAppendStr(cs, (e1'type != null and e1'type'type == ast:TYPE_PTR) => "->" || ".")

    translExpr(cs, root, e2)

    return
  /if

  if pexpr'opType == tokens:SIZE
      txt:csAppendStr(cs, "sizeof(")
      csymTypeWrap(cs, pexpr'type)
      txt:csAppendStr(cs, ")")

      return
  /if

  if pexpr'opType == tokens:CAST
    mut expr = cast<ptr ast:PExpr>(val list:listGet(pexpr'node'leaves, 0))

    txt:csAppendStr(cs, "(")
    csymTypeWrap(cs, pexpr'type)
    txt:csAppendStr(cs, ")(")

    translExpr(cs, root, expr)

    txt:csAppendStr(cs, ")")

    return
  /if

  if pexpr'opType == tokens:OPAR
    mut toCall = cast<ptr ast:PExpr>(val list:listGet(pexpr'node'leaves, 0))

    mut callerOk = false

    # Check if this is a function in the same file.
    # If this is true, then the module name should also be added.
    if toCall'opType == tokens:ID
      mut name = cast<ptr uint8>(toCall'node'value)
      mut modName ptr uint8 = root'moduleName != null => root'moduleName'name || null
      mut fDecl = ast:stabGet(root'node'syms, name)

      if fDecl != null and fDecl'declType != ast:PDECL
        symMod(cs, modName, name)
        callerOk = true
      /if
    /if

    if !callerOk
      translExpr(cs, root, toCall)
    /if

    txt:csAppendStr(cs, "(")

    mut i uintptr = 1
    mut len = list:listLen(pexpr'node'leaves)

    while i < len
      mut param = cast<ptr ast:PExpr>(val list:listGet(pexpr'node'leaves, i))

      if i > 1
        txt:csAppendWord(cs, ",")
      /if

      translExpr(cs, root, param)
      i++
    /while

    txt:csAppendStr(cs, ")")

    return
  /if

  if pexpr'opType == tokens:CPAR
    mut e1 = cast<ptr ast:PExpr>(val list:listGet(pexpr'node'leaves, 0))
    mut e2 = cast<ptr ast:PExpr>(val list:listGet(pexpr'node'leaves, 1))

    txt:csAppendStr(cs, "(")

    translExpr(cs, root, e1)

    txt:csAppendStr(cs, ")[")

    translExpr(cs, root, e2)

    txt:csAppendStr(cs, "]")

    return
  /if

  if pexpr'opType == tokens:FATARROW
    mut e1 = cast<ptr ast:PExpr>(val list:listGet(pexpr'node'leaves, 0))
    mut e2 = cast<ptr ast:PExpr>(val list:listGet(pexpr'node'leaves, 1))
    mut e3 = cast<ptr ast:PExpr>(val list:listGet(pexpr'node'leaves, 2))

    txt:csAppendStr(cs, "(")

    translExpr(cs, root, e1)

    txt:csAppendStr(cs, ") ? (")

    translExpr(cs, root, e2)

    txt:csAppendStr(cs, ") : (")

    translExpr(cs, root, e3)

    txt:csAppendStr(cs, ")")

    return
  /if

  if pexpr'opType == tokens:DEC
    mut e = cast<ptr ast:PExpr>(val list:listGet(pexpr'node'leaves, 0))
    translExpr(cs, root, e)

    txt:csAppendStr(cs, "--")

    return
  /if

  if pexpr'opType == tokens:INC
    mut e = cast<ptr ast:PExpr>(val list:listGet(pexpr'node'leaves, 0))
    translExpr(cs, root, e)

    txt:csAppendStr(cs, "++")

    return
  /if

  if isBinOp(pexpr'opType) or pexpr'opType == tokens:MINUS
    mut e1 = cast<ptr ast:PExpr>(val list:listGet(pexpr'node'leaves, 0))
    mut e2 = cast<ptr ast:PExpr>(val list:listGet(pexpr'node'leaves, 1))

    if pexpr'opType == tokens:POW
      txt:csAppendStr(cs, "__forkpow(")
      translExpr(cs, root, e1)
      txt:csAppendStr(cs, ", ")
      translExpr(cs, root, e2)
      txt:csAppendStr(cs, ")")

      return
    /if

    txt:csAppendStr(cs, "(")
    translExpr(cs, root, e1)
    txt:csAppend(cs, 32)
    txt:csAppendStr(cs, opConv(pexpr'opType))
    txt:csAppend(cs, 32)
    translExpr(cs, root, e2)
    txt:csAppendStr(cs, ")")

    return
  /if

  #assume prefix unary now

  mut e = cast<ptr ast:PExpr>(val list:listGet(pexpr'node'leaves, 0))
  txt:csAppendStr(cs, opConv(pexpr'opType))
  txt:csAppendStr(cs, "(")
  translExpr(cs, root, e)
  txt:csAppendStr(cs, ")")

/func


func translIf(stmt ptr ast:PNode, root ptr ast:PRoot, fname ptr uint8, p uintptr) ptr uint8
  mut cs = txt:csNew(100)

  txt:csAppendStr(cs, "if (")

  mut pexpr = cast<ptr ast:PExpr>(val list:listGet(stmt'leaves, 0))

  translExpr(cs, root, pexpr)

  txt:csAppendWord(cs, ")")

  mut block = cast<ptr ast:PBlock>(val list:listGet(stmt'leaves, 1))

  translBlock(cs, root, block, fname, p + 2)

  if stmt'type == ast:PIFELSE
    txt:csAppendStr(cs, " else ")

    block = cast<ptr ast:PBlock>(val list:listGet(stmt'leaves, 2))

    translBlock(cs, root, block, fname, p + 2)
  /if

  return txt:csUnwrap(cs)
/func


func translWhile(stmt ptr ast:PNode, root ptr ast:PRoot, fname ptr uint8, p uintptr) ptr uint8
  mut cs = txt:csNew(100)

  txt:csAppendStr(cs, "while (")

  mut pexpr = cast<ptr ast:PExpr>(val list:listGet(stmt'leaves, 0))

  translExpr(cs, root, pexpr)

  txt:csAppendWord(cs, ")")

  mut block = cast<ptr ast:PBlock>(val list:listGet(stmt'leaves, 1))

  translBlock(cs, root, block, fname, p + 2)

  return txt:csUnwrap(cs)
/func


func translDecl(bl BlTrans, root ptr ast:PRoot, block ptr ast:PBlock, stmt ptr ast:PNode)
  mut isMut = stmt'type == ast:PMUT
  mut pdecl = cast<ptr ast:PDecl>(stmt)
  mut sym = txt:csNew(20)
  mut type = ast:stabTypeof(block'syms, pdecl'sym'name)

  csym(sym, null, pdecl'sym'name, type, false)

  mut ls = lsNew(stmt'begin,txt:csUnwrap(sym))

  list:listAppend(isMut => bl'vars || bl'decls, ls)

  if isMut and list:listLen(stmt'leaves) > 0
    mut expr = cast<ptr ast:PExpr>(val list:listGet(stmt'leaves, 0))
    mut cs = txt:csNew(30)

    txt:csAppendStr(cs, pdecl'sym'name)
    txt:csAppendStr(cs, " = ")

    translExpr(cs, root, expr)

    list:listAppend(bl'stmts, lsNew(expr'node'begin, txt:csUnwrap(cs)))
  /if
/func


func translReturn(stmt ptr ast:PNode, root ptr ast:PRoot) ptr uint8
  mut cs = txt:csNew(30)

  txt:csAppendStr(cs, "return")

  mut expr = list:listGet(stmt'leaves, 0)

  if expr != null
    txt:csAppend(cs, 32)
    translExpr(cs, root, cast<ptr ast:PExpr>(val expr))
  /if

  return txt:csUnwrap(cs)
/func


func translStmt(bl BlTrans, root ptr ast:PRoot, block ptr ast:PBlock, stmt ptr ast:PNode, fname ptr uint8, p uintptr)

  if stmt'type == ast:PIF or stmt'type == ast:PIFELSE
    list:listAppend(bl'stmts, lsNew(stmt'begin, translIf(stmt, root, fname, p)))
  else
    if stmt'type == ast:PMUT or stmt'type == ast:PDECL
      translDecl(bl, root, block, stmt)
    else
      if stmt'type == ast:PWHILE
        list:listAppend(bl'stmts, lsNew(stmt'begin, translWhile(stmt, root, fname, p)))
      else
        if stmt'type == ast:PCONTINUE
          list:listAppend(bl'stmts, lsNew(stmt'begin, txt:strclone("continue")))
        else
          if stmt'type == ast:PBREAK
            list:listAppend(bl'stmts, lsNew(stmt'begin, txt:strclone("break")))
          else
            if stmt'type == ast:PRETURN
              list:listAppend(bl'stmts, lsNew(stmt'begin, translReturn(stmt, root)))
            else
              if stmt'type == ast:PEXPR
                mut cs = txt:csNew(30)

                translExpr(cs, root, cast<ptr ast:PExpr>(stmt))

                list:listAppend(bl'stmts, lsNew(stmt'begin, txt:csUnwrap(cs)))
              /if
            /if
          /if
        /if
      /if
    /if
  /if
/func


func translBlock(cs ptr txt:Charstash,
                 root ptr ast:PRoot,
                 block ptr ast:PBlock,
                 fname ptr uint8,
                 p uintptr)

  mut origp uintptr = p == 0 => 0 || p - 2

  txt:csAppendLine(cs, "{")

  mut bl = blNew()

  mut bLen = list:listLen(block'node'leaves)
  mut i uintptr = 0

  while i < bLen
    mut stmt = cast<ptr ast:PNode>(val list:listGet(block'node'leaves, i))

    translStmt(bl, root, block, stmt, fname, p)

    i++
  /while

  blDump(bl, cs, fname, p)

  dbgLine(cs, fname, block'node'end'line + 1, origp)
  pad(cs, origp)
  txt:csAppendStr(cs, "}")
/func


func translFunc(tr ptr ctrans:Transl,
                root ptr ast:PRoot,
                fname,sym ptr uint8,
                fn ptr ast:PDecl)

  dbgLine(tr'funcs, fname, fn'node'begin'line, 0)
  txt:csAppendWord(tr'funcs, sym)

  mut block = cast<ptr ast:PBlock>(val list:listGet(fn'node'leaves, 0))

  translBlock(tr'funcs, root, block, fname, 2)

  txt:csAppendLine(tr'funcs, "\n")
/func


func ctransGenEntry(tr ptr ctrans:Transl, root ptr ast:PRoot)
  mut entryN = root'entryNode

  dbgLine(tr'funcs, root'fileName, entryN'node'begin'line, 0)
  txt:csAppendStr(tr'funcs, "void __fork_entry() ")

  mut block = cast<ptr ast:PBlock>(val list:listGet(entryN'node'leaves, 0))

  translBlock(tr'funcs, root, block, root'fileName, 2)

  txt:csAppendLine(tr'funcs, "\n")
/func


func translGenSym(moduleName,name ptr uint8, type ptr ast:Type) ptr uint8
  mut cs = txt:csNew(30)

  csym(cs, moduleName, name, type, false)

  return txt:csUnwrap(cs)
/func


func translGlobVar(tr ptr ctrans:Transl, sym ptr uint8, root ptr ast:PRoot, expr ptr ast:PExpr)
  txt:csAppendStr(tr'vars, sym)

  if expr != null
    txt:csAppendStr(tr'vars, " = ")
    translExpr(tr'vars, root, expr)
  /if

  txt:csAppendLine(tr'vars, ";")
/func


func translTypedef(tr ptr ctrans:Transl, name ptr uint8, type ptr ast:Type)
  txt:csAppendWord(tr'typedefs, "typedef")

  csym(tr'typedefs, tr'modName, name, type, true)

  txt:csAppendLine(tr'typedefs, ";\n")
/func
