#  ctrans, Fork to C transpiler
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2015
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the
#  licenses expressed under Section 1.12 of the MPL v2.


module ctrans


import ast
import cs
import ctrans
import err
import io
import libfork
import mem
import proc
import tokens
import txt
import tty


func init(tr ptr ctrans:Transl, header bool, name ptr uint8)
  tr'includes = cs:new(40)
  tr'typedefs = cs:new(300)
  tr'externs = cs:new(300)
  tr'vars = cs:new(300)
  tr'funcs = cs:new(300)

  tr'header = header
  tr'modName = name
/func


func nullSafestreq(str1,str2 ptr uint8) bool
  return (str1? and str2?) => txt:strequals(str1, str2) || str1 == str2
/func


method ctrans:Transl.extern(sym ptr uint8)
  me'externs.addWord("extern")
  me'externs.add(sym)
  me'externs.addLine(";")
/method


func translSym(moduleName ptr uint8, pdecl ptr ast:PDecl, dinfo ptr ast:DeclInfo) ptr uint8
  mut cs = cs:new(30)
  mut name = pdecl'sym'name

  # big hack for int main(int argc, char *argv[])
  if not moduleName? and txt:strequals(name, "main") and dinfo'declType == ast:PFUNCTION
    cs.add("int main(int argc, char *argv[])")
  else
    mut typeName ptr uint8 = null

    if dinfo'declType == ast:PMETHOD
      typeName = ctrans:symMod(pdecl'methodTypeModule, pdecl'methodType)
    /if

    cs.genCsym(typeName, moduleName, name, dinfo'type, false)

    mem:free(typeName)
  /if

  return cs:unwrap(cs)
/func


method ctrans:Transl.function(root ptr ast:PRoot,
                              fname,sym ptr uint8,
                              fn ptr ast:PDecl)

  me'funcs.addDebugLine(fname, fn'node'begin'line, 0)
  me'funcs.addWord(sym)

  mut block = cast<ptr ast:PBlock>(val fn'node'leaves.get(0))

  ctrans:translBlock(me'funcs, ptr me'cnt, root, block, fname, 2)

  me'funcs.addLine("\n")
/method


method ctrans:Transl.forkmain(root ptr ast:PRoot)
  mut entryN = root'entryNode

  me'funcs.addDebugLine(root'fileName, entryN'node'begin'line, 0)
  me'funcs.add("void __fork_entry() ")

  mut block = cast<ptr ast:PBlock>(val entryN'node'leaves.get(0))

  ctrans:translBlock(me'funcs, ptr me'cnt, root, block, root'fileName, 2)

  me'funcs.addLine("\n")
/method


method ctrans:Transl.globVar(sym ptr uint8, root ptr ast:PRoot, expr ptr ast:PExpr)
  me'vars.add(sym)

  if expr?
    me'vars.add(" = ")
    me.globExpr(root, expr)
  /if

  me'vars.addLine(";")
/method


method ctrans:Transl.typedef(name ptr uint8, type ptr ast:Type)
  me'typedefs.addWord("typedef")

  me'typedefs.genCsym(null, me'modName, name, type, true)

  me'typedefs.addLine(";\n")
/method


method ctrans:Transl.dump(stream ptr io:Stream) ptr err:Error
  io:streamWrite(stream, "// generated with ctrans+libfork v")
  io:streamWrite(stream, libfork:VERSION)
  io:streamWrite(stream, "\n\n\n")

  if me'header
    io:streamWrite(stream, "#ifndef ford$$")
    io:streamWrite(stream, me'modName )
    io:streamWrite(stream, "_h\n")

    io:streamWrite(stream, "#define ford$$")
    io:streamWrite(stream, me'modName)
    io:streamWrite(stream, "_h\n\n\n")
  /if

  io:streamWrite(stream, "#include <stdint.h>\n\n")

  #just in case, you know.
  io:streamWrite(stream, "#undef NULL\n\n")

  mut includes = cs:unwrap(me'includes)
  io:streamWrite(stream, includes)
  mem:free(includes)

  io:streamWrite(stream, "\n\n")

  mut typedefs = cs:unwrap(me'typedefs)
  io:streamWrite(stream, typedefs)
  mem:free(typedefs)

  io:streamWrite(stream, "\n\n")

  mut externs = cs:unwrap(me'externs)
  io:streamWrite(stream, externs)
  mem:free(externs)

  io:streamWrite(stream, "\n\n")

  mut vars = cs:unwrap(me'vars)
  io:streamWrite(stream, vars)
  mem:free(vars)

  io:streamWrite(stream, "\n\n")

  mut funcs = cs:unwrap(me'funcs)
  io:streamWrite(stream, funcs)
  mem:free(funcs)

  io:streamWrite(stream, "\n\n")

  if me'header
    io:streamWrite(stream, "\n\n#endif //ford$$")
    io:streamWrite(stream, me'modName)
    io:streamWrite(stream, "_h\n\n")
  /if

  return io:streamError(stream)
/method


method ctrans:Transl.includeFord(fordName ptr uint8)
  me'includes.add("#include <ford$$")
  me'includes.add(fordName)
  me'includes.addLine(".h>")
/method
