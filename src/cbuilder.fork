#  ctrans, Fork to C transpiler
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2015
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the
#  licenses expressed under Section 1.12 of the MPL v2.


module ctrans


import ast
import ctrans
import err
import io
import kv
import list
import mem
import proc
import txt
import tty


func translDump(tr ptr ctrans:Transl, stream ptr io:Stream) ptr err:Error
  if tr'header
    # first-step is buggy like shit, must use trigraphs because
    # `#` gets deleted by the lexer
    io:streamWrite(stream, "??=ifndef ford$$")
    io:streamWrite(stream, tr'modName )
    io:streamWrite(stream, "_h\n")

    io:streamWrite(stream, "??=define ford$$")
    io:streamWrite(stream, tr'modName)
    io:streamWrite(stream, "_h\n\n\n")
  /if

  io:streamWrite(stream, "??=include <stddef.h>\n")
  io:streamWrite(stream, "??=include <stdint.h>\n\n")

  mut includes = txt:csUnwrap(tr'includes)
  io:streamWrite(stream, includes)
  mem:free(includes)

  io:streamWrite(stream, "\n\n")

  mut typedefs = txt:csUnwrap(tr'typedefs)
  io:streamWrite(stream, typedefs)
  mem:free(typedefs)

  io:streamWrite(stream, "\n\n")

  mut externs = txt:csUnwrap(tr'externs)
  io:streamWrite(stream, externs)
  mem:free(externs)

  io:streamWrite(stream, "\n\n")

  mut vars = txt:csUnwrap(tr'vars)
  io:streamWrite(stream, vars)
  mem:free(vars)

  io:streamWrite(stream, "\n\n")

  mut funcs = txt:csUnwrap(tr'funcs)
  io:streamWrite(stream, funcs)
  mem:free(funcs)

  io:streamWrite(stream, "\n\n")

  if tr'header
    io:streamWrite(stream, "\n\n??=endif //ford$$")
    io:streamWrite(stream, tr'modName)
    io:streamWrite(stream, "_h\n\n")
  /if

  return io:streamError(stream)
/func


func translFordInc(tr ptr ctrans:Transl, fordName ptr uint8)
  txt:csAppendStr(tr'includes, "??=include <ford$$")
  txt:csAppendStr(tr'includes, fordName)
  txt:csAppendLine(tr'includes, ".h>")
/func


func translInit(tr ptr ctrans:Transl, header bool, name ptr uint8)
  tr'includes = txt:csNew(40)
  tr'typedefs = txt:csNew(300)
  tr'externs = txt:csNew(300)
  tr'vars = txt:csNew(300)
  tr'funcs = txt:csNew(300)

  tr'header = header
  tr'modName = name
/func


func nullSafestreq(str1,str2 ptr uint8) bool
  return (str1 != null and str2 != null) => txt:strequals(str1, str2) || str1 == str2
/func


func symMod(cs ptr txt:Charstash, modName,name ptr uint8)
  if modName != null
    txt:csAppendStr(cs, modName)
    txt:csAppendStr(cs, "$")
  /if

  txt:csAppendStr(cs, name)
/func


alias LRStr struct(
  left,right ptr txt:Charstash
)


func lrNew() LRStr
  mut ret LRStr

  ret'left  = txt:csNew(20)
  ret'right = txt:csNew(20)

  return ret
/func


func lrDump(lr LRStr, cs ptr txt:Charstash)
  mut left = txt:csUnwrap(lr'left)
  txt:csAppendStr(cs, left)
  mem:free(left)

  mut right = txt:csUnwrap(lr'right)
  txt:csAppendStr(cs, right)
  mem:free(right)
/func


decl csymType func(lr LRStr, type ptr ast:Type, full bool)
decl csymGen func(lr LRStr,
                  moduleName,name ptr uint8,
                  type ptr ast:Type,
                  tdf bool)
decl csym func(cs ptr txt:Charstash,
               moduleName,name ptr uint8,
               type ptr ast:Type,
               tdf bool)

func csymTypeWrap(cs ptr txt:Charstash, type ptr ast:Type)
  mut lr = lrNew()
  csymType(lr, type, false)
  lrDump(lr, cs)
/func


func csymFuncType(lr LRStr, type ptr ast:Type)
  csymType(lr, type'retType, false)

  mut paramsCs = txt:csNew(30)

  mut i uintptr = 0
  mut len = kv:kvLen(type'members)

  txt:csAppendStr(paramsCs, "(")

  while i < len
    if i != 0
      txt:csAppendWord(paramsCs, ",")
    /if

    mut pair = kv:kvGetAt(type'members, i)
    csym(paramsCs, null, cast<ptr uint8>(pair'key), cast<ptr ast:Type>(pair'value), false)
    i++
  /while

  txt:csAppendStr(paramsCs, ")")

  mut params = txt:csUnwrap(paramsCs)

  txt:csPrependStr(lr'right, params)

  mem:free(params)
/func


func csymPtrArrType(lr LRStr, type ptr ast:Type)
  mut tofn = type'retType'type == ast:TYPE_FUNC

  csymType(lr, type'retType, false)

  if tofn
    txt:csAppendStr(lr'left, "(")
  /if

  if type'type == ast:TYPE_PTR
    txt:csAppendStr(lr'left, "*")
  /if

  if tofn
    txt:csPrependStr(lr'right, ")")
  /if

  if type'type == ast:TYPE_LOC
    txt:csPrependStr(lr'right, "]")
    txt:csPrependInt(lr'right, type'itemCount)
    txt:csPrependStr(lr'right, "[")
  /if
/func


func csymStructType(cs ptr txt:Charstash, type ptr ast:Type)
  txt:csAppendWord(cs, "struct")

  if type'name != null
    symMod(cs, type'moduleName, type'name)
  /if

  txt:csAppendLine(cs, " {")

  mut i uintptr = 0
  mut len = kv:kvLen(type'members)

  while i < len
    mut pair = kv:kvGetAt(type'members, i)

    txt:csAppendStr(cs, "  ")
    csym(cs, null, cast<ptr uint8>(pair'key), cast<ptr ast:Type>(pair'value), false)
    txt:csAppendLine(cs, ";")

    i++
  /while

  txt:csAppendStr(cs, "} ")
/func


func csymType(lr LRStr, type ptr ast:Type, full bool)

  if type == null or type'type == ast:TYPE_EMPTY
    txt:csAppendStr(lr'left, "void ")
    return
  /if

  if !full and type'name != null and (type'type == ast:TYPE_STRUCT or type'type == ast:TYPE_FUNC)
    symMod(lr'left, type'moduleName, type'name)
    txt:csAppendStr(lr'left, " ")
    return
  /if

  if type'type == ast:TYPE_BOOL
    txt:csAppendStr(lr'left, "_Bool ")
  else
    if type'type == ast:TYPE_DATA
      txt:csAppendStr(lr'left, "void* ")
    else
      if type'type == ast:TYPE_FUNC
        csymFuncType(lr, type)
      else
        if type'type == ast:TYPE_INT
          if !type'isSigned
            txt:csAppendStr(lr'left, "u")
          /if

          txt:csAppendStr(lr'left, "int")
          txt:csAppendInt(lr'left, type'typeSize * 8)
          txt:csAppendStr(lr'left, "_t ")
        else
          if type'type == ast:TYPE_LOC or type'type == ast:TYPE_PTR
            csymPtrArrType(lr, type)
          else
            if type'type == ast:TYPE_NULL
              tty:errln("UNREACHABLE - TYPE NULL CAN'T BE VALID")
              proc:abort()
            else
              if type'type == ast:TYPE_RECALIAS
                txt:csAppendStr(lr'left, "struct ")
                symMod(lr'left, type'moduleName, type'name)
                txt:csAppendStr(lr'left, " ")
              else
                csymStructType(lr'left, type)
              /if
            /if
          /if
        /if
      /if
    /if
  /if
/func


func csymGen(lr LRStr,
             moduleName,name ptr uint8,
             type ptr ast:Type,
             tdf bool)

  csymType(lr, type, tdf)
  symMod(lr'left, moduleName, name)
/func


func csym(cs ptr txt:Charstash,
          moduleName,name ptr uint8,
          type ptr ast:Type,
          tdf bool)

  mut lr = lrNew()
  csymGen(lr, moduleName, name, type, tdf)
  lrDump(lr, cs)

/func


func translExtern(tr ptr ctrans:Transl, sym ptr uint8)
  txt:csAppendWord(tr'externs, "extern")
  txt:csAppendStr(tr'externs, sym)
  txt:csAppendLine(tr'externs, ";")
/func


func pad(cs ptr txt:Charstash, p uintptr)
  mut i uintptr = 0

  while i < p
    txt:csAppend(cs, 32)

    i++
  /while
/func


func dbgLine(cs ptr txt:Charstash, fname ptr uint8, line uintptr, p uintptr)
  pad(cs, p)

  txt:csAppendStr(cs, "\n??=line ")
  txt:csAppendInt(cs, line)
  txt:csAppendStr(cs, " \"")

  mut pwd = proc:getenv("PWD")

  txt:csAppendStr(cs, pwd)
  txt:csAppendStr(cs, "/")
  txt:csAppendStr(cs, fname)
  txt:csAppendLine(cs, "\"")
/func


alias BlTrans struct(
  decls,vars,stmt ptr list:List
)


func blDump(blt BlTrans, cs ptr txt:Charstash, p uintptr)
  mut i uintptr = 0
  mut dLen = list:listLen(blt'decls)

  while i < dLen
    mut dcl = cast<ptr uint8>(val list:listGet(blt'decls, i))

    pad(cs, p)

    txt:csAppendWord(cs, "extern")
    txt:csAppendStr(cs, dcl)
    txt:csAppendLine(cs, ";")

    mem:free(dcl)

    i++
  /while

  mut vLen = list:listLen(blt'vars)

  i = 0

  while i < vLen
    mut var = cast<ptr uint8>(val list:listGet(blt'vars, i))

    pad(cs, p)

    txt:csAppendStr(cs, var)
    txt:csAppendLine(cs, ";")

    mem:free(var)

    i++
  /while

  if dLen + vLen > 0
    txt:csAppendLine(cs, "\n")
  /if

  mut sLen = list:listLen(blt'stmt)

  i = 0

  while i < sLen
    mut stmt = cast<ptr uint8>(val list:listGet(blt'stmt, i))

    pad(cs, p)

    txt:csAppendStr(cs, stmt)
    txt:csAppendLine(cs, ";")

    mem:free(stmt)

    i++
  /while

  list:listFree(blt'decls)
  list:listFree(blt'vars)
  list:listFree(blt'stmt)
/func


func blNew() BlTrans
  mut ret BlTrans

  ret'decls = list:listNew()
  ret'vars = list:listNew()
  ret'stmt = list:listNew()

  return ret
/func


func translStmt(bl BlTrans, block ptr ast:PBlock, stmt ptr ast:PNode)
  mut cs = txt:csNew(40)

  if stmt'type == ast:PIF

  else
    mut isMut = stmt'type == ast:PMUT
    mut isDecl = stmt'type == ast:PDECL

    if isMut or isDecl
      mut pdecl = cast<ptr ast:PDecl>(stmt)
      mut sym = txt:csNew(20)
      mut type = ast:stabTypeof(block'syms, pdecl'sym'name)

      csym(sym, null, pdecl'sym'name, type, false)

      mut sstr = txt:csUnwrap(sym)

      list:listAppend(isMut => bl'vars || bl'decls, sstr)
    /if
  /if

  bl'stmt
/func


func translBlock(cs ptr txt:Charstash,
                 block ptr ast:PBlock,
                 fname ptr uint8,
                 p uintptr)

  mut origp uintptr = p == 0 => 0 || p - 2

  txt:csAppendLine(cs, "{")

  mut bl = blNew()

  mut bLen = list:listLen(block'node'leaves)
  mut i uintptr = 0

  while i < bLen
    mut stmt = cast<ptr ast:PNode>(val list:listGet(block'node'leaves, i))

    translStmt(bl, block, stmt)

    i++
  /while

  blDump(bl, cs, p)

  dbgLine(cs, fname, block'node'end'line + 1, origp)
  txt:csAppendLine(cs, "}\n\n")
/func


func translFunc(tr ptr ctrans:Transl,
                fname,sym ptr uint8,
                fn ptr ast:PDecl)

  dbgLine(tr'funcs, fname, fn'node'begin'line, 0)
  txt:csAppendWord(tr'funcs, sym)

  mut block = cast<ptr ast:PBlock>(val list:listGet(fn'node'leaves, 0))

  translBlock(tr'funcs, block, fname, 2)
/func


func translGenSym(moduleName,name ptr uint8, type ptr ast:Type) ptr uint8
  mut cs = txt:csNew(30)

  csym(cs, moduleName, name, type, false)

  return txt:csUnwrap(cs)
/func


func translGlobVar(tr ptr ctrans:Transl, sym ptr uint8, expr ptr ast:PExpr)
  txt:csAppendStr(tr'vars, sym)

  txt:csAppendLine(tr'vars, ";")
/func


func translTypedef(tr ptr ctrans:Transl, name ptr uint8, type ptr ast:Type)
  txt:csAppendWord(tr'typedefs, "typedef")

  csym(tr'typedefs, tr'modName, name, type, true)

  txt:csAppendLine(tr'typedefs, ";\n")
/func
