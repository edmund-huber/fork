#  Second Step - Experimental Fork Compiler
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2014
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the
#  licenses expressed under Section 1.12 of the MPL v2.

import lex
import spring
import syms
import synt
import utils


func parserNew(filename ptr uint8) ptr synt:Parser
  mut ret = cast<ptr synt:Parser>(spring:zalloc(size(synt:Parser)))
  ret'filename = spring:strclone(filename)

  return ret
/func


func parserFree(parser ptr synt:Parser)
  if parser != null
    spring:free(parser'filename)
    spring:free(parser)
  /if
/func


func theresError(ctx ptr synt:Context) bool
  return ctx'prs'err != null
/func


func nextTok(ctx ptr synt:Context) ptr lex:Token
  mut tok = ctx'next
  if ctx'last != null
    lex:linenoFree(ctx'last)
  /if

  ctx'last = lex:linenoClone(tok'lineno)

  ctx'next = lex:lexerNext(ctx'lex)
  ctx'prs'err = lex:lexerError(ctx'lex)
  if ctx'prs'err != null
    return null
  /if

  return tok
/func


func discardTok(ctx ptr synt:Context)
  lex:tokenFree(nextTok(ctx))
/func


# if the expected token is not given, then the Parser gets its error set
func createExpectedError(ctx ptr synt:Context, expected, got ptr lex:Token)
  ctx'prs'err = utils:errorMism(ctx'last, lex:tokenStr(expected), lex:tokenStr(got))
/func


# get the expected token or null for error.
func expect(ctx ptr synt:Context, ttype uint16) ptr lex:Token
  mut got = nextTok(ctx)
  if theresError(ctx)
    return null
  /if

  mut expected lex:Token
  expected'type = ttype
  if (got == null and ttype != lex:EOF) or got'type != ttype
    createExpectedError(ctx, ptr expected, got)
    return null
  /if

  return got
/func


func expectDiscard(ctx ptr synt:Context, ttype uint16) bool
  mut tok = expect(ctx, ttype)
  lex:tokenFree(tok)

  return tok != null
/func


# parses, if present, the module name. Returns null if none or error
func parserParseModuleName(ctx ptr synt:Context) ptr uint8
  if ctx'next'type == lex:MODULE
    lex:tokenFree(nextTok(ctx)) # discard 'module'

    mut name = expect(ctx, lex:ID)
    if name != null
      mut temp = expect(ctx, lex:NEWLINE)
      if temp == null
        return null
      /if
      lex:tokenFree(temp)

      mut ret = spring:strclone(cast<ptr uint8>(name'value))
      lex:tokenFree(name)

      return ret
    /if
  /if

  return null
/func


func parserParseImport(ctx ptr synt:Context) ptr uint8
  if ctx'next'type == lex:IMPORT
    lex:tokenFree(nextTok(ctx)) # discard 'import'

    mut name = expect(ctx, lex:ID)
    if name != null
      mut temp = expect(ctx, lex:NEWLINE)
      if temp == null
        return null
      /if
      lex:tokenFree(temp)

      mut ret = spring:strclone(cast<ptr uint8>(name'value))
      lex:tokenFree(name)

      return ret
    /if
  /if

  return null
/func


# parses the 'import' statements, or returns a null pointer if empty
func parserParseImports(ctx ptr synt:Context) ptr spring:Vector
  mut ret = spring:vectNew(5)
  mut importLine ptr uint8

  while (importLine = parserParseImport(ctx)) != null
    spring:vectAppend(ret, importLine)
  /while

  return ret
/func


func parserParseIdType(ctx ptr synt:Context, name ptr uint8) ptr syms:Type
  mut moduleName ptr uint8 = null

  if ctx'next != null and ctx'next'type == lex:COLON
    # discard ':'
    lex:tokenFree(nextTok(ctx))

    mut tok = expect(ctx, lex:ID)
    if tok == null
      return null
    /if

    moduleName = name
    name = spring:strclone(cast<ptr uint8>(tok'value))

    lex:tokenFree(tok)
  /if

  return syms:typeNew(name, moduleName, syms:typeDescrNew(syms:TYPE_ID, null, null))
/func


func tokenIsTypeStart(tok ptr lex:Token) bool
  mut ttype = tok'type
  return ttype == lex:STRUCT or ttype == lex:FUNC or ttype == lex:PTR or ttype == lex:VAL or ttype == lex:ID
/func


decl parserParseType func(ctx ptr synt:Context) ptr syms:Type


# if the next token exists and it's a lex:NEWLINE, then discards it
func parserDiscardNewLine(ctx ptr synt:Context)
  if ctx'next != null and ctx'next'type == lex:NEWLINE
    synt:discardTok(ctx)
  /if
/func

func parserParseIdList(ctx ptr synt:Context) ptr spring:List
  mut tok ptr lex:Token
  mut ret = spring:listNew()
  while true
    tok = expect(ctx, lex:ID)
    if tok == null
      break
    /if

    spring:listAppend(ret, spring:strclone(cast<ptr uint8>(tok'value)))
    lex:tokenFree(tok)

    if ctx'next == null
      ctx'prs'err = utils:errorMism(ctx'last, "a ',' or an identifier", "end of file")
      break
    /if

    if ctx'next'type != lex:COMMA
      return ret
    /if

    # discard comma
    synt:discardTok(ctx)
  /while

  spring:listFreeAll(ret, ptr spring:free)
  return null
/func


func makeSymsAndInsertInList(syms ptr spring:List, ids ptr spring:List, type ptr syms:Type)
  mut len = spring:listLen(ids)
  mut i uintptr = 0
  mut elem ptr uint8
  mut sym ptr syms:Symbol

  while i < len
    elem = cast<ptr uint8>(val spring:listGet(ids, i))
    sym = syms:symbolNew(elem, type)
    spring:listAppend(syms, sym)
    i++
  /while

  spring:listFree(ids)
/func


func parserParseStructBodyVars(ctx ptr synt:Context, syms ptr spring:List) bool

  # allow multiline struct/function header declarations
  parserDiscardNewLine(ctx)

  if ctx'next == null
    ctx'prs'err = utils:errorMism(ctx'last, "an identifier or a ')'", "end of file")
    return false
  /if

  if ctx'next'type == lex:CPAR
    return false
  /if

  mut ids = parserParseIdList(ctx)
  if ids == null
    return false
  /if

  mut type = parserParseType(ctx)
  if type == null
    spring:listFreeAll(ids, ptr spring:free)
    return false
  /if

  makeSymsAndInsertInList(syms, ids, type)

  return true
/func


func parserParseStructBody(ctx ptr synt:Context) ptr spring:List
  lex:tokenFree(expect(ctx, lex:OPAR))
  if theresError(ctx)
    return null
  /if

  mut strBody = spring:listNew()

  # each iteration parses a sequence of 'a,b,c,d type' or a full list (if this is a function header)
  while parserParseStructBodyVars(ctx, strBody)
    if ctx'next != null and ctx'next'type == lex:CPAR
      break
    /if

    if !synt:expectDiscard(ctx, lex:COMMA)
      spring:listFreeAll(strBody, cast<ptr func(item data)>(ptr utils:decRef))
      return null
    /if
  /while

  if theresError(ctx)
    spring:listFreeAll(strBody, cast<ptr func(item data)>(ptr utils:decRef))
    return null
  /if

  if !synt:expectDiscard(ctx, lex:CPAR)
    spring:listFreeAll(strBody, cast<ptr func(item data)>(ptr utils:decRef))
    return null
  /if

  return strBody
/func


func parserParseFunctionType(ctx ptr synt:Context) ptr syms:Type
  mut args = parserParseStructBody(ctx)
  if theresError(ctx)
    return null
  /if

  mut retType ptr syms:Type = null

  if ctx'next != null and tokenIsTypeStart(ctx'next)
    retType = parserParseType(ctx)
  /if

  return syms:typeNew(null, null, syms:typeDescrNew(syms:TYPE_FUNC, retType, args))
/func

func parserParseStruct(ctx ptr synt:Context) ptr syms:Type
  mut args = parserParseStructBody(ctx)
  if theresError(ctx)
    return null
  /if

  return syms:typeNew(null, null, syms:typeDescrNew(syms:TYPE_STRUCT, null, args))
/func


func parserParseType(ctx ptr synt:Context) ptr syms:Type
  if ctx'next == null
    ctx'prs'err = utils:errorMism(ctx'last, "a valid type", "end of file")
    return null
  /if

  mut tok = nextTok(ctx)
  mut ret ptr syms:Type = null

  if tok'type == lex:FUNC
    ret = parserParseFunctionType(ctx)
  /if

  if tok'type == lex:ID
    ret = parserParseIdType(ctx, spring:strclone(cast<ptr uint8>(tok'value)))
  /if

  if tok'type == lex:PTR
    # parses the real type (after ptr)
    mut realType = parserParseType(ctx)
    ret = syms:typeNew(null, null, syms:typeDescrNew(syms:TYPE_PTR, realType, null))
  /if

  if tok'type == lex:STRUCT
    ret = parserParseStruct(ctx)
  /if

  if tok'type == lex:VAL
    # parses the real type (after val)
    ret = parserParseType(ctx)
  /if

  if ret == null and !theresError(ctx)
    ctx'prs'err = utils:errorMism(ctx'last, "a valid type", lex:tokenStr(tok))
  /if

  lex:tokenFree(tok)
  return ret
/func


func parserParseDeclaration(ctx ptr synt:Context, declType uint16) ptr synt:PNode
  # discard 'var' or 'decl'
  synt:discardTok(ctx)

  mut idTok = expect(ctx, lex:ID)
  if idTok == null
    return null
  /if

  mut id = spring:strclone(cast<ptr uint8>(idTok'value))

  lex:tokenFree(idTok)

  if ctx'next == null
    ctx'prs'err = utils:errorMism(ctx'last, "a type or an '='", "EOF")
    spring:free(id)
    return null
  /if

  mut type ptr syms:Type = null

  if ctx'next'type != lex:ASSIGN
    type = parserParseType(ctx)
    if type == null
      spring:free(id)
      return null
    /if
  /if

  mut pdecl = synt:pdeclNew(declType, syms:symbolNew(id, type))

  if ctx'next == null
    ctx'prs'err = utils:errorMism(ctx'last, "a type or an '='", "EOF")
    synt:pnodeFree(cast<ptr synt:PNode>(pdecl))
    return null
  /if


  if ctx'next'type == lex:ASSIGN
    synt:discardTok(ctx)

    mut expr = synt:parserParseExpr(ctx)
    if expr == null
      synt:pnodeFree(cast<ptr synt:PNode>(pdecl))
      return null
    /if

    synt:pnodeAppendChild(cast<ptr synt:PNode>(pdecl), cast<ptr synt:PNode>(expr))
  /if

  return cast<ptr synt:PNode>(pdecl)
/func


func parserParseDecl(ctx ptr synt:Context) ptr synt:PNode
  return parserParseDeclaration(ctx, synt:PDECL)
/func


func parserParseMut(ctx ptr synt:Context) ptr synt:PNode
  return parserParseDeclaration(ctx, synt:PMUT)
/func


func parserParseAlias(ctx ptr synt:Context) ptr synt:PNode
  # discard 'alias'
  lex:tokenFree(nextTok(ctx))

  mut name = expect(ctx, lex:ID)
  if name != null
    mut type = parserParseType(ctx)
    if type == null
      return null
    /if

    mut palias = synt:pdeclNew(synt:PALIAS, syms:symbolNew(cast<ptr uint8>(name'value), type))

    return ptr palias'node
  /if

  return null
/func


decl parserParseBody func(ctx ptr synt:Context, pnode ptr synt:PNode, isEndToken ptr func(tok ptr lex:Token) bool) bool


func matchWhileEndTok(tok ptr lex:Token) bool
  return tok'type == lex:ENDWHILE
/func


func parserParseWhile(ctx ptr synt:Context) ptr synt:PNode
  synt:discardTok(ctx) #discard while token

  mut expr = cast<ptr synt:PNode>(synt:parserParseExpr(ctx))
  if expr == null
    return null
  /if

  if !synt:expectDiscard(ctx, lex:NEWLINE)
    synt:pnodeFree(expr)
    return null
  /if

  mut whileBlock = synt:pnodeNew(synt:PWHILE, 0)
  synt:pnodeAppendChild(whileBlock, expr)

  if !parserParseBody(ctx, whileBlock, ptr matchWhileEndTok)
    synt:pnodeFree(whileBlock)
    return null
  /if

  synt:discardTok(ctx) #discard /while

  return whileBlock
/func


func matchIfElseEndTok(tok ptr lex:Token) bool
  return tok'type == lex:ENDIF or tok'type == lex:ELSE
/func

func matchIfEndTok(tok ptr lex:Token) bool
  return tok'type == lex:ENDIF
/func


func parserParseIf(ctx ptr synt:Context) ptr synt:PNode
  synt:discardTok(ctx) #discard if token

  mut expr = cast<ptr synt:PNode>(synt:parserParseExpr(ctx))
  if expr == null
    return null
  /if

  if !synt:expectDiscard(ctx, lex:NEWLINE)
    synt:pnodeFree(expr)
    return null
  /if

  mut block = synt:pnodeNew(synt:PIF, 0)
  synt:pnodeAppendChild(block, expr)

  mut mainBlock = synt:pnodeNew(synt:PBLOCK, 0)
  synt:pnodeAppendChild(block, mainBlock)

  if !parserParseBody(ctx, mainBlock, ptr matchIfElseEndTok)
    synt:pnodeFree(block)
    return null
  /if

  if ctx'next'type == lex:ELSE
    mut elseBlock = synt:pnodeNew(synt:PBLOCK, 0)
    synt:pnodeAppendChild(block, elseBlock)

    synt:discardTok(ctx) #discard else
    if !synt:expectDiscard(ctx, lex:NEWLINE)
      synt:pnodeFree(block)
      return null
    /if

    if !parserParseBody(ctx, elseBlock, ptr matchIfEndTok)
      synt:pnodeFree(block)
      return null
    /if
  /if

  synt:discardTok(ctx) #discard /if

  return block
/func


func parserParseReturn(ctx ptr synt:Context) ptr synt:PNode
  synt:discardTok(ctx) # discard "return"

  mut returnNode = synt:pnodeNew(synt:PRETURN, 0)
  if ctx'next != null and ctx'next'type != lex:NEWLINE
    mut expr = synt:parserParseExpr(ctx)
    if expr == null
      synt:pnodeFree(returnNode)
      return null
    /if
    synt:pnodeAppendChild(returnNode, cast<ptr synt:PNode>(expr))
  /if

  return returnNode
/func


func parserParseStatement(ctx ptr synt:Context) ptr synt:PNode

  if ctx'next == null
    ctx'prs'err = utils:errorMism(ctx'last, "a statement or an expression", "EOF")
  /if

  if ctx'next'type == lex:BREAK
    return synt:pnodeNew(synt:PBREAK, 0)
  /if

  if ctx'next'type == lex:CONTINUE
    return synt:pnodeNew(synt:PCONTINUE, 0)
  /if

  if ctx'next'type == lex:DECL
    return parserParseDecl(ctx)
  /if

  if ctx'next'type == lex:IF
    return parserParseIf(ctx)
  /if

  if ctx'next'type == lex:MUT
    return parserParseMut(ctx)
  /if

  if ctx'next'type == lex:RETURN
    return parserParseReturn(ctx)
  /if

  if ctx'next'type == lex:WHILE
    return parserParseWhile(ctx)
  /if

  return cast<ptr synt:PNode>(synt:parserParseExpr(ctx))
/func


func parserParseBody(ctx ptr synt:Context, block ptr synt:PNode, isEndToken ptr func(tok ptr lex:Token) bool) bool

  while ctx'next != null and !isEndToken(ctx'next)
    mut statement = parserParseStatement(ctx)
    if statement == null
      return false
    /if

    synt:pnodeAppendChild(block, statement)

    if !synt:expectDiscard(ctx, lex:NEWLINE)
      return false
    /if
  /while

  if ctx'next == null
    return false
  /if

  # if ctx'next is not null, then the while above quitted because
  # isEndToken(ctx'next) == true.

  return true
/func


func parserMakeFunction(ctx ptr synt:Context,
                        pType uint16,
                        name ptr uint8,
                        type ptr syms:Type,
                        endTType uint16,
                        isEndToken ptr func(tok ptr lex:Token) bool) ptr synt:PNode

  if !expectDiscard(ctx, lex:NEWLINE)
    return null
  /if

  mut funcNode = cast<ptr synt:PNode>(synt:pdeclNew(pType, syms:symbolNew(name, type)))

  if !parserParseBody(ctx, funcNode, isEndToken)
    synt:pnodeFree(funcNode)
    return null
  /if

  if !synt:expectDiscard(ctx, endTType)
    synt:pnodeFree(funcNode)
    return null
  /if



  return funcNode

/func


func makeEntryType() ptr syms:Type
  return syms:typeNew(null, null,syms:typeDescrNew(syms:TYPE_FUNC, null, null))
/func


func matchEntryEndTok(tok ptr lex:Token) bool
  return tok'type == lex:ENDENTRY
/func


func parserParseEntry(ctx ptr synt:Context) ptr synt:PNode
  discardTok(ctx) #discard "entry"

  return parserMakeFunction(ctx, synt:PENTRY, spring:strclone("_fork_entry"), makeEntryType(), lex:ENDENTRY, ptr matchEntryEndTok)
/func


func parserParseFuncName(ctx ptr synt:Context) ptr uint8
  mut nameTok = expect(ctx, lex:ID)
  if nameTok == null
    return null
  /if

  mut name = spring:strclone(cast<ptr uint8>(nameTok'value))

  lex:tokenFree(nameTok)

  return name

/func


func matchFuncEndTok(tok ptr lex:Token) bool
  return tok'type == lex:ENDFUNC
/func


func parserParseFunc(ctx ptr synt:Context) ptr synt:PNode
  discardTok(ctx) #discard "func"

  mut name = parserParseFuncName(ctx)
  if name == null
    return null
  /if

  mut type = parserParseFunctionType(ctx)

  if type == null
    spring:free(name)
    return null
  /if

  return parserMakeFunction(ctx, synt:PFUNCTION, name, type, lex:ENDFUNC, ptr matchFuncEndTok)
/func


func parserParseDefinition(ctx ptr synt:Context) ptr synt:PNode

  if ctx'next == null
    return null
  /if

  if ctx'next'type == lex:ALIAS
    return parserParseAlias(ctx)
  /if

  if ctx'next'type == lex:DECL
    return parserParseDecl(ctx)
  /if

  if ctx'next'type == lex:ENTRY
    return parserParseEntry(ctx)
  /if

  if ctx'next'type == lex:FUNC
    return parserParseFunc(ctx)
  /if

  if ctx'next'type == lex:MUT
    return  parserParseMut(ctx)
  /if

  ctx'prs'err = utils:errorMism(ctx'last, "'alias', 'decl', 'entry', 'func' or 'var'", lex:tokenStr(ctx'next))

  return null

/func

# parses the root node
func parserParseProgram(ctx ptr synt:Context) ptr synt:PNode

  # parse module name
  mut moduleName = parserParseModuleName(ctx)

  if theresError(ctx)
    return null
  /if

  # parse imports
  mut imports = parserParseImports(ctx)

  if theresError(ctx)
    return null
  /if

  mut pnode = cast<ptr synt:PNode>(synt:pprogramNew(moduleName, imports))

  mut definition ptr synt:PNode = null

  while (definition = parserParseDefinition(ctx)) != null
    synt:pnodeAppendChild(pnode, definition)

    if ctx'next != null and !synt:expectDiscard(ctx, lex:NEWLINE)
      synt:pnodeFree(pnode)
      return null
    /if
  /while

  if theresError(ctx)
    synt:pnodeFree(pnode)
    return null
  /if

  return pnode

/func


func parserParse(parser ptr synt:Parser) ptr synt:PNode

  mut lex = lex:lexerNew(parser'filename, ptr parser'err)
  if parser'err != null
    return null
  /if

  # init synt:Context
  mut ctx synt:Context
  ctx'prs = parser
  ctx'lex = lex
  ctx'next = lex:lexerNext(lex)
  ctx'last = null

  if (parser'err = lex:lexerError(lex)) != null
    return null
  /if

  mut ret = parserParseProgram(ptr ctx)

  lex:lexerClose(lex)

  return ret

/func


func pnodeAppendChild(pnode, child ptr synt:PNode) ptr synt:PNode

  if pnode != null and child != null
    spring:vectAppend(pnode'leaves, child)

    child'parent = pnode
  /if

  return pnode
/func


func pnodeFree(pnode ptr synt:PNode)
  if pnode != null
    if synt:isPProgram(pnode)

      mut pprog = cast<ptr synt:PProgram>(pnode)
      spring:free(pprog'moduleName)
      spring:vectFreeAll(pprog'imports, ptr spring:free)

    /if

    if synt:isPDecl(pnode)

      mut pdecl = cast<ptr synt:PDecl>(pnode)
      utils:decRef(pdecl'sym)

    /if

    # remember to fix PEXPR leaks.

    spring:vectFreeAll(pnode'leaves, ptr pnodeFree)
    spring:free(pnode)
  /if
/func


func pnodeNew(type uint16, value uintptr) ptr synt:PNode

  mut pnode = cast<ptr synt:PNode>(spring:zalloc(size(synt:PNode)))
  pnode'type = type
  pnode'value = value
  pnode'leaves = spring:vectNew(2)

  return pnode
/func


func pdeclNew(nodeType uint16, sym ptr syms:Symbol) ptr synt:PDecl

  mut pdecl = cast<ptr synt:PDecl>(spring:zalloc(size(synt:PDecl)))
  pdecl'node'type = nodeType
  pdecl'node'leaves = spring:vectNew(2)

  utils:incRef(sym)

  pdecl'sym = sym

  return pdecl
/func


func pprogramNew(moduleName ptr uint8, imports ptr spring:Vector) ptr synt:PProgram

  mut pprog = cast<ptr synt:PProgram>(spring:zalloc(size(synt:PProgram)))
  pprog'node'type = synt:PPROGRAM
  pprog'node'leaves = spring:vectNew(5)
  pprog'moduleName = moduleName
  pprog'imports = imports
  pprog'node'parent = null

  return pprog

/func


func isPDecl(pnode ptr synt:PNode) bool
  return pnode != null and pnode'type == synt:PALIAS or pnode'type == synt:PDECL or pnode'type == synt:PMUT or pnode'type == synt:PENTRY or pnode'type == synt:PFUNCTION
/func


func isPExpr(pnode ptr synt:PNode) bool
  return pnode != null and pnode'type == synt:PEXPR
/func


func isPProgram(pnode ptr synt:PNode) bool
  return pnode != null and pnode'type == synt:PPROGRAM
/func


mut PPROGRAM   uint16 = 10
mut PENTRY     uint16 = 20
mut PFUNCTION  uint16 = 30
mut PALIAS     uint16 = 40
mut PDECL      uint16 = 50
mut PMUT       uint16 = 60
mut PIF        uint16 = 70
mut PEXPR      uint16 = 80
mut PBREAK     uint16 = 90
mut PCONTINUE  uint16 = 100
mut PRETURN    uint16 = 110
mut PIFELSE    uint16 = 120
mut PWHILE     uint16 = 130
mut PBLOCK     uint16 = 140
