#  Second Step - Experimental Helm Compiler
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2014
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the
#  licenses expressed under Section 1.12 of the MPL v2.

import lex
import spring
import synt
import utils


func parserNew(filename ptr uint8) ptr synt:Parser
  mut ret = cast<ptr synt:Parser>(spring:zalloc(size(synt:Parser)))
  ret'filename = spring:strclone(filename)

  return ret
/func


func parserFree(parser ptr synt:Parser)
  if parser != null
    spring:free(parser'filename)
    spring:free(parser)
  /if
/func


func theresError(ctx ptr synt:Context) bool
  return ctx'prs'err != null
/func


func nextTok(ctx ptr synt:Context) ptr lex:Token
  mut tok = ctx'next
  if ctx'last'filename != null
    spring:free(ctx'last'filename)
  /if

  ctx'last = val tok'lineno
  ctx'last'filename = ctx'lex'lineno'filename # we're sure this isn't going to fade randomly

  ctx'next = lex:lexerNext(ctx'lex)
  ctx'prs'err = lex:lexerError(ctx'lex)
  if ctx'prs'err != null
    return null
  /if

  return tok
/func


func discardTok(ctx ptr synt:Context)
  lex:tokenFree(nextTok(ctx))
/func


# if the expected token is not given, then the Parser gets its error set
func createExpectedError(ctx ptr synt:Context, expected, got ptr lex:Token)
  ctx'prs'err = utils:errorMism(ptr ctx'last, lex:tokenStr(expected), lex:tokenStr(got))
/func


# get the expected token or null for error.
func expect(ctx ptr synt:Context, ttype uint16) ptr lex:Token
  mut got = nextTok(ctx)
  if theresError(ctx)
    return null
  /if

  mut expected lex:Token
  expected'type = ttype
  if (got == null and ttype != lex:EOF) or got'type != ttype
    createExpectedError(ctx, ptr expected, got)
    return null
  /if

  return got
/func


# parses, if present, the module name. Returns null if none or error
func parserParseModuleName(ctx ptr synt:Context) ptr uint8
  if ctx'next'type == lex:MODULE
    lex:tokenFree(nextTok(ctx)) # discard 'module'

    mut name = expect(ctx, lex:ID)
    if name != null
      mut temp = expect(ctx, lex:NEWLINE)
      if temp == null
        return null
      /if
      lex:tokenFree(temp)

      mut ret = spring:strclone(cast<ptr uint8>(name'value))
      lex:tokenFree(name)

      return ret
    /if
  /if

  return null
/func


func parserParseImport(ctx ptr synt:Context) ptr uint8
  if ctx'next'type == lex:IMPORT
    lex:tokenFree(nextTok(ctx)) # discard 'import'

    mut name = expect(ctx, lex:ID)
    if name != null
      mut temp = expect(ctx, lex:NEWLINE)
      if temp == null
        return null
      /if
      lex:tokenFree(temp)

      mut ret = spring:strclone(cast<ptr uint8>(name'value))
      lex:tokenFree(name)

      return ret
    /if
  /if

  return null
/func


# parses the 'import' statements, or returns a null pointer if empty
func parserParseImports(ctx ptr synt:Context) ptr spring:Vector
  mut ret = spring:vectNew(5)
  mut importLine ptr uint8

  while (importLine = parserParseImport(ctx)) != null
    spring:vectAppend(ret, importLine)
  /while

  return ret
/func


func parserParseIdType(ctx ptr synt:Context, name ptr uint8) ptr synt:Type
  mut moduleName ptr uint8 = null

  if ctx'next != null and ctx'next'type == lex:COLON
    # discard ':'
    lex:tokenFree(nextTok(ctx))

    mut tok = expect(ctx, lex:ID)
    if tok == null
      return null
    /if

    moduleName = name
    name = spring:strclone(cast<ptr uint8>(tok'value))

    lex:tokenFree(tok)
  /if

  return synt:typeNew(name, moduleName, null)
/func


func tokenIsTypeStart(tok ptr lex:Token) bool
  mut ttype = tok'type
  return ttype == lex:STRUCT or ttype == lex:FUNC or ttype == lex:PTR or ttype == lex:VAL or ttype == lex:ID
/func


decl parserParseType func(ptr synt:Context) ptr synt:Type


# if the next token exists and it's a lex:NEWLINE, then discards it
func parserDiscardNewLine(ctx ptr synt:Context)
  if ctx'next != null and ctx'next'type == lex:NEWLINE
    lex:tokenFree(nextTok(ctx))
  /if
/func

func parserParseIdList(ctx ptr synt:Context) ptr spring:List
  mut tok ptr lex:Token
  mut ret = spring:listNew()
  while true
    tok = expect(ctx, lex:ID)
    if theresError(ctx)
      break
    /if

    spring:listAppend(ret, spring:strclone(cast<ptr uint8>(tok'value)))

    if ctx'next == null
      ctx'prs'err = utils:errorMism(ptr ctx'last, "a ',' or an identifier", "end of file")
      break
    /if

    if ctx'next'type != lex:COMMA
      return ret
    /if

    # discard comma
    lex:tokenFree(nextTok(ctx))
  /while

  spring:listFreeAll(ret, ptr spring:free)
  return null
/func

func makeSymsAndInsertInList(syms ptr spring:List, ids ptr spring:List, type ptr synt:Type)
  mut len = spring:listLen(ids)
  mut i uintptr = 0
  mut elem ptr uint8
  mut sym ptr synt:Symbol

  while i < len
    elem = cast<ptr uint8>(val spring:listGet(ids, i))
    sym = synt:symbolNew(elem, type)
    spring:listAppend(syms, sym)
    i++
  /while

  spring:listFree(ids)
/func


func parserParseStructBodyVars(ctx ptr synt:Context, syms ptr spring:List, isFuncHeader bool) bool

  # allow multiline struct/function header declarations
  parserDiscardNewLine(ctx)

  if ctx'next == null
    ctx'prs'err = utils:errorMism(ptr ctx'last, "an identifier or a ')'", "end of file")
    return false
  /if

  if ctx'next'type == lex:CPAR
    return false
  /if

  mut ids = parserParseIdList(ctx)
  if theresError(ctx)
    return false
  /if

  if ctx'next == null
    ctx'prs'err = utils:errorMism(ptr ctx'last, "an identifier or a ')'", "end of file")
    spring:listFreeAll(ids, ptr spring:free)
    return false
  /if

  if ctx'next'type != lex:CPAR and !tokenIsTypeStart(ctx'next)
    ctx'prs'err = utils:errorMism(ptr ctx'last, "a type or a ')'", lex:tokenStr(ctx'next))
    return false
  /if

  if ctx'next'type == lex:CPAR
    if !isFuncHeader
      ctx'prs'err = utils:errorMism(ptr ctx'last, "a type", "a ')' - struct types must have field names")
      spring:listFreeAll(ids, ptr spring:free)
      return false
    /if

    makeSymsAndInsertInList(syms, ids, null)
  /if


  mut type = parserParseType(ctx)
  if theresError(ctx)
    spring:listFreeAll(ids, ptr spring:free)
    return false
  /if

  makeSymsAndInsertInList(syms, ids, type)

  return true
/func


func parserParseStructBody(ctx ptr synt:Context, isFuncHeader bool) ptr spring:List
  lex:tokenFree(expect(ctx, lex:OPAR))
  if theresError(ctx)
    return null
  /if

  mut strBody = spring:listNew()

  # each iteration parses a sequence of 'a,b,c,d type' or a full list (if this is a function header)
  while parserParseStructBodyVars(ctx, strBody, isFuncHeader)
    if ctx'next != null and ctx'next'type == lex:CPAR
      break
    /if

    lex:tokenFree(expect(ctx, lex:COMMA))
    if theresError(ctx)
      spring:listFreeAll(strBody, cast<ptr func(data)>(ptr synt:symbolNew))
      return null
    /if
  /while

  if theresError(ctx)
    spring:listFreeAll(strBody, cast<ptr func(data)>(ptr synt:symbolNew))
    return null
  /if

  lex:tokenFree(expect(ctx, lex:CPAR))
  if theresError(ctx)
    spring:listFreeAll(strBody, cast<ptr func(data)>(ptr synt:symbolNew))
    return null
  /if

  return strBody
/func


func parserParseFunctionType(ctx ptr synt:Context) ptr synt:Type
  mut args = parserParseStructBody(ctx, true)
  if theresError(ctx)
    return null
  /if

  mut retType ptr synt:Type = null

  if ctx'next != null and tokenIsTypeStart(ctx'next)
    retType = parserParseType(ctx)
  /if

  return synt:typeNew(null, null, synt:typeDescrNew(synt:TYPE_FUNC, retType, args))
/func

func parserParseStruct(ctx ptr synt:Context) ptr synt:Type
  mut args = parserParseStructBody(ctx, false)
  if theresError(ctx)
    return null
  /if

  return synt:typeNew(null, null, synt:typeDescrNew(synt:TYPE_STRUCT, null, args))
/func


func parserParseType(ctx ptr synt:Context) ptr synt:Type
  if ctx'next == null
    ctx'prs'err = utils:errorMism(ptr ctx'last, "a valid type", "end of file")
    return null
  /if

  mut tok = nextTok(ctx)
  mut ret ptr synt:Type = null

  if tok'type == lex:FUNC
    ret = parserParseFunctionType(ctx)
  /if

  if tok'type == lex:ID
    ret = parserParseIdType(ctx, spring:strclone(cast<ptr uint8>(tok'value)))
  /if

  if tok'type == lex:PTR
    # parses the real type (after ptr)
    mut realType = parserParseType(ctx)
    ret = synt:typeNew(null, null, synt:typeDescrNew(synt:TYPE_PTR, realType, null))
  /if

  if tok'type == lex:STRUCT
    ret = parserParseStruct(ctx)
  /if

  if tok'type == lex:VAL
    # parses the real type (after val)
    ret = parserParseType(ctx)
  /if

  if ret == null and !theresError(ctx)
    ctx'prs'err = utils:errorMism(ptr ctx'last, "a valid type", lex:tokenStr(tok))
  /if

  lex:tokenFree(tok)
  return ret
/func


func parserParseAlias(ctx ptr synt:Context) ptr synt:PNode
  # discard 'alias'
  lex:tokenFree(nextTok(ctx))

  mut name = expect(ctx, lex:ID)
  if name != null
    mut type = parserParseType(ctx)
    if theresError(ctx)
      return null
    /if

    mut node = cast<ptr synt:PDecl>(spring:zalloc(size(synt:PDecl)))
    node'node'type = lex:ALIAS
    node'name = spring:strclone(cast<ptr uint8>(name'value))
    node'type = type

    return ptr node'node
  /if

  return null
/func


func parserParseDeclaration(ctx ptr synt:Context, declType uint16) ptr synt:PNode
  # discard 'var' or 'decl'
  lex:tokenFree(nextTok(ctx))

# mut node = parserParseIdList(ctx, )

# while
/func


func parserParseDecl(ctx ptr synt:Context) ptr synt:PNode
  return parserParseDeclaration(ctx, lex:DECL)
/func


func parserParseMut(ctx ptr synt:Context) ptr synt:PNode
  return parserParseDeclaration(ctx, lex:MUT)
/func


func parserParseFunctionBody(ctx ptr synt:Context) ptr synt:PNode

/func


func parserMakeFunction(ctx ptr synt:Context, type uint16, name ptr uint8, header ptr synt:PExpr, endToken uint16) ptr synt:PNode

  mut newLine = expect(ctx, lex:NEWLINE)
  if newLine == null
    return null
  /if

  lex:tokenFree(newLine)

  mut body = parserParseFunctionBody(ctx)
  if body == null
    return null
  /if


  mut funcNode = synt:pnodeNew(type, cast<uintptr>(name), null)

  synt:pnodeAppendChild(funcNode, cast<ptr synt:PNode>(header))
  synt:pnodeAppendChild(funcNode, body)

  mut endTok = expect(ctx, endToken)
  if endTok == null
    synt:pnodeFree(funcNode)
    return null
  /if

  return funcNode

/func


func parserParseEntry(ctx ptr synt:Context) ptr synt:PNode
  discardTok(ctx) #discard "entry"

  return parserMakeFunction(ctx, synt:PENTRY, "_helm_entry", ptr synt:emptyExpr, lex:ENDENTRY)
/func


func parserParseFuncName(ctx ptr synt:Context) ptr uint8
  mut nameTok = expect(ctx, lex:ID)
  if nameTok == null
    return null
  /if

  mut name = spring:strclone(cast<ptr uint8>(nameTok'value))

  lex:tokenFree(nameTok)

  return name

/func


func parserParseFunc(ctx ptr synt:Context) ptr synt:PNode
  discardTok(ctx) #discard "func"

  mut name = parserParseFuncName(ctx)
  if name == null
    return null
  /if

  mut header = parserParseStructBody(ctx, true)

  if header == null
    spring:free(name)
    return null
  /if

  return parserMakeFunction(ctx, synt:PFUNCTION, name, ptr synt:emptyExpr, lex:ENDENTRY)
/func


func parserParseDefinition(ctx ptr synt:Context) ptr synt:PNode

  if ctx'next == null
    return null
  /if

  if ctx'next'type == lex:ALIAS
    return parserParseAlias(ctx)
  /if

  if ctx'next'type == lex:DECL
    return parserParseDecl(ctx)
  /if

  if ctx'next'type == lex:ENTRY
    return parserParseEntry(ctx)
  /if

  if ctx'next'type == lex:FUNC
    return parserParseFunc(ctx)
  /if

  if ctx'next'type == lex:MUT
    return  parserParseMut(ctx)
  /if

  ctx'prs'err = utils:errorMism(ptr ctx'last, "'alias', 'decl', 'entry', 'function' or 'var'", lex:tokenStr(ctx'next))

  return null

/func

# parses the root node
func parserParseProgram(ctx ptr synt:Context) ptr synt:PNode

  # parse module name
  mut moduleName = parserParseModuleName(ctx)

  if theresError(ctx)
    return null
  /if

  # parse imports
  mut imports = parserParseImports(ctx)

  if theresError(ctx)
    return null
  /if

  mut pnode = cast<ptr synt:PNode>(synt:pprogramNew(moduleName, imports))

  mut definition ptr synt:PNode = null

  while (definition = parserParseDefinition(ctx)) != null
    synt:pnodeAppendChild(pnode, definition)
  /while

  if theresError(ctx)
    synt:pnodeFree(pnode)
    return null
  /if

  return pnode

/func


func parserParse(parser ptr synt:Parser) ptr synt:PNode

  mut lex = lex:lexerNew(parser'filename, ptr parser'err)
  if parser'err != null
    return null
  /if

  # init synt:Context
  mut ctx synt:Context
  ctx'prs = parser
  ctx'lex = lex
  ctx'next = lex:lexerNext(lex)

  if (parser'err = lex:lexerError(lex)) != null
    return null
  /if

  mut ret = parserParseProgram(ptr ctx)

  lex:lexerClose(lex)

  return ret

/func


func pnodeAppendChild(pnode, child ptr synt:PNode)

  if pnode != null
    spring:vectAppend(pnode'leaves, child)

    if child != null
      child'parent = pnode
    /if
  /if

/func


func pnodeFree(pnode ptr synt:PNode)

  if pnode'type == synt:PPROGRAM

    mut pprog = cast<ptr synt:PProgram>(pnode)
    spring:free(pprog'moduleName)
    spring:vectFreeAll(pprog'imports, ptr spring:free)

  /if

  if pnode'type == synt:PALIAS or pnode'type == synt:PDECL or pnode'type == synt:PVAR or pnode'type == synt:PENTRY or pnode'type == synt:PFUNCTION

    mut pdecl = cast<ptr synt:PDecl>(pnode)
    spring:free(pdecl'name)
    utils:decRef(pdecl'type)

  /if

  # remember to fix PEXPR leaks.

  spring:vectFreeAll(pnode'leaves, ptr pnodeFree)
  spring:free(pnode)

/func


func pnodeNew(type uint16, value uintptr, parent ptr synt:PNode) ptr synt:PNode

  mut pnode = cast<ptr synt:PNode>(spring:zalloc(size(synt:PNode)))
  pnode'type = type
  pnode'value = value
  pnode'parent = parent

  return pnode
/func


func pprogramNew(moduleName ptr uint8, imports ptr spring:Vector) ptr synt:PProgram

  mut pprog = cast<ptr synt:PProgram>(spring:zalloc(size(synt:PProgram)))
  pprog'node'type = synt:PPROGRAM
  pprog'moduleName = moduleName
  pprog'imports = imports
  pprog'node'parent = null

  return pprog

/func

mut PPROGRAM   uint16 = 10
mut PENTRY     uint16 = 20
mut PFUNCTION  uint16 = 30
mut PALIAS     uint16 = 40
mut PDECL      uint16 = 50
mut PVAR       uint16 = 60
mut PDECLBLOCK uint16 = 70
mut PEXPR      uint16 = 80
