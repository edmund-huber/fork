#  Second Step - Experimental Helm Compiler
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2014
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the 
#  licenses expressed under Section 1.12 of the MPL v2. 

import lex
import spring
import synt
import utils

func parserNew(filename ptr uint8) ptr synt:Parser
  var ret = cast<ptr synt:Parser>(spring:zalloc(size(synt:Parser)))
  ret'filename = spring:strclone(filename)

  return ret
/func

func parserFree(parser ptr synt:Parser)
  if parser != null
    spring:free(parser'filename)
    spring:free(parser)
  /if
/func

alias Context struct (
  prs ptr synt:Parser,
  lex ptr lex:Lexer,
  next ptr lex:Token
)

func theresError(ctx ptr Context) bool
  return ctx'prs'err != null
/func

func nextTok(ctx ptr Context) ptr lex:Token
  var tok = ctx'next
  ctx'next = lex:lexerNext(ctx'lex)
  ctx'prs'err = lex:lexerError(ctx'lex)
  if ctx'prs'err != null
    return null
  /if

  return tok
/func

# if the expected token is not given, then the Parser gets its error set
func expectError(ctx ptr Context, expected, got uint16)
  var tok1 lex:Token
  tok1'type = expected
  var tok2 lex:Token
  tok2'type = got
  ctx'prs'err = utils:errorMism(ctx'lex, lex:tokenStr(ptr tok1), lex:tokenStr(ptr tok2))
/func

# get the expected token or null for error.
func expect(ctx ptr Context, ttype uint16) ptr lex:Token
  var tok = nextTok(ctx)
  if theresError(ctx) or tok == null
    return null
  /if

  if tok'type != ttype
    expectError(ctx, ttype, tok'type)
    return null
  /if

  return tok
/func

# parses, if present, the module name. Returns null if none or error
func parserParseModuleName(ctx ptr Context) ptr uint8
  if ctx'next'type == lex:MODULE
    lex:tokenFree(nextTok(ctx)) # discard 'module'

    var name = expect(ctx, lex:ID)
    if name != null
      var temp = expect(ctx, lex:NEWLINE)
      if temp == null
        return null
      /if
      lex:tokenFree(temp)

      var ret = spring:strclone(cast<ptr uint8>(name'value))
      lex:tokenFree(name)

      return ret
    /if
  /if

  return null
/func

func parserParseImport(ctx ptr Context) ptr uint8
  if ctx'next'type == lex:IMPORT
    lex:tokenFree(nextTok(ctx)) # discard 'import'

    var name = expect(ctx, lex:ID)
    if name != null
      var temp = expect(ctx, lex:NEWLINE)
      if temp == null
        return null
      /if
      lex:tokenFree(temp)

      var ret = spring:strclone(cast<ptr uint8>(name'value))
      lex:tokenFree(name)

      return ret
    /if
  /if

  return null
/func

# parses the 'import' statements, or returns a null pointer if empty
func parserParseImports(ctx ptr Context) ptr spring:Vector
  var ret = spring:vectNew(5)
  var importLine ptr uint8

  while (importLine = parserParseImport(ctx)) != null
    spring:vectAppend(ret, importLine)
  /while

  return ret
/func

# parses the root node
func parserParseProgram(ctx ptr Context) ptr synt:PNode

  # parse module name
  var moduleName = parserParseModuleName(ctx)

  if theresError(ctx)
    return null
  /if

  # parse imports
  var imports = parserParseImports(ctx)

  if theresError(ctx)
    return null
  /if

  var prog = cast<ptr synt:PProgram>(spring:zalloc(size(synt:PProgram)))

  prog'node'type = synt:PROGRAM
  prog'moduleName = moduleName
  prog'imports = imports

  return cast<ptr synt:PNode>(prog)

/func

func parserParse(parser ptr synt:Parser) ptr synt:PNode
  var lex = lex:lexerNew(parser'filename, ptr parser'err)
  if parser'err != null
    return null
  /if

  # init Context
  var ctx Context
  ctx'prs = parser
  ctx'lex = lex
  ctx'next = lex:lexerNext(lex)

  if (parser'err = lex:lexerError(lex)) != null
    return null
  /if

  var ret = parserParseProgram(ptr ctx)

  lex:lexerClose(lex)

  return ret
/func

func pnodeFree(pnode ptr synt:PNode)
  if pnode'type == synt:PROGRAM
    var pprog = cast<ptr synt:PProgram>(pnode)
    spring:free(pprog'moduleName)
    spring:vectFreeAll(pprog'imports, ptr spring:free)
  /if

  spring:vectFreeAll(pnode'leaves, ptr pnodeFree)
  spring:free(pnode)
/func

var PROGRAM  uint16 = 10
var ENTRY    uint16 = 20
var FUNCTION uint16 = 30
