#  Second Step - Experimental Fork Compiler
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2014
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the
#  licenses expressed under Section 1.12 of the MPL v2.

import ast
import lex
import spring
import synt
import utils


func parserNew(filename ptr uint8) ptr synt:Parser
  mut ret = cast<ptr synt:Parser>(spring:zalloc(size(synt:Parser)))
  ret'filename = spring:strclone(filename)

  return ret
/func


func parserFree(parser ptr synt:Parser)
  if parser != null
    spring:free(parser'filename)
    spring:free(parser)
  /if
/func


func theresError(ctx ptr synt:ParserContext) bool
  return ctx'prs'err != null
/func


func nextTok(ctx ptr synt:ParserContext) ptr lex:Token
  mut tok = ctx'next
  if ctx'last != null
    lex:linenoFree(ctx'last)
  /if

  ctx'last = lex:linenoClone(tok'lineno)

  ctx'next = lex:lexerNext(ctx'lex)
  ctx'prs'err = lex:issueFromLexError(lex:lexerError(ctx'lex), ctx'last)
  if ctx'prs'err != null
    return null
  /if

  return tok
/func


func discardTok(ctx ptr synt:ParserContext)
  lex:tokenFree(nextTok(ctx))
/func


# if the expected token is not given, then the Parser gets its error set
func createExpectedError(ctx ptr synt:ParserContext, expected, got ptr lex:Token)
  ctx'prs'err = lex:errorMism(ctx'last, lex:tokenStr(expected), lex:tokenStr(got))
/func


# get the expected token or null for error.
func expect(ctx ptr synt:ParserContext, ttype uint16) ptr lex:Token
  mut got = nextTok(ctx)
  if theresError(ctx)
    return null
  /if

  mut expected lex:Token
  expected'type = ttype
  if (got == null and ttype != lex:EOF) or got'type != ttype
    createExpectedError(ctx, ptr expected, got)
    return null
  /if

  return got
/func


func expectDiscard(ctx ptr synt:ParserContext, ttype uint16) bool
  mut tok = expect(ctx, ttype)
  lex:tokenFree(tok)

  return tok != null
/func


# parses, if present, the module name. Returns null if none or error
func parserParseModuleName(ctx ptr synt:ParserContext) ptr ast:StringDef
  if ctx'next'type == lex:MODULE
    mut begin = lex:tokDiscardBegin(synt:nextTok(ctx)) # discard 'module'

    mut name = expect(ctx, lex:ID)
    if name != null
      if !synt:expectDiscard(ctx, lex:NEWLINE)
        return null
      /if

      mut moduleName = spring:strclone(cast<ptr uint8>(name'value))
      mut end = lex:tokDiscardEnd(name)

      return ast:strdefNew(moduleName, begin, end)
    /if
  /if

  return null
/func


func parserParseImport(ctx ptr synt:ParserContext) ptr ast:StringDef
  if ctx'next'type == lex:IMPORT
    mut begin = lex:tokDiscardBegin(synt:nextTok(ctx)) # discard 'import'

    mut name = synt:expect(ctx, lex:ID)
    if name != null
      if !synt:expectDiscard(ctx, lex:NEWLINE)
        return null
      /if

      mut importName = spring:strclone(cast<ptr uint8>(name'value))
      mut end = lex:tokDiscardEnd(name)

      return ast:strdefNew(importName, begin, end)
    /if
  /if

  return null
/func


# parses the 'import' statements
func parserParseImports(ctx ptr synt:ParserContext) ptr spring:List
  mut ret = spring:listNew()
  mut importLine ptr ast:StringDef

  while (importLine = parserParseImport(ctx)) != null
    spring:listAppend(ret, importLine)
  /while

  return ret
/func


func parserParseIdType(ctx ptr synt:ParserContext, name ptr uint8) ptr ast:PType
  mut moduleName ptr uint8 = null

  if ctx'next != null and ctx'next'type == lex:COLON
    # discard ':'
    lex:tokenFree(nextTok(ctx))

    mut tok = expect(ctx, lex:ID)
    if tok == null
      return null
    /if

    moduleName = name
    name = spring:strclone(cast<ptr uint8>(tok'value))

    lex:tokenFree(tok)
  /if

  return ast:ptypeNew(name, moduleName, ast:ptypeDescrNew(ast:PTYPE_ID, null, null))
/func


func tokenIsTypeStart(tok ptr lex:Token) bool
  mut ttype = tok'type
  return ttype == lex:STRUCT or ttype == lex:FUNC or ttype == lex:PTR or ttype == lex:VAL or ttype == lex:ID or ttype == lex:OBRAC
/func


decl parserParseType func(ctx ptr synt:ParserContext) ptr ast:PType


# if the next token exists and it's a lex:NEWLINE, then discards it
func parserDiscardNewLine(ctx ptr synt:ParserContext)
  if ctx'next != null and ctx'next'type == lex:NEWLINE
    synt:discardTok(ctx)
  /if
/func

func parserParseIdList(ctx ptr synt:ParserContext) ptr spring:List
  mut tok ptr lex:Token
  mut ret = spring:listNew()
  while true
    tok = expect(ctx, lex:ID)
    if tok == null
      break
    /if

    spring:listAppend(ret, spring:strclone(cast<ptr uint8>(tok'value)))
    lex:tokenFree(tok)

    if ctx'next == null
      ctx'prs'err = lex:errorMism(ctx'last, "a ',' or an identifier", "end of file")
      break
    /if

    if ctx'next'type != lex:COMMA
      return ret
    /if

    # discard comma
    synt:discardTok(ctx)
  /while

  spring:listFreeAll(ret, ptr spring:free)
  return null
/func


func makeSymsAndInsertInList(syms ptr spring:List, ids ptr spring:List, type ptr ast:PType)
  mut len = spring:listLen(ids)
  mut i uintptr = 0
  mut elem ptr uint8
  mut sym ptr ast:PSymbol

  while i < len
    elem = cast<ptr uint8>(val spring:listGet(ids, i))
    sym = ast:psymbolNew(elem, type)
    spring:listAppend(syms, sym)
    i++
  /while

  spring:listFree(ids)
/func


func parserParseStructBodyVars(ctx ptr synt:ParserContext, syms ptr spring:List) bool

  # allow multiline struct/function header declarations
  parserDiscardNewLine(ctx)

  if ctx'next == null
    ctx'prs'err = lex:errorMism(ctx'last, "an identifier or a ')'", "end of file")
    return false
  /if

  if ctx'next'type == lex:CPAR
    return false
  /if

  mut ids = parserParseIdList(ctx)
  if ids == null
    return false
  /if

  mut type = parserParseType(ctx)
  if type == null
    spring:listFreeAll(ids, ptr spring:free)
    return false
  /if

  makeSymsAndInsertInList(syms, ids, type)

  return true
/func


func parserParseStructBody(ctx ptr synt:ParserContext, end ptr utils:Line) ptr spring:List
  if !expectDiscard(ctx, lex:OPAR)
    return null
  /if

  mut strBody = spring:listNew()

  # each iteration parses a sequence of 'a,b,c,d type' or a full list (if this is a function header)
  while parserParseStructBodyVars(ctx, strBody)

    parserDiscardNewLine(ctx)

    if ctx'next != null and ctx'next'type == lex:CPAR
      break
    /if

    if !synt:expectDiscard(ctx, lex:COMMA)
      spring:listFreeAll(strBody, cast<ptr func(item data)>(ptr utils:decRef))
      return null
    /if
  /while

  if theresError(ctx)
    spring:listFreeAll(strBody, cast<ptr func(item data)>(ptr utils:decRef))
    return null
  /if

  mut endTok = synt:expect(ctx, lex:CPAR)
  if endTok == null
    spring:listFreeAll(strBody, cast<ptr func(item data)>(ptr utils:decRef))
    return null
  /if

  val end = lex:tokDiscardEnd(endTok)

  return strBody
/func


func parserParseFunctionType(ctx ptr synt:ParserContext) ptr ast:PType
  mut end utils:Line
  mut args = parserParseStructBody(ctx, ptr end)
  if args == null
    return null
  /if

  mut retType ptr ast:PType = null

  if ctx'next != null and tokenIsTypeStart(ctx'next)
    retType = parserParseType(ctx)
  /if

  mut type = ast:ptypeNew(null, null, ast:ptypeDescrNew(ast:PTYPE_FUNC, retType, args))
  type'end = end

  return type
/func


func parserParseLocType(ctx ptr synt:ParserContext) ptr ast:PType
  mut locLengthTok = expect(ctx, lex:NUMBER)
  if locLengthTok == null
    return null
  /if

  mut locLength = locLengthTok'value

  lex:tokenFree(locLengthTok)

  if !expectDiscard(ctx, lex:CBRAC)
    return null
  /if

  mut realType = parserParseType(ctx)
  if realType == null
    return null
  /if

  mut type = ast:ptypeNew(null, null, ast:ptypeDescrNewLoc(realType, locLength))
  type'end = realType'end

  return type
/func


func parserParseStructType(ctx ptr synt:ParserContext) ptr ast:PType
  mut end utils:Line

  mut args = parserParseStructBody(ctx, ptr end)
  if args == null
    return null
  /if

  mut type = ast:ptypeNew(null, null, ast:ptypeDescrNew(ast:PTYPE_STRUCT, null, args))
  type'end = end

  return type
/func


func parserParseType(ctx ptr synt:ParserContext) ptr ast:PType
  if ctx'next == null
    ctx'prs'err = lex:errorMism(ctx'last, "a valid type", "end of file")
    return null
  /if

  mut tok = nextTok(ctx)
  mut ret ptr ast:PType = null

  if tok'type == lex:FUNC
    ret = parserParseFunctionType(ctx)
  /if

  if tok'type == lex:ID
    ret = parserParseIdType(ctx, spring:strclone(cast<ptr uint8>(tok'value)))
    ret'end = lex:tokExtractEnd(tok)
  /if

  if tok'type == lex:OBRAC
    ret = parserParseLocType(ctx)
  /if

  if tok'type == lex:PTR
    # parses the real type (after ptr)
    mut realType = parserParseType(ctx)
    ret = ast:ptypeNew(null, null, ast:ptypeDescrNew(ast:PTYPE_PTR, realType, null))
    ret'end = realType'end
  /if

  if tok'type == lex:STRUCT
    ret = parserParseStructType(ctx)
  /if

  if tok'type == lex:VAL
    # parses the real type (after val)
    ret = parserParseType(ctx)
  /if

  if ret == null and !theresError(ctx)
    ctx'prs'err = lex:errorMism(ctx'last, "a valid type", lex:tokenStr(tok))
  /if

  ret'begin = lex:tokDiscardBegin(tok)

  return ret
/func


func parserParseDeclaration(ctx ptr synt:ParserContext, declType uint16, external bool) ptr ast:PNode
  # discard 'mut' or 'decl'
  mut begin = lex:tokDiscardBegin(synt:nextTok(ctx))

  mut idTok = expect(ctx, lex:ID)
  if idTok == null
    return null
  /if

  mut id = spring:strclone(cast<ptr uint8>(idTok'value))

  lex:tokenFree(idTok)

  if ctx'next == null
    ctx'prs'err = lex:errorMism(ctx'last, "a type or an '='", "EOF")
    spring:free(id)
    return null
  /if

  mut type ptr ast:PType = null
  mut end utils:Line

  if ctx'next'type != lex:ASSIGN
    type = parserParseType(ctx)
    if type == null
      spring:free(id)
      return null
    /if

    end = type'end
  /if

  mut pdecl = ast:pdeclNew(declType, ast:psymbolNew(id, type))
  mut pnode = cast<ptr ast:PNode>(pdecl)

  if ctx'next != null and ctx'next'type == lex:ASSIGN
    if external
      ctx'prs'err = lex:error(ctx'last, "decl values can't have initializers")
      ast:pnodeFree(pnode)
      return null
    /if

    synt:discardTok(ctx)

    mut expr = synt:parserParseExpr(ctx)
    if expr == null
      ast:pnodeFree(pnode)
      return null
    /if

    mut exprPNode = cast<ptr ast:PNode>(expr)

    ast:pnodeAppendChild(pnode, exprPNode)

    end = exprPNode'end
  /if

  pnode'begin = begin
  pnode'end = end
  return pnode
/func


func parserParseDecl(ctx ptr synt:ParserContext) ptr ast:PNode
  return parserParseDeclaration(ctx, ast:PDECL, true)
/func


func parserParseMut(ctx ptr synt:ParserContext) ptr ast:PNode
  return parserParseDeclaration(ctx, ast:PMUT, false)
/func


func parserParseAlias(ctx ptr synt:ParserContext) ptr ast:PNode
  # discard 'alias'
  mut begin = lex:tokDiscardBegin(synt:nextTok(ctx))

  mut name = expect(ctx, lex:ID)
  if name != null
    mut type = parserParseType(ctx)
    if type == null
      return null
    /if

    mut palias = ast:pdeclNew(ast:PALIAS, ast:psymbolNew(cast<ptr uint8>(name'value), type))
    mut pnode = cast<ptr ast:PNode>(palias)
    pnode'begin = begin
    pnode'end = type'end

    return pnode
  /if

  return null
/func


decl parserParseBody func(ctx ptr synt:ParserContext, isEndToken ptr func(tok ptr lex:Token) bool) ptr ast:PBlock


func matchWhileEndTok(tok ptr lex:Token) bool
  return tok'type == lex:ENDWHILE
/func


func parserParseWhile(ctx ptr synt:ParserContext) ptr ast:PNode
  mut begin = lex:tokDiscardBegin(synt:nextTok(ctx)) #discard while token

  mut expr = cast<ptr ast:PNode>(synt:parserParseExpr(ctx))
  if expr == null
    return null
  /if

  if !synt:expectDiscard(ctx, lex:NEWLINE)
    ast:pnodeFree(expr)
    return null
  /if

  mut whileBlock = ast:pnodeNew(ast:PWHILE, 0)
  ast:pnodeAppendChild(whileBlock, expr)

  mut body = cast<ptr ast:PNode>(parserParseBody(ctx, ptr matchWhileEndTok))
  if body == null
    ast:pnodeFree(whileBlock)
    return null
  /if

  ast:pnodeAppendChild(whileBlock, body)

  whileBlock'begin = begin
  whileBlock'end = lex:tokDiscardEnd(synt:nextTok(ctx)) #discard /while

  return whileBlock
/func


func matchIfElseEndTok(tok ptr lex:Token) bool
  return tok'type == lex:ENDIF or tok'type == lex:ELSE
/func

func matchIfEndTok(tok ptr lex:Token) bool
  return tok'type == lex:ENDIF
/func


func parserParseIf(ctx ptr synt:ParserContext) ptr ast:PNode
  mut begin = lex:tokDiscardBegin(synt:nextTok(ctx)) #discard if token

  mut expr = cast<ptr ast:PNode>(synt:parserParseExpr(ctx))
  if expr == null
    return null
  /if

  if !synt:expectDiscard(ctx, lex:NEWLINE)
    ast:pnodeFree(expr)
    return null
  /if

  mut block = ast:pnodeNew(ast:PIF, 0)
  ast:pnodeAppendChild(block, expr)

  mut mainBlock = cast<ptr ast:PNode>(parserParseBody(ctx, ptr matchIfElseEndTok))

  if mainBlock == null
    ast:pnodeFree(block)
    return null
  /if

  ast:pnodeAppendChild(block, mainBlock)

  if ctx'next'type == lex:ELSE
    synt:discardTok(ctx) #discard else
    if !synt:expectDiscard(ctx, lex:NEWLINE)
      ast:pnodeFree(block)
      return null
    /if

    mut elseBlock = cast<ptr ast:PNode>(parserParseBody(ctx, ptr matchIfEndTok))

    if elseBlock == null
      ast:pnodeFree(block)
      return null
    /if

    ast:pnodeAppendChild(block, elseBlock)

    block'type = ast:PIFELSE
  /if

  block'begin = begin
  block'end = lex:tokDiscardEnd(synt:nextTok(ctx)) #discard /if

  return block
/func


func parserParseReturn(ctx ptr synt:ParserContext) ptr ast:PNode
  mut returnTok = synt:nextTok(ctx)

  mut begin = lex:tokExtractBegin(returnTok) # discard "return"
  mut end = lex:tokDiscardEnd(returnTok)

  mut returnNode = ast:pnodeNew(ast:PRETURN, 0)
  if ctx'next != null and ctx'next'type != lex:NEWLINE
    mut expr = synt:parserParseExpr(ctx)
    if expr == null
      ast:pnodeFree(returnNode)
      return null
    /if
    ast:pnodeAppendChild(returnNode, cast<ptr ast:PNode>(expr))

    end = expr'node'end
  /if

  returnNode'begin = begin
  returnNode'end = end

  return returnNode
/func


func parserParseBreakCont(ctx ptr synt:ParserContext, ptype uint16) ptr ast:PNode
  mut breakTok = synt:nextTok(ctx)

  mut begin = lex:tokExtractBegin(breakTok) # discard "break" or "continue"
  mut end = lex:tokDiscardEnd(breakTok)
  mut pnode = ast:pnodeNew(ptype, 0)

  pnode'begin = begin
  pnode'end = end

  return pnode
/func


func parserParseStatement(ctx ptr synt:ParserContext) ptr ast:PNode

  if ctx'next == null
    ctx'prs'err = lex:errorMism(ctx'last, "a statement or an expression", "EOF")
  /if

  if ctx'next'type == lex:BREAK
    return parserParseBreakCont(ctx, ast:PBREAK)
  /if

  if ctx'next'type == lex:CONTINUE
    return parserParseBreakCont(ctx, ast:PCONTINUE)
  /if

  if ctx'next'type == lex:DECL
    return parserParseDecl(ctx)
  /if

  if ctx'next'type == lex:IF
    return parserParseIf(ctx)
  /if

  if ctx'next'type == lex:MUT
    return parserParseMut(ctx)
  /if

  if ctx'next'type == lex:RETURN
    return parserParseReturn(ctx)
  /if

  if ctx'next'type == lex:WHILE
    return parserParseWhile(ctx)
  /if

  return cast<ptr ast:PNode>(synt:parserParseExpr(ctx))
/func


func parserParseBody(ctx ptr synt:ParserContext, isEndToken ptr func(tok ptr lex:Token) bool) ptr ast:PBlock
  mut begin utils:Line

  mut statement ptr ast:PNode
  mut first = true

  mut block = ast:pblockNew()
  mut pnode = cast<ptr ast:PNode>(block)

  while ctx'next != null and !isEndToken(ctx'next)
    statement = parserParseStatement(ctx)
    if statement == null
      ast:pnodeFree(pnode)
      return null
    /if

    ast:pnodeAppendChild(pnode, statement)

    if first
      begin = statement'begin
      first = false
    /if

    if !synt:expectDiscard(ctx, lex:NEWLINE)
      ast:pnodeFree(pnode)
      return null
    /if
  /while

  if ctx'next == null
    ast:pnodeFree(pnode)
    return null
  /if

  # if ctx'next is not null, then the while above quitted because
  # isEndToken(ctx'next) == true.
  pnode'begin = begin
  pnode'end = statement'end

  return block
/func


func parserMakeFunction(ctx ptr synt:ParserContext,
                        pType uint16,
                        name ptr uint8,
                        type ptr ast:PType,
                        endTType uint16,
                        isEndToken ptr func(tok ptr lex:Token) bool) ptr ast:PNode

  if !expectDiscard(ctx, lex:NEWLINE)
    return null
  /if

  mut funcNode = cast<ptr ast:PNode>(ast:pdeclNew(pType, ast:psymbolNew(name, type)))
  mut body = cast<ptr ast:PNode>(parserParseBody(ctx, isEndToken))

  if body == null
    ast:pnodeFree(funcNode)
    return null
  /if

  ast:pnodeAppendChild(funcNode, body)

  mut endTok = synt:expect(ctx, endTType)
  if endTok == null
    ast:pnodeFree(funcNode)
    return null
  /if

  funcNode'end = lex:tokDiscardEnd(endTok)

  return funcNode

/func


func makeEntryType() ptr ast:PType
  return ast:ptypeNew(null, null,ast:ptypeDescrNew(ast:PTYPE_FUNC, null, null))
/func


func matchEntryEndTok(tok ptr lex:Token) bool
  return tok'type == lex:ENDENTRY
/func


func parserParseEntry(ctx ptr synt:ParserContext) ptr ast:PNode
  mut begin = lex:tokDiscardBegin(synt:nextTok(ctx))  #discard "entry"

  mut entryNode = parserMakeFunction(ctx, ast:PENTRY, spring:strclone("_fork_entry"), makeEntryType(), lex:ENDENTRY, ptr matchEntryEndTok)

  if entryNode == null
    return null
  /if

  entryNode'begin = begin

  return entryNode
/func


func parserParseFuncName(ctx ptr synt:ParserContext) ptr uint8
  mut nameTok = expect(ctx, lex:ID)
  if nameTok == null
    return null
  /if

  mut name = spring:strclone(cast<ptr uint8>(nameTok'value))

  lex:tokenFree(nameTok)

  return name

/func


func matchFuncEndTok(tok ptr lex:Token) bool
  return tok'type == lex:ENDFUNC
/func


func parserParseFunc(ctx ptr synt:ParserContext) ptr ast:PNode
  mut begin = lex:tokDiscardBegin(synt:nextTok(ctx)) #discard "func"

  mut name = parserParseFuncName(ctx)
  if name == null
    return null
  /if

  mut type = parserParseFunctionType(ctx)

  if type == null
    spring:free(name)
    return null
  /if

  mut functionNode =  parserMakeFunction(ctx, ast:PFUNCTION, name, type, lex:ENDFUNC, ptr matchFuncEndTok)
  if functionNode == null
    return null
  /if

  functionNode'begin = begin

  return functionNode
/func


func parserParseDefinition(ctx ptr synt:ParserContext) ptr ast:PNode

  if ctx'next == null
    return null
  /if

  if ctx'next'type == lex:ALIAS
    return parserParseAlias(ctx)
  /if

  if ctx'next'type == lex:DECL
    return parserParseDecl(ctx)
  /if

  if ctx'next'type == lex:ENTRY
    return parserParseEntry(ctx)
  /if

  if ctx'next'type == lex:FUNC
    return parserParseFunc(ctx)
  /if

  if ctx'next'type == lex:MUT
    return parserParseMut(ctx)
  /if

  ctx'prs'err = lex:errorMism(ctx'last, "'alias', 'decl', 'entry', 'func' or 'var'", lex:tokenStr(ctx'next))

  return null

/func

# parses the root node
func parserParseProgram(ctx ptr synt:ParserContext) ptr ast:PNode

  # parse module name
  mut moduleName = parserParseModuleName(ctx)

  if theresError(ctx)
    return null
  /if

  # parse imports
  mut imports = parserParseImports(ctx)

  if theresError(ctx)
    return null
  /if

  mut pnode = cast<ptr ast:PNode>(ast:prootNew(moduleName, imports, ctx'prs'filename))

  mut definition ptr ast:PNode = null
  mut first = true

  while (definition = parserParseDefinition(ctx)) != null
    ast:pnodeAppendChild(pnode, definition)

    if ctx'next != null and !synt:expectDiscard(ctx, lex:NEWLINE)
      ast:pnodeFree(pnode)
      return null
    /if

    if first
      pnode'begin = definition'begin
      first = false
    /if

    pnode'end = definition'end
  /while

  if theresError(ctx)
    ast:pnodeFree(pnode)
    return null
  /if

  return pnode

/func


func parserParse(parser ptr synt:Parser) ptr ast:PNode
  mut lexErr ptr spring:Error = null
  mut firstLineno = lex:linenoNew(spring:strclone(parser'filename), 1, 1)

  mut lex = lex:lexerNew(parser'filename, ptr lexErr)
  if lexErr != null
    parser'err = lex:issueFromLexError(lexErr, firstLineno)

    lex:linenoFree(firstLineno)
    return null
  /if

  # init synt:ParserContext
  mut ctx synt:ParserContext
  ctx'prs = parser
  ctx'lex = lex
  ctx'next = lex:lexerNext(lex)
  ctx'last = firstLineno

  if (lexErr = lex:lexerError(lex)) != null
    parser'err = lex:issueFromLexError(lexErr, firstLineno)

    lex:linenoFree(firstLineno)
    lex:tokenFree(ctx'next)

    return null
  /if

  mut ret = parserParseProgram(ptr ctx)

  lex:lexerClose(lex)

  return ret

/func
