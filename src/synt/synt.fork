#  libfork, a base library for the Fork language
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2014, 2015
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the
#  licenses expressed under Section 1.12 of the MPL v2.


module synt


import ast
import astfn
import err
import fs
import lex
import list
import mem
import parser
import synt
import tokens
import txt
import utils


method synt:Parser.theresError() bool
  return me'err?
/method


method synt:Parser.next() ptr lex:Token
  mut tok = me'next

  if me'last?
    lex:linenoFree(me'last)
  /if

  if not tok?
    return null
  /if

  me'last = lex:linenoClone(tok'lineno)

  me'next = lex:lexerNext(me'lex)
  me'err = lex:issueFromLexError(lex:lexerError(me'lex), me'last)
  if me'err?
    return null
  /if

  return tok
/method


method synt:Parser.discardNext()
  lex:tokenFree(me.next())
/method


# if the expected token is not given, then the Parser gets its error set
method synt:Parser.expectedError(expected, got ptr lex:Token)
  me'err = lex:errorMism(me'last, lex:tokenStr(expected), lex:tokenStr(got))
/method


# get the expected token or null for error.
method synt:Parser.expect(ttype uint16) ptr lex:Token
  mut got = me.next()
  if me.theresError()
    return null
  /if

  mut expected lex:Token
  expected'type = ttype
  if (not got? and ttype != tokens:EOF) or got'type != ttype
    me.expectedError(ptr expected, got)
    return null
  /if

  return got
/method


method synt:Parser.expectDiscard(ttype uint16) bool
  mut tok = me.expect(ttype)
  lex:tokenFree(tok)

  return tok?
/method


# parses, if present, the module name. Returns null if none or error
method synt:Parser.parseModuleName() ptr ast:StringDef
  if me'next'type == tokens:MODULE
    mut begin = lex:tokDiscardBegin(me.next()) # discard 'module'

    mut name = me.expect(tokens:ID)
    if name?
      if not me.expectDiscard(tokens:NEWLINE)
        return null
      /if

      mut moduleName = txt:strclone(<ptr uint8>(name'value))
      mut end = lex:tokDiscardEnd(name)

      return astfn:strdefNew(moduleName, begin, end)
    /if
  /if

  return null
/method


method synt:Parser.parseImport() ptr ast:StringDef
  if me'next? and me'next'type == tokens:IMPORT
    mut begin = lex:tokDiscardBegin(me.next()) # discard 'import'

    mut name = me.expect(tokens:ID)
    if name?
      if not me.expectDiscard(tokens:NEWLINE)
        return null
      /if

      mut importName = txt:strclone(<ptr uint8>(name'value))
      mut end = lex:tokDiscardEnd(name)

      return astfn:strdefNew(importName, begin, end)
    /if
  /if

  return null
/method


# parses the 'import' statements
method synt:Parser.parseImports() ptr list:List
  mut ret = list:new()
  mut importLine ptr ast:StringDef

  while (importLine = me.parseImport())?
    ret.append(importLine)
  /while

  return ret
/method


method synt:Parser.parseIdType(name ptr uint8) ptr ast:PType
  mut moduleName ptr uint8 = null

  if me'next? and me'next'type == tokens:COLON
    # discard ':'
    lex:tokenFree(me.next())

    mut tok = me.expect(tokens:ID)
    if not tok?
      return null
    /if

    moduleName = name
    name = txt:strclone(<ptr uint8>(tok'value))

    lex:tokenFree(tok)
  /if

  return astfn:ptypeNew(name, moduleName, astfn:ptypeDescrNew(ast:PTYPE_ID, null, null))
/method


func tokenIsTypeStart(tok ptr lex:Token) bool
  mut ttype = tok'type
  return    ttype == tokens:STRUCT \
         or ttype == tokens:FUNC \
         or ttype == tokens:PTR \
         or ttype == tokens:VAL \
         or ttype == tokens:ID \
         or ttype == tokens:OBRAC \
         or ttype == tokens:OCURLY
/func


# if the next token exists and it's a tokens:NEWLINE, then discards it
method synt:Parser.discardNewLine()
  if me'next? and me'next'type == tokens:NEWLINE
    me.discardNext()
  /if
/method

method synt:Parser.parseIdList() ptr list:List
  mut tok ptr lex:Token
  mut ret = list:new()
  while true
    tok = me.expect(tokens:ID)
    if not tok?
      break
    /if

    ret.append(txt:strclone(<ptr uint8>(tok'value)))
    lex:tokenFree(tok)

    if not me'next?
      me'err = lex:errorMism(me'last, "a ',' or an identifier", "end of file")
      break
    /if

    if me'next'type != tokens:COMMA
      return ret
    /if

    # discard comma
    me.discardNext()
  /while

  list:freeAll(ret, ptr mem:free)
  return null
/method


func makeSymsAndInsertInList(syms ptr list:List, ids ptr list:List, type ptr ast:PType)
  mut len = ids.len()
  mut i uintptr = 0
  mut elem ptr uint8
  mut sym ptr ast:PSymbol

  while i < len
    elem = <ptr uint8>(val ids.get(i))
    sym = astfn:psymbolNew(elem, type)
    syms.append(sym)
    i++
  /while

  list:free(ids)
/func


method synt:Parser.parseStructBodyVars(syms ptr list:List) bool

  # allow multiline struct/methodtion header declarations
  me.discardNewLine()

  if not me'next?
    me'err = lex:errorMism(me'last, "an identifier or a ')'", "end of file")
    return false
  /if

  if me'next'type == tokens:CPAR
    return false
  /if

  mut ids = me.parseIdList()
  if not ids?
    return false
  /if

  mut type = me.parseType()
  if not type?
    list:freeAll(ids, ptr mem:free)
    return false
  /if

  makeSymsAndInsertInList(syms, ids, type)

  return true
/method


method synt:Parser.parseStructBody(end ptr ast:Line,
                                   newStruct bool) ptr list:List

  mut openTok = newStruct => tokens:OCURLY || tokens:OPAR
  mut closeTok = newStruct => tokens:CCURLY || tokens:CPAR

  # If newStruct is on, this just discards the `{`.
  # Otherwise, it checks for a `(`.
  if not me.expectDiscard(openTok)
    return null
  /if

  mut strBody = list:new()

  # each iteration parses a sequence of 'a,b,c,d type' or a full list
  # (if this is a function header)
  while me.parseStructBodyVars(strBody)

    me.discardNewLine()

    if me'next? and me'next'type == closeTok
      break
    /if

    if not me.expectDiscard(tokens:COMMA)
      list:freeAll(strBody, <ptr func(item data)>(ptr mem:decRef))
      return null
    /if
  /while

  if me.theresError()
    list:freeAll(strBody, <ptr func(item data)>(ptr mem:decRef))
    return null
  /if

  mut endTok = me.expect(closeTok)
  if not endTok?
    list:freeAll(strBody, <ptr func(item data)>(ptr mem:decRef))
    return null
  /if

  # discards `)` or `}`.
  val end = lex:tokDiscardEnd(endTok)

  return strBody
/method


method synt:Parser.parseFunctionType() ptr ast:PType
  mut end ast:Line
  mut args = me.parseStructBody(ptr end, false)
  if not args?
    return null
  /if

  mut retType ptr ast:PType = null

  if me'next? and tokenIsTypeStart(me'next)
    retType = me.parseType()
  /if

  mut type = astfn:ptypeNew(null, null, astfn:ptypeDescrNew(ast:PTYPE_FUNC, retType, args))
  type'end = end

  return type
/method


method synt:Parser.parseLocType() ptr ast:PType
  mut locLengthTok = me.expect(tokens:NUMBER)
  if not locLengthTok?
    return null
  /if

  mut locLength = locLengthTok'value

  lex:tokenFree(locLengthTok)

  if not me.expectDiscard(tokens:CBRAC)
    return null
  /if

  mut realType = me.parseType()
  if not realType?
    return null
  /if

  mut type = astfn:ptypeNew(null, null, astfn:ptypeDescrNewLoc(realType, locLength))
  type'end = realType'end

  return type
/method


method synt:Parser.parseStructType(newStruct bool) ptr ast:PType
  mut end ast:Line

  mut args = me.parseStructBody(ptr end, newStruct)
  if not args?
    return null
  /if

  mut type = astfn:ptypeNew(null, null, astfn:ptypeDescrNew(ast:PTYPE_STRUCT, null, args))
  type'end = end

  return type
/method


method synt:Parser.parseType() ptr ast:PType
  if not me'next?
    me'err = lex:errorMism(me'last, "a valid type", "end of file")
    return null
  /if

  mut ret ptr ast:PType = null

  # if we have an open parenthesis, then this is a struct type (shortened).
  # This comparison should be made BEFORE getting the token, because
  # Parser.parseStructType() expects a `{` at the beginning.
  if me'next'type == tokens:OCURLY
    mut begin = lex:tokExtractBegin(me'next)
    ret = me.parseStructType(true)

    if ret?
      ret'begin = begin
    /if

    return ret
  /if

  mut tok = me.next()

  if tok'type == tokens:FUNC
    ret = me.parseFunctionType()
  /if

  if tok'type == tokens:ID
    ret = me.parseIdType(txt:strclone(<ptr uint8>(tok'value)))
    ret'end = lex:tokExtractEnd(tok)
  /if

  if tok'type == tokens:OBRAC
    ret = me.parseLocType()
  /if

  if tok'type == tokens:PTR
    # parses the real type (after ptr)
    mut realType = me.parseType()
    ret = astfn:ptypeNew(null, null, astfn:ptypeDescrNew(ast:PTYPE_PTR, realType, null))
    ret'end = realType'end
  /if

  if tok'type == tokens:STRUCT
    ret = me.parseStructType(false)
  /if

  if tok'type == tokens:VAL
    # parses the real type (after val)
    ret = me.parseType()
  /if

  if not ret?
    if not me.theresError()
      me'err = lex:errorMism(me'last, "a valid type", lex:tokenStr(tok))
    /if

    return null
  /if

  ret'begin = lex:tokDiscardBegin(tok)

  return ret
/method


method synt:Parser.parseMutId() {id ptr uint8, ptype ptr ast:PType, end ast:Line}
  mut end ast:Line

  mut idTok = me.expect(tokens:ID)
  if not idTok?
    return {null, null, end}
  /if

  mut id = txt:strclone(<ptr uint8>(idTok'value))

  lex:tokenFree(idTok)

  if not me'next?
    me'err = lex:errorMism(me'last, "a type", "EOF")
    mem:free(id)
    return {null, null, end}
  /if

  mut type ptr ast:PType = null

  if tokenIsTypeStart(me'next)
    type = me.parseType()
    if not type?
      mem:free(id)
      return {null, null, end}
    /if

    end = type'end
  /if

  return {id, type, end}
/method


method synt:Parser.parseMutExp() {pnode ptr ast:PNode, needsAssign bool}
  me.discardNext() # discard `{`

  # check this here, because otherwise if we just rely on the loop, things like
  # "mut {} = x" would be valid. But they are not, and they must be discarded.
  if not me'next? or me'next'type != tokens:ID
    me'err = lex:errorMism(me'last, "an identifier", "EOF")
    return {null, false}
  /if

  mut needsAssign = false
  mut syms = list:new()

  while true
    mut {id,ptype,end} = me.parseMutId()

    if not id?
      list:freeAll(syms, <ptr func(item data)>(ptr mem:decRef))
      return {null, false}
    /if

    mut needsAssign = needsAssign or not ptype?

    syms.append(astfn:psymbolNew(id, ptype))

    if not me'next? \
        or (me'next'type != tokens:CCURLY and me'next'type != tokens:COMMA)

      me'err = lex:errorMism(me'last, "`,` or `}`", lex:tokenStr(me'next))
      list:freeAll(syms, <ptr func(item data)>(ptr mem:decRef))
      return {null, false}
    /if

    if me'next'type == tokens:CCURLY
      break
    /if

    if me'next'type == tokens:COMMA
      me.discardNext()
    /if
  /while

  # discard `}`
  me.discardNext()

  return { <ptr ast:PNode>(astfn:pmuldeclNew(ast:PMUTEXP, syms)), needsAssign}
/method


method synt:Parser.parseMut(external bool) ptr ast:PNode
  mut end ast:Line
  # discard 'mut'
  mut begin = lex:tokDiscardBegin(me.next())

  if not me'next?
    me'err = lex:errorMism(me'last, "an identifier or a bracketed list", "EOF")
    return null
  /if

  mut pnode ptr ast:PNode = null
  mut needsAssign = false

  if me'next'type == tokens:OCURLY
    {pnode,needsAssign} = me.parseMutExp()
    if not pnode?
      return null
    /if

  else

    mut {id,ptype,end} = me.parseMutId()

    if not id?
      return null
    /if

    needsAssign = not ptype?

    pnode = <ptr ast:PNode>(astfn:pdeclNew(ast:PMUT, \
                                astfn:psymbolNew(id, ptype), external))
  /if

  if me'next? and me'next'type == tokens:ASSIGN
    if external
      me'err = lex:error(me'last, "decl values can't have initializers")
      ast:pnodeFree(pnode)
      return null
    /if

    me.discardNext()

    mut expr = me.parseExpr()
    if not expr?
      ast:pnodeFree(pnode)
      return null
    /if

    mut exprPNode = <ptr ast:PNode>(expr)

    astfn:pnodeAppendChild(pnode, exprPNode)

    end = exprPNode'end
  else
    if needsAssign
      me'err = lex:errorMism(me'last, "an assignment or a type", lex:tokenStr(me'next))
      ast:pnodeFree(pnode)
      return null
    /if
  /if

  pnode'begin = begin
  pnode'end = end
  return pnode
/method


method synt:Parser.parseDecl() ptr ast:PNode

  # discard 'decl'
  mut begin = lex:tokDiscardBegin(me.next())

  if not me'next?
    me'err = lex:errorMism(me'last, "`mut`,`method` or `func`", "EOF")
    return null
  /if

  mut ret ptr ast:PDecl = null

  if me'next'type == tokens:MUT
    ret = <ptr ast:PDecl>(me.parseMut(true))
  else
    if me'next'type == tokens:FUNC
      # discard 'func'
      me.discardNext()

      mut name ptr uint8
      mut type ptr ast:PType

      if not me.parseFuncHead(ptr name, ptr type)
        return null
      /if

      ret = astfn:pdeclNew(ast:PFUNCTION, astfn:psymbolNew(name, type), true)

      ret'node'end = type'end
    else
      if me'next'type == tokens:METHOD
        # discard 'method'
        me.discardNext()

        mut typeModule ptr uint8
        mut typeName ptr uint8
        mut name ptr uint8
        mut ptype ptr ast:PType

        if not me.parseMethodHead(ptr typeModule, ptr typeName, ptr name, ptr ptype)
          return null
        /if

        ret = astfn:pdeclNew(ast:PMETHOD, astfn:psymbolNew(name, ptype), true)

        ret'methodTypeModule = typeModule
        ret'methodType = typeName

        ret'node'end = ptype'end

      else
        me'err = lex:errorMism(me'last, "`mut`, `method` or `func`", lex:tokenStr(me'next))
        return null
      /if
    /if
  /if

  if not ret?
    return null
  /if

  ret'node'begin = begin

  return <ptr ast:PNode>(ret)
/method


method synt:Parser.parseAlias() ptr ast:PNode
  # discard 'alias'
  mut begin = lex:tokDiscardBegin(me.next())

  mut name = me.expect(tokens:ID)
  if name?
    mut type = me.parseType()
    if not type?
      return null
    /if

    mut palias = astfn:pdeclNew(ast:PALIAS, astfn:psymbolNew(<ptr uint8>(name'value), type), false)
    mut pnode = <ptr ast:PNode>(palias)
    pnode'begin = begin
    pnode'end = type'end

    name'value = 0 # steal from the token the string
    lex:tokenFree(name)

    return pnode
  /if

  return null
/method


func matchWhileEndTok(tok ptr lex:Token) bool
  return tok'type == tokens:ENDWHILE
/func


method synt:Parser.parseWhile() ptr ast:PNode
  mut begin = lex:tokDiscardBegin(me.next()) #discard while token

  mut expr = <ptr ast:PNode>(me.parseExpr())
  if not expr?
    return null
  /if

  if not me.expectDiscard(tokens:NEWLINE)
    ast:pnodeFree(expr)
    return null
  /if

  mut whileBlock = astfn:pnodeNew(ast:PWHILE, 0)
  astfn:pnodeAppendChild(whileBlock, expr)

  mut body = <ptr ast:PNode>(me.parseBody(ptr matchWhileEndTok))
  if not body?
    ast:pnodeFree(whileBlock)
    return null
  /if

  astfn:pnodeAppendChild(whileBlock, body)

  whileBlock'begin = begin
  whileBlock'end = lex:tokDiscardEnd(me.next()) #discard /while

  return whileBlock
/method


func matchIfElseEndTok(tok ptr lex:Token) bool
  return tok'type == tokens:ENDIF or tok'type == tokens:ELSE
/func

func matchIfEndTok(tok ptr lex:Token) bool
  return tok'type == tokens:ENDIF
/func


method synt:Parser.parseIf() ptr ast:PNode
  mut begin = lex:tokDiscardBegin(me.next()) #discard if token

  mut expr = <ptr ast:PNode>(me.parseExpr())
  if not expr?
    return null
  /if

  if not me.expectDiscard(tokens:NEWLINE)
    ast:pnodeFree(expr)
    return null
  /if

  mut block = astfn:pnodeNew(ast:PIF, 0)
  astfn:pnodeAppendChild(block, expr)

  mut mainBlock = <ptr ast:PNode>(me.parseBody(ptr matchIfElseEndTok))

  if not mainBlock?
    ast:pnodeFree(block)
    return null
  /if

  astfn:pnodeAppendChild(block, mainBlock)

  if me'next'type == tokens:ELSE
    me.discardNext() #discard else
    if not me.expectDiscard(tokens:NEWLINE)
      ast:pnodeFree(block)
      return null
    /if

    mut elseBlock = <ptr ast:PNode>(me.parseBody(ptr matchIfEndTok))

    if not elseBlock?
      ast:pnodeFree(block)
      return null
    /if

    astfn:pnodeAppendChild(block, elseBlock)

    block'type = ast:PIFELSE
  /if

  block'begin = begin
  block'end = lex:tokDiscardEnd(me.next()) #discard /if

  return block
/method


method synt:Parser.parseReturn() ptr ast:PNode
  mut returnTok = me.next()

  mut begin = lex:tokExtractBegin(returnTok) # discard "return"
  mut end = lex:tokDiscardEnd(returnTok)

  mut returnNode = astfn:pnodeNew(ast:PRETURN, 0)
  if me'next? and me'next'type != tokens:NEWLINE
    mut expr = me.parseExpr()
    if not expr?
      ast:pnodeFree(returnNode)
      return null
    /if
    astfn:pnodeAppendChild(returnNode, <ptr ast:PNode>(expr))

    end = expr'node'end
  /if

  returnNode'begin = begin
  returnNode'end = end

  return returnNode
/method


method synt:Parser.parseBreakCont(ptype uint16) ptr ast:PNode
  mut breakTok = me.next()

  mut begin = lex:tokExtractBegin(breakTok) # discard "break" or "continue"
  mut end = lex:tokDiscardEnd(breakTok)
  mut pnode = astfn:pnodeNew(ptype, 0)

  pnode'begin = begin
  pnode'end = end

  return pnode
/method


method synt:Parser.parseStatement() ptr ast:PNode

  if not me'next?
    me'err = lex:errorMism(me'last, "a statement or an expression", "EOF")
  /if

  if me'next'type == tokens:BREAK
    return me.parseBreakCont(ast:PBREAK)
  /if

  if me'next'type == tokens:CONTINUE
    return me.parseBreakCont(ast:PCONTINUE)
  /if

  if me'next'type == tokens:DECL
    return me.parseDecl()
  /if

  if me'next'type == tokens:IF
    return me.parseIf()
  /if

  if me'next'type == tokens:MUT
    return me.parseMut(false)
  /if

  if me'next'type == tokens:RETURN
    return me.parseReturn()
  /if

  if me'next'type == tokens:WHILE
    return me.parseWhile()
  /if

  return <ptr ast:PNode>(me.parseExpr())
/method


method synt:Parser.parseBody(isEndToken ptr func(tok ptr lex:Token) bool) ptr ast:PBlock
  mut begin ast:Line

  # If this block is empty, then begin will remain unset.
  # We avoid this, assigning it to the next token position (usually newline or end of block)
  if me'next?
    begin = lex:tokExtractBegin(me'next)
  /if

  mut statement ptr ast:PNode = null
  mut first = true

  mut block = astfn:pblockNew()
  mut pnode = <ptr ast:PNode>(block)

  while me'next? and not isEndToken(me'next)
    statement = me.parseStatement()
    if not statement?
      ast:pnodeFree(pnode)
      return null
    /if

    astfn:pnodeAppendChild(pnode, statement)

    if first
      begin = statement'begin
      first = false
    /if

    if not me.expectDiscard(tokens:NEWLINE)
      ast:pnodeFree(pnode)
      return null
    /if
  /while

  if not me'next?
    ast:pnodeFree(pnode)
    return null
  /if

  # if me'next is not null, then the while above quitted because
  # isEndToken(me'next) == true.
  pnode'begin = begin

  # prevent issues from empty blocks.
  pnode'end = statement? => statement'end || begin

  return block
/method


method synt:Parser.makeFunction(pType uint16,
                                name ptr uint8,
                                type ptr ast:PType,
                                endTType uint16,
                                isEndToken ptr func(tok ptr lex:Token) bool) ptr ast:PNode

  if not me.expectDiscard(tokens:NEWLINE)
    return null
  /if

  mut funcNode = <ptr ast:PNode>(astfn:pdeclNew(pType, astfn:psymbolNew(name, type), false))
  mut body = <ptr ast:PNode>(me.parseBody(isEndToken))

  if not body?
    ast:pnodeFree(funcNode)
    return null
  /if

  astfn:pnodeAppendChild(funcNode, body)

  mut endTok = me.expect(endTType)
  if not endTok?
    ast:pnodeFree(funcNode)
    return null
  /if

  funcNode'end = lex:tokDiscardEnd(endTok)

  return funcNode

/method


func makeEntryType() ptr ast:PType
  return astfn:ptypeNew(null, null,astfn:ptypeDescrNew(ast:PTYPE_FUNC, null, null))
/func


func matchEntryEndTok(tok ptr lex:Token) bool
  return tok'type == tokens:ENDENTRY
/func


method synt:Parser.parseEntry() ptr ast:PNode
  mut begin = lex:tokDiscardBegin(me.next())  #discard "entry"

  mut entryNode = me.makeFunction(ast:PENTRY, txt:strclone("_fork_entry"), makeEntryType(), tokens:ENDENTRY, ptr matchEntryEndTok)

  if not entryNode?
    return null
  /if

  entryNode'begin = begin

  return entryNode
/method


method synt:Parser.parseIdentifier() ptr uint8
  mut nameTok = me.expect(tokens:ID)
  if not nameTok?
    return null
  /if

  mut name = txt:strclone(<ptr uint8>(nameTok'value))

  lex:tokenFree(nameTok)

  return name

/method


func matchFuncEndTok(tok ptr lex:Token) bool
  return tok'type == tokens:ENDFUNC
/func


method synt:Parser.parseFuncHead(name ptr ptr uint8, type ptr ptr ast:PType) bool

  val name = me.parseIdentifier()
  if not (val name)?
    return false
  /if

  val type = me.parseFunctionType()

  if not (val type)?
    mem:free(val name)
    return false
  /if

  return true
/method


method synt:Parser.parseFunc() ptr ast:PNode
  mut begin = lex:tokDiscardBegin(me.next()) #discard "func"

  mut name ptr uint8
  mut ptype ptr ast:PType

  if not me.parseFuncHead(ptr name, ptr ptype)
    return null
  /if

  mut functionNode =  me.makeFunction(ast:PFUNCTION, name, ptype, tokens:ENDFUNC, ptr matchFuncEndTok)
  if not functionNode?
    return null
  /if

  functionNode'begin = begin

  return functionNode
/method


func matchMethodEndTok(tok ptr lex:Token) bool
  return tok'type == tokens:ENDMETHOD
/func


method synt:Parser.parseMethodHead(typeModule,typeName,name ptr ptr uint8, type ptr ptr ast:PType) bool
  mut firstId = me.parseIdentifier()
  if not firstId?
    return false
  /if

  if not me'next?
    mem:free(firstId)
    return false
  /if

  if me'next'type == tokens:COLON
    me.discardNext()

    val typeName = me.parseIdentifier()
    if not (val typeName)?
      mem:free(firstId)
      return false
    /if

    val typeModule = firstId
  else
    val typeModule = txt:strclone(me'moduleName)
    val typeName = firstId
  /if

  if not me.expectDiscard(tokens:DOT)
    mem:free(firstId)
    mem:free(val typeName)
    mem:free(val name)
    return false
  /if

  val name = me.parseIdentifier()
  if not (val name)?
    return false
  /if

  val type = me.parseFunctionType()
  if not (val type)?
    mem:free(val name)
    return false
  /if

  return true
/method


method synt:Parser.makeMethod(typeModule,typeName,name ptr uint8, ptype ptr ast:PType) ptr ast:PNode
  mut pnode = me.makeFunction(ast:PMETHOD, name, ptype, tokens:ENDMETHOD, ptr matchMethodEndTok)

  if not pnode?
    return null
  /if

  mut pdecl = <ptr ast:PDecl>(pnode)
  pdecl'methodType = typeName
  pdecl'methodTypeModule = typeModule

  return pnode
/method


method synt:Parser.parseMethod() ptr ast:PNode
  mut begin = lex:tokDiscardBegin(me.next()) #discard "method"

  mut typeModule ptr uint8
  mut typeName ptr uint8
  mut name ptr uint8
  mut ptype ptr ast:PType

  if not me.parseMethodHead(ptr typeModule, ptr typeName, ptr name, ptr ptype)
    return null
  /if

  mut methodNode = me.makeMethod(typeModule, typeName, name, ptype)
  if not methodNode?
    return null
  /if

  methodNode'begin = begin

  return methodNode
/method


method synt:Parser.parseDefinition() ptr ast:PNode

  if not me'next?
    return null
  /if

  if me'next'type == tokens:ALIAS
    return me.parseAlias()
  /if

  if me'next'type == tokens:DECL
    return me.parseDecl()
  /if

  if me'next'type == tokens:ENTRY
    return me.parseEntry()
  /if

  if me'next'type == tokens:FUNC
    return me.parseFunc()
  /if

  if me'next'type == tokens:METHOD
    return me.parseMethod()
  /if

  if me'next'type == tokens:MUT
    return me.parseMut(false)
  /if

  me'err = lex:errorMism(me'last, "'alias', 'decl', 'entry', 'func', 'method' or 'var'", lex:tokenStr(me'next))

  return null

/method

# parses the root node
method synt:Parser.parseProgram() ptr ast:PNode

  if not me'next?
    me'err = lex:error(me'last, "empty input")
    return null
  /if


  # parse module name
  mut moduleName = me.parseModuleName()

  if me.theresError()
    return null
  /if

  me'moduleName = moduleName? => moduleName'name || null

  # parse imports
  mut imports = me.parseImports()

  if me.theresError()
    return null
  /if

  mut pnode = <ptr ast:PNode>(astfn:prootNew(moduleName, imports, me'filename))

  mut definition ptr ast:PNode = null
  mut first = true

  while (definition = me.parseDefinition())?
    astfn:pnodeAppendChild(pnode, definition)

    if me'next? and not me.expectDiscard(tokens:NEWLINE)
      ast:pnodeFree(pnode)
      return null
    /if

    if first
      pnode'begin = definition'begin
      first = false
    /if

    pnode'end = definition'end
  /while

  if me.theresError()
    ast:pnodeFree(pnode)
    return null
  /if

  return pnode

/method


func parse(filename ptr uint8) {file ptr ast:PNode, err ptr ast:Issue}
  mut firstLineno = lex:linenoNew(txt:strclone(filename), 1, 1)

  mut result = lex:lexerNew(filename)
  if result'err?
    lex:linenoFree(firstLineno)

    return {null, lex:issueFromLexError(result'err, firstLineno)}
  /if

  mut lex = result'lex

  # init synt:Parser
  mut prs synt:Parser
  prs'err = null
  prs'lex = lex
  prs'next = lex:lexerNext(lex)
  prs'last = firstLineno
  prs'moduleName = null
  prs'filename = txt:strclone(filename)

  mut lexErr = lex:lexerError(lex)
  if lexErr?
    mut err = lex:issueFromLexError(lexErr, firstLineno)

    lex:linenoFree(firstLineno)
    lex:tokenFree(prs'next)
    mem:free(prs'filename)

    return {null, err}
  /if

  mut ret = prs.parseProgram()

  lex:lexerClose(lex)
  mem:free(prs'filename)

  return {ret, prs'err}
/func


func parseModule(path ptr uint8) {pmod ptr ast:PModule, errs ptr ast:Issues}
  mut issues = ast:issuesNew()

  mut {dir,err} = fs:dir(path)
  mut zero ast:Line = {0 , 0}

  if err?
    issues.error(zero, path, err'msg)
    err:errorFree(err)
    return {null, issues}
  /if

  mut ret = astfn:pmoduleNew()

  while true
    mut {file,err} = dir.next()

    if err?
      issues.error(zero, path, err'msg)
      err:errorFree(err)

      continue
    /if

    if not file?
      break
    /if

    if not file.isDir() and txt:strEndsWith(file'name, ".fork")
      mut {root,issue} = parse(file.path())

      if issue?
        issues.add(issue)
      /if

      if root?
        if not astfn:pmoduleAdd(ret, <ptr ast:PRoot>(root))
          mut msg = "files belonging to different modules in directory"

          issues.error(zero, path, msg)
        /if
      /if
    /if
  /while

  return {ret,issues}
/func
