#  libfork, a base library for the Fork language
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2014, 2015
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the
#  licenses expressed under Section 1.12 of the MPL v2.


module synt


import ast
import astfn
import lex
import mem
import synt
import tokens
import utils


mut PTYPE_BINARY uint8 = 0
mut PTYPE_UNARY uint8 = 2

mut ASSOC_LEFT uint8 = 0
mut ASSOC_RIGHT uint8 = 1

mut emptyExpr ast:PExpr


func isBinary(tok ptr lex:Token) bool
  return tok != null and (tok'type mod 10) < 2
/func


func isUnary(tok ptr lex:Token) bool
  return tok != null and not isBinary(tok)
/func


func assocRight(tok ptr lex:Token) bool
  return tok != null and ((tok'type & 1) != 0)
/func


func assocLeft(tok ptr lex:Token) bool
  return tok != null and not assocRight(tok)
/func


func tokTypePrec(ttype uint16) int16
  if ttype == tokens:MINUS
    return tokTypePrec(tokens:PLUS)
  /if

  return ttype / 1000
/func


func opPrec(tok ptr lex:Token) int16
  if tok != null
    return tokTypePrec(tok'type)
  /if

  return 0
/func


func isOp(tok ptr lex:Token) bool
  return opPrec(tok) != 0
/func


func isValidInExpr(tok ptr lex:Token) bool
  return tok != null and (isOp(tok) or tok'type == tokens:ID or tok'type == tokens:NUMBER)
/func


func parserParseCastTag(ctx ptr synt:ParserContext) ptr ast:PExpr

  mut castTok ptr lex:Token = null

  # If we have the "cast" operator, than we should read it, and use it to mark
  # the expression's beginning.
  # Otherwise it's a `<` and we must create a "fake" cast token - to create a
  # cast PExpr.
  if ctx'next'type == tokens:CAST
    castTok = synt:nextTok(ctx)
  /if

  mut minor = synt:expect(ctx, tokens:MINOR)

  if not minor?
    # tokenFree SHOULD check for nulls - like every free function should - and
    # be noop for them.
    lex:tokenFree(castTok)
    return null
  /if

  if not castTok?
    castTok = lex:tokenNew(tokens:CAST, 0, lex:linenoClone(minor'lineno), minor'endPos)
  /if

  lex:tokenFree(minor)

  mut type = synt:parserParseType(ctx)
  if not type?
    lex:tokenFree(castTok)
    return null
  /if

  if not synt:expectDiscard(ctx, tokens:MAJOR) or not synt:expectDiscard(ctx, tokens:OPAR)
    lex:tokenFree(castTok)
    mem:decRef(type)
    return null
  /if

  mut expr = synt:parserParseExpr(ctx)
  if not expr?
    lex:tokenFree(castTok)
    mem:decRef(type)
  /if

  mut cpar = synt:expect(ctx, tokens:CPAR)
  if not cpar?
    lex:tokenFree(castTok)
    mem:decRef(type)
    return null
  /if

  mut pexpr = astfn:pexprNew(castTok, expr, null, lex:tokExtractBegin(castTok), lex:tokDiscardEnd(cpar))
  pexpr'node'value = cast<uintptr>(type)

  return pexpr
/func


func parserParseSizeOp(ctx ptr synt:ParserContext) ptr ast:PExpr

  mut sizeTok = synt:nextTok(ctx)


  if not synt:expectDiscard(ctx, tokens:OPAR)
    lex:tokenFree(sizeTok)
    return null
  /if

  mut type = synt:parserParseType(ctx)
  if type == null
    lex:tokenFree(sizeTok)
    return null
  /if

  mut cpar = synt:expect(ctx, tokens:CPAR)
  if cpar == null
    lex:tokenFree(sizeTok)
    return null
  /if

  mut sizeop = astfn:pexprNew(sizeTok, null, null, lex:tokExtractBegin(sizeTok), lex:tokDiscardEnd(cpar))
  sizeop'node'value = cast<uintptr>(type)

  return sizeop
/func


func tokIsPostfixExpressionSuffixStart(tok ptr lex:Token) bool
  return tok != null and (tok'type == tokens:OPAR or tok'type == tokens:OBRAC or tok'type == tokens:INC or tok'type == tokens:DEC or tok'type == tokens:APOS or tok'type == tokens:DOT)
/func


func parserParseId(ctx ptr synt:ParserContext) ptr ast:PExpr
  mut first = synt:nextTok(ctx)
  mut ret = astfn:pexprNewSingle(first)

  if ctx'next != null and ctx'next'type == tokens:COLON
    mut colon = synt:nextTok(ctx)

    mut id = synt:expect(ctx, tokens:ID)
    if id == null
      lex:tokenFree(colon)
      ast:pnodeFree(cast<ptr ast:PNode>(ret))
      return null
    /if

    mut idExpr = astfn:pexprNewSingle(id)
    ret = astfn:pexprNew(colon, ret, idExpr, ret'node'begin, idExpr'node'end)
  /if

  return ret

/func


func parserParseGenParens(ctx ptr synt:ParserContext, cpar uint16) ptr ast:PExpr

  mut expression = parserParseAssignExpr(ctx)

  if expression == null
    return null
  /if

  mut cparTok = synt:expect(ctx, cpar)
  if cparTok == null
    ast:pnodeFree(cast<ptr ast:PNode>(expression))
    return null
  /if

  lex:tokenFree(cparTok)

  return expression

/func


func parserParseParens(ctx ptr synt:ParserContext) ptr ast:PExpr

  synt:discardTok(ctx)
  return parserParseGenParens(ctx, tokens:CPAR)

/func


func parserParsePrimaryExpr(ctx ptr synt:ParserContext) ptr ast:PExpr

  if not ctx'next?
    ctx'prs'err = lex:error(ctx'last, "expected a primary expression, got an EOF")
    return null
  /if

  if    ctx'next'type == tokens:FALSE \
     or ctx'next'type == tokens:TRUE \
     or ctx'next'type == tokens:STRING \
     or ctx'next'type == tokens:NUMBER \
     or ctx'next'type == tokens:NULL \
     or ctx'next'type == tokens:ME

    return astfn:pexprNewSingle(synt:nextTok(ctx))
  /if

  if ctx'next'type == tokens:ID
    return parserParseId(ctx)
  /if

  if ctx'next'type == tokens:CAST or ctx'next'type == tokens:MINOR
    return parserParseCastTag(ctx)
  /if

  if ctx'next'type == tokens:SIZE
    return parserParseSizeOp(ctx)
  /if

  if ctx'next'type == tokens:OCURLY
    
  /if

  if ctx'next'type != tokens:OPAR
    ctx'prs'err = lex:errorMism(ctx'next'lineno, "an identifier, a costant, a struct literal or an expression between ()", lex:tokenStr(ctx'next))
    return null
  /if

  return parserParseParens(ctx)

/func


func parserParseAccessExpr(ctx ptr synt:ParserContext, lhs ptr ast:PExpr) ptr ast:PExpr

  mut obrac = synt:nextTok(ctx)
  mut expression = parserParseGenParens(ctx, tokens:CBRAC)

  if not expression?
      return null
  /if

  return astfn:pexprNew(obrac, lhs, expression, lhs'node'begin, expression'node'end)

/func


func parserParseCallExpr(ctx ptr synt:ParserContext, lhs ptr ast:PExpr) ptr ast:PExpr

  mut opar = synt:nextTok(ctx)

  if not opar?
    return null
  /if

  mut begin = lex:tokExtractBegin(opar)
  mut callExpr = astfn:pexprNew(opar, lhs, null, begin, begin)
  mut callPNode = cast<ptr ast:PNode>(callExpr)

  mut next = ctx'next
  mut first = true


  while ctx'next != null and ctx'next'type != tokens:CPAR

    if ctx'next'type != tokens:COMMA and not first

      ctx'prs'err = lex:errorMism(ctx'last, "a comma ','", lex:tokenStr(ctx'next))
      ast:pnodeFree(callPNode)
      return null

    else

    #if it's not the first argument than it is COMMA
      if not first
        synt:discardTok(ctx)
      else
        first = false
      /if

    /if

    mut arg = parserParseAssignExpr(ctx)
    if arg == null
      ast:pnodeFree(callPNode)
      return null
    /if

    astfn:pnodeAppendChild(callPNode, cast<ptr ast:PNode>(arg))

  /while

  mut cpar = synt:expect(ctx, tokens:CPAR)
  if cpar == null
    ast:pnodeFree(callPNode)
    return null
  /if

  callExpr'node'end = lex:tokDiscardEnd(cpar)

  return callExpr

/func


func parserParseFieldDotExpr(ctx ptr synt:ParserContext, lhs ptr ast:PExpr) ptr ast:PExpr

  # APOS or DOT
  mut op = synt:nextTok(ctx)
  mut id = synt:expect(ctx, tokens:ID)

  if id == null
    lex:tokenFree(op)
    return null
  /if

  mut idExpr = astfn:pexprNewSingle(id)

  return astfn:pexprNew(op, lhs, idExpr, lhs'node'begin, idExpr'node'end)
/func


func parserParsePostfixSuffix(ctx ptr synt:ParserContext, primaryLhs ptr ast:PExpr) ptr ast:PExpr

  mut lhs = primaryLhs

  while true
    if ctx'next == null
      break
    /if

    if ctx'next'type == tokens:OBRAC
      lhs = parserParseAccessExpr(ctx, lhs)
    else
      if ctx'next'type == tokens:OPAR
        lhs = parserParseCallExpr(ctx, lhs)
      else
        if ctx'next'type == tokens:INC or ctx'next'type == tokens:DEC or ctx'next'type == tokens:QUEST
          mut pfOp = synt:nextTok(ctx)
          lhs = astfn:pexprNew(pfOp, lhs, null, lhs'node'begin, lex:tokExtractEnd(pfOp))
        else
          if ctx'next'type == tokens:APOS or ctx'next'type == tokens:DOT
            lhs = parserParseFieldDotExpr(ctx, lhs)
          else
            break
          /if
        /if
      /if
    /if

    if lhs == null
      return null
    /if
  /while

  return lhs
/func


func parserParsePostfixExpr(ctx ptr synt:ParserContext) ptr ast:PExpr
  mut primary = parserParsePrimaryExpr(ctx)

  if primary == null
    return null
  /if

  return parserParsePostfixSuffix(ctx, primary)
/func


func parserParseUnaryExprOp(ctx ptr synt:ParserContext) ptr ast:PExpr
  mut operator = synt:nextTok(ctx)

  mut result = parserParseUnaryExpr(ctx)
  if result == null
    lex:tokenFree(operator)
    return null
  /if

  if operator'type == tokens:MINUS
    operator'type = tokens:UMINUS
  /if

  return astfn:pexprNew(operator, result, null, lex:tokExtractBegin(operator), result'node'end)
/func


func parserParseUnaryExpr(ctx ptr synt:ParserContext) ptr ast:PExpr
  if ctx'next == null
    ctx'prs'err = lex:error(ctx'last, "unexpected EOF")
    return null
  /if

  if isUnary(ctx'next)
    return parserParseUnaryExprOp(ctx)
  /if

  return parserParsePostfixExpr(ctx)
/func


func isConditionalOperator(tok ptr lex:Token) bool
  return tok != null and tok'type == tokens:FATARROW
/func


func parserParseBinaryRhs(ctx ptr synt:ParserContext, lhs ptr ast:PExpr, minPri uint16) ptr ast:PExpr
  mut curOpPrec uint16
  mut rhs ptr ast:PExpr = null

  while ctx'next != null and ((curOpPrec = opPrec(ctx'next)) >= minPri)
    mut opTok = synt:nextTok(ctx)
    mut opIsRight = assocRight(opTok)

    mut ternaryMiddle ptr ast:PExpr = null

    if isConditionalOperator(opTok)
      if (ternaryMiddle = synt:parserParseExpr(ctx)) == null or not synt:expectDiscard(ctx, tokens:SEPARATOR)
        lex:tokenFree(opTok)
        return null
      /if
    /if

    rhs = parserParseUnaryExpr(ctx)

    if rhs == null
      return null
    /if

    mut nextOpPrec = opPrec(ctx'next)

    if ctx'next != null and (nextOpPrec > curOpPrec or (opIsRight and nextOpPrec == curOpPrec))
      mut rhsMinPrec = curOpPrec
      if not opIsRight
        curOpPrec++
      /if

      rhs = parserParseBinaryRhs(ctx, rhs, curOpPrec)
      if rhs == null
        return null
      /if
    /if

    lhs = astfn:pexprNewTernary(opTok, lhs, ternaryMiddle, rhs, lhs'node'begin, rhs'node'end)
  /while

  return lhs
/func


func parserParseAssignExpr(ctx ptr synt:ParserContext) ptr ast:PExpr
  mut lhs = parserParseUnaryExpr(ctx)

  return lhs != null => parserParseBinaryRhs(ctx, lhs, tokTypePrec(tokens:ASSIGN)) || null
/func


func parserParseExpr(ctx ptr synt:ParserContext) ptr ast:PExpr
  return parserParseAssignExpr(ctx)
/func
