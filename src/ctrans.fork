#  ctrans, Fork to C transpiler
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2015
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the
#  licenses expressed under Section 1.12 of the MPL v2.


module ctrans


import ast
import ctrans
import kv
import list
import mem
import pair
import txt


func ctransGenDecls(tr ptr ctrans:Transl,
                    root ptr ast:PRoot)

  mut len = root'node'node'leaves.len()
  mut i uintptr = 0
  mut moduleName ptr uint8 = (root'moduleName != null) => root'moduleName'name || null

  while i < len
    mut child = cast<ptr ast:PDecl>(val root'node'node'leaves.get(i))

    if child'node'type != ast:PALIAS and child'node'type != ast:PENTRY

      mut key = ast:declKey(child)

      mut dinfo = ast:stabGet(root'node'syms, key)

      mem:free(key)

      mut wantsModName = tr'header or not child'isDecl

      mut sym = ctrans:translGenSym(wantsModName => moduleName || null, child, dinfo)

      ctrans:translExtern(tr, sym)

      if not child'isDecl
        if child'node'type == ast:PMUT
          mut expr = child'node'leaves.get(0)

          ctrans:translGlobVar(tr, sym, root, expr != null => cast<ptr ast:PExpr>(val expr) || null)
        else
          if child'node'type == ast:PFUNCTION or child'node'type == ast:PMETHOD
            ctrans:translFunc(tr, root, root'fileName, sym, child)
          /if
        /if
      /if

      mem:free(sym)

    /if

    i++
  /while
/func


func ctransGenImports(tr ptr ctrans:Transl,
                      root ptr ast:PRoot)

  mut i uintptr = 0
  mut len = root'imports.len()

  while i < len
    mut impdef = cast<ptr ast:StringDef>(val root'imports.get(i))

    ctrans:translFordInc(tr, impdef'name)

    i++
  /while
/func


func ctransGenTypedefs(tr ptr ctrans:Transl,
                       root ptr ast:PRoot)

  mut als = root'aliases'syms

  mut i uintptr = 0
  mut len = kv:kvLen(als)

  while i < len
    mut pair = kv:kvGetAt(als, i)
    mut name = cast<ptr uint8>(pair'key)
    mut type = cast<ptr ast:DeclInfo>(pair'value)'type

    ctrans:translTypedef(tr, name, type)

    i++
  /while
/func


# if ford is true, than emit include guards.
func ctransTranslate(tr ptr ctrans:Transl,
                     root ptr ast:PRoot)

  ctransGenImports(tr, root)
  ctransGenTypedefs(tr, root)
  ctransGenDecls(tr, root)

  if root'entryNode != null
    ctrans:ctransGenEntry(tr, root)
  /if
/func
