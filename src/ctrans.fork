#  ctrans, Fork to C transpiler
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2015
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the
#  licenses expressed under Section 1.12 of the MPL v2.


module ctrans


import ast
import cs
import ctrans
import err
import io
import kv
import libfork
import list
import mem
import pair
import proc
import tokens
import txt
import tty


func init(tr ptr ctrans:Transl, header bool, name ptr uint8)
  tr'includes = cs:new(40)
  tr'typedefs = cs:new(300)
  tr'externs = cs:new(300)
  tr'vars = cs:new(300)
  tr'funcs = cs:new(300)
  tr'cnt = 0

  tr'header = header
  tr'modName = name
/func


func nullSafestreq(str1,str2 ptr uint8) bool
  return (str1? and str2?) => txt:strequals(str1, str2) || str1 == str2
/func


method ctrans:Transl.extern(sym ptr uint8)
  me'externs.addWord("extern")
  me'externs.add(sym)
  me'externs.addLine(";")
/method


method ctrans:Transl.fnblock(root ptr ast:PRoot,
                             block ptr ast:PBlock,
                             rvoType ptr ast:Type,
                             fname ptr uint8)

  ctrans:translBlock(me'funcs, me, root, block, rvoType, fname, 2, true)
/method


method ctrans:Transl.function(root ptr ast:PRoot,
                              fname,sym ptr uint8,
                              type ptr ast:Type,
                              fn ptr ast:PDecl)

  me'funcs.addDebugLine(fname, fn'node'begin'line)
  me'funcs.addWord(sym)

  mut rvoType = ast:typeIsStruct(type'retType) => type'retType || null

  mut block = cast<ptr ast:PBlock>(val fn'node'leaves.get(0))

  me.fnblock(root, block, rvoType, fname)

  me'funcs.addLine("\n")
/method


method ctrans:Transl.forkmain(root ptr ast:PRoot)
  mut entryN = root'entryNode

  me'funcs.addDebugLine(root'fileName, entryN'node'begin'line)
  me'funcs.add("void __fork_entry(void) ")

  mut block = cast<ptr ast:PBlock>(val entryN'node'leaves.get(0))

  me.fnblock(root, block, null, root'fileName)

  me'funcs.addLine("\n")
/method


method ctrans:Transl.globVar(sym ptr uint8, root ptr ast:PRoot, expr ptr ast:PExpr)
  me'vars.add(sym)

  if expr?
    me'vars.add(" = ")
    me.globExpr(root, expr)
  /if

  me'vars.addLine(";")
/method


method ctrans:Transl.typedef(name ptr uint8, type ptr ast:Type, ssa bool)
  me'typedefs.addWord("typedef")

  me.genCsym(me'typedefs, null, ssa => null || me'modName, name, type, -1, true)

  me'typedefs.addLine(";\n")
/method


method ctrans:Transl.dump(stream ptr io:Stream) ptr err:Error
  io:streamWrite(stream, "// generated with ctrans v")
  io:streamWrite(stream, ctrans:VERSION)
  io:streamWrite(stream, " (")

  io:streamWrite(stream, "libfork v")
  io:streamWrite(stream, libfork:VERSION)
  io:streamWrite(stream, ")\n\n\n")

  if me'header
    io:streamWrite(stream, "#ifndef ford$$")
    io:streamWrite(stream, me'modName )
    io:streamWrite(stream, "_h\n")

    io:streamWrite(stream, "#define ford$$")
    io:streamWrite(stream, me'modName)
    io:streamWrite(stream, "_h\n\n\n")
  /if

  io:streamWrite(stream, "#include <stdint.h>\n\n")

  #just in case, you know.
  io:streamWrite(stream, "#undef NULL\n\n")

  mut includes = cs:unwrap(me'includes)
  io:streamWrite(stream, includes)
  mem:free(includes)

  io:streamWrite(stream, "\n\n")

  mut typedefs = cs:unwrap(me'typedefs)
  io:streamWrite(stream, typedefs)
  mem:free(typedefs)

  io:streamWrite(stream, "\n\n")

  mut externs = cs:unwrap(me'externs)
  io:streamWrite(stream, externs)
  mem:free(externs)

  io:streamWrite(stream, "\n\n")

  mut vars = cs:unwrap(me'vars)
  io:streamWrite(stream, vars)
  mem:free(vars)

  io:streamWrite(stream, "\n\n")

  mut funcs = cs:unwrap(me'funcs)
  io:streamWrite(stream, funcs)
  mem:free(funcs)

  io:streamWrite(stream, "\n\n")

  if me'header
    io:streamWrite(stream, "\n\n#endif //ford$$")
    io:streamWrite(stream, me'modName)
    io:streamWrite(stream, "_h\n\n")
  /if

  return io:streamError(stream)
/method


method ctrans:Transl.includeFord(fordName ptr uint8)
  me'includes.add("#include <ford$$")
  me'includes.add(fordName)
  me'includes.addLine(".h>")
/method


method ctrans:Transl.genDecls(root ptr ast:PRoot)

  mut len = root'node'node'leaves.len()
  mut i uintptr = 0
  mut moduleName ptr uint8 = root'moduleName? => root'moduleName'name || null

  while i < len
    mut child = cast<ptr ast:PDecl>(val root'node'node'leaves.get(i))

    if child'node'type != ast:PALIAS and child'node'type != ast:PENTRY

      mut key = ast:declKey(child)

      mut dinfo = ast:stabGet(root'node'syms, key)

      mem:free(key)

      mut wantsModName = me'header or not child'isDecl

      mut sym = me.translSym(wantsModName => moduleName || null, child, dinfo)

      me.extern(sym)

      if not child'isDecl
        if child'node'type == ast:PMUT
          mut expr = child'node'leaves.get(0)

          me.globVar(sym, root, expr? => cast<ptr ast:PExpr>(val expr) || null)
        else
          if child'node'type == ast:PFUNCTION or child'node'type == ast:PMETHOD
            me.function(root, root'fileName, sym, dinfo'type, child)
          /if
        /if
      /if

      mem:free(sym)

    /if

    i++
  /while
/method


method ctrans:Transl.genImports(root ptr ast:PRoot)

  mut i uintptr = 0
  mut len = root'imports.len()

  while i < len
    mut impdef = cast<ptr ast:StringDef>(val root'imports.get(i))

    me.includeFord(impdef'name)

    i++
  /while
/method


method ctrans:Transl.genTypedefs(root ptr ast:PRoot)

  mut als = root'aliases'syms

  mut i uintptr = 0
  mut len = als.len()

  while i < len
    mut pair = als.getAt(i)
    mut name = cast<ptr uint8>(pair'key)
    mut type = cast<ptr ast:DeclInfo>(pair'value)'type

    me.typedef(name, type, false)

    i++
  /while
/method


# if ford is true, than emit include guards.
method ctrans:Transl.translate(root ptr ast:PRoot)

  me.genImports(root)
  me.genTypedefs(root)
  me.genDecls(root)

  if root'entryNode?
    me.forkmain(root)
  /if
/method
