#  ctrans, Fork to C transpiler
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2015
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the
#  licenses expressed under Section 1.12 of the MPL v2.


module ctrans


import ast
import cs
import ctrans
import err
import io
import kv
import libfork
import list
import mem
import pair
import parser
import proc
import set
import txt
import tty


func init(tr ptr ctrans:Transl,
          name ptr uint8,
          parser ptr parser:Parser)

  tr'includes = cs:new(40)
  tr'typedefs = cs:new(300)
  tr'externs = cs:new(300)
  tr'vars = cs:new(300)
  tr'funcs = cs:new(300)
  tr'parser = parser
  tr'cnt = 0

  tr'modName = name
/func


func nullSafestreq(str1,str2 ptr uint8) bool
  return (str1? and str2?) => txt:strequals(str1, str2) || str1 == str2
/func


method ctrans:Transl.extern(sym ptr uint8)
  me'externs.addWord("extern")
  me'externs.add(sym)
  me'externs.addLine(";")
/method


method ctrans:Transl.fnblock(root ptr ast:PRoot,
                             block ptr ast:PBlock,
                             rvoType ptr ast:Type,
                             fname ptr uint8)

  ctrans:translBlock(me'funcs, me, root, block, rvoType, fname, 2, true)
/method


method ctrans:Transl.function(root ptr ast:PRoot,
                              fname,sym ptr uint8,
                              type ptr ast:Type,
                              fn ptr ast:PDecl)

  me'funcs.addDebugLine(fname, fn'node'begin'line)
  me'funcs.addWord(sym)

  mut rvoType = (type'retType? and type'retType.isStruct()) => type'retType || null

  mut block = <ptr ast:PBlock>(val fn'node'leaves.get(0))



  me.fnblock(root, block, rvoType, fname)

  me'funcs.addLine("\n")
/method


method ctrans:Transl.forkmain(root ptr ast:PRoot)
  mut entryN = root'entryNode

  me'funcs.addDebugLine(root'fileName, entryN'node'begin'line)
  me'funcs.add("void __fork_entry(void) ")

  mut block = <ptr ast:PBlock>(val entryN'node'leaves.get(0))

  me.fnblock(root, block, null, root'fileName)

  me'funcs.addLine("\n")
/method


method ctrans:Transl.globVar(sym ptr uint8, root ptr ast:PRoot, expr ptr ast:PExpr)
  me'vars.add(sym)

  if expr?
    me'vars.add(" = ")
    me.globExpr(root, expr)
  /if

  me'vars.addLine(";")
/method


method ctrans:Transl.typedef(name ptr uint8, type ptr ast:Type, ssa bool)
  me'typedefs.addWord("typedef")

  me.genCsym(me'typedefs, null, ssa => null || me'modName, name, type, -1, true)

  me'typedefs.addLine(";\n")
/method


method ctrans:Transl.dump() {headers,cfile ptr uint8}
  mut cs = cs:new(200)

  cs.add("// generated with ctrans v")
  cs.add(ctrans:VERSION)
  cs.add(" (")

  cs.add("libfork v")
  cs.add(libfork:VERSION)
  cs.add(")\n\n\n")

  cs.add("#include <stdint.h>\n\n")

  #just in case, you know.
  cs.add("#undef NULL\n\n")

  mut includes = cs:unwrap(me'includes)
  cs.add(includes)
  mem:free(includes)

  cs.add("\n\n")

  mut typedefs = cs:unwrap(me'typedefs)
  cs.add(typedefs)
  mem:free(typedefs)

  cs.add("\n\n")

  mut headers = cs:new(200)

  mut externs = cs:unwrap(me'externs)
  headers.add(externs)
  mem:free(externs)

  headers.add("\n\n")

  mut vars = cs:unwrap(me'vars)
  headers.add(vars)
  mem:free(vars)

  mut headRet = cs:unwrap(headers)

  cs.add(headRet)
  cs.add("\n\n")

  mut funcs = cs:unwrap(me'funcs)
  cs.add(funcs)
  mem:free(funcs)

  cs.add("\n\n")

  return {headRet,cs:unwrap(cs)}
/method


# Include a ford.
method ctrans:Transl.includeFord(fordName ptr uint8, done ptr set:Set)
  if done.contains(fordName)
    return
  /if

  # Find ford for this include in parser.

  mut ford = me'parser.getImport(fordName)

  if ford'extra?
    mut impLen = ford'imports.len()
    mut i uintptr = 0

    while i < impLen
      mut upImp = cast<ptr uint8>(val ford'imports.get(i))

      me.includeFord(upImp, done)

      i++
    /while

    me'includes.add("\n// module ")
    me'includes.add(fordName)
    me'includes.add("\n\n\n")
    me'includes.addLine(ford'extra)
  /if
/method


method ctrans:Transl.genDecls(root ptr ast:PRoot)

  mut len = root'node'node'leaves.len()
  mut i uintptr = 0
  mut moduleName ptr uint8 = root'moduleName? => root'moduleName'name || null

  while i < len
    mut child = <ptr ast:PDecl>(val root'node'node'leaves.get(i))

    if child'node'type != ast:PALIAS and child'node'type != ast:PENTRY

      mut key = ast:declKey(child)

      mut dinfo = root'node'syms.get(key)

      mem:free(key)

      mut wantsModName = me'modName? or not child'isDecl

      mut sym = me.translSym(wantsModName => moduleName || null, child, dinfo)

      me.extern(sym)

      if not child'isDecl
        if child'node'type == ast:PMUT
          mut expr = child'node'leaves.get(0)

          me.globVar(sym, root, expr? => <ptr ast:PExpr>(val expr) || null)
        else
          if child'node'type == ast:PFUNCTION or child'node'type == ast:PMETHOD
            me.function(root, root'fileName, sym, dinfo'type, child)
          /if
        /if
      /if

      mem:free(sym)

    /if

    i++
  /while
/method


method ctrans:Transl.genImports(root ptr ast:PRoot)

  mut i uintptr = 0
  mut len = root'imports.len()

  mut done set:Set

  set:strinit(ptr done, 10)

  while i < len
    mut impdef = <ptr ast:StringDef>(val root'imports.get(i))

    me.includeFord(impdef'name, ptr done)

    i++
  /while

  set:deinit(ptr done)
/method


method set:Set.gatherImports(root ptr ast:PRoot)
  mut impLen = root'imports.len()

  mut i uintptr = 0
  while i < impLen
    mut impdef = <ptr ast:StringDef>(val root'imports.get(i))
    me.put(impdef'name)

    i++
  /while
/method


method ctrans:Transl.genTypedefs(root ptr ast:PRoot)

  mut als = root'aliases'syms

  mut i uintptr = 0
  mut len = als.len()

  while i < len
    mut pair = als.getAt(i)
    mut name = <ptr uint8>(pair'key)
    mut type = <ptr ast:DeclInfo>(pair'value)'type

    me.typedef(name, type, false)

    i++
  /while
/method


method ctrans:Transl.translate(root ptr ast:PRoot)

  me.genImports(root)
  me.genTypedefs(root)
  me.genDecls(root)

  if root'entryNode?
    me.forkmain(root)
  /if
/method


method ctrans:Transl.translateModule(pmod ptr ast:PModule)
  mut set set:Set
  set:strinit(ptr set, 10)

  mut len = pmod'roots.len()

  mut i uintptr = 0
  while i < len
    mut root = <ptr ast:PRoot>(val pmod'roots.get(i))

    set.gatherImports(root)

    me.genTypedefs(root)
    me.genDecls(root)

    i++
  /while

  mut done set:Set
  set:strinit(ptr done, set.len())

  mut iter = set.iter()

  mut imp ptr uint8

  while (imp = <ptr uint8>(iter.next()))?
    me.includeFord(imp, ptr done)
  /while

  set:iterFree(iter)

  set:deinit(ptr set)

  if pmod'entryNode?
    me.forkmain(pmod'entryNode.findPRoot())
  /if
/method
