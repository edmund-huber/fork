#  ctrans, Fork to C transpiler
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2015
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the
#  licenses expressed under Section 1.12 of the MPL v2.


module ctrans


import ast
import ctrans
import kv
import list
import mem
import pair
import txt


func ctransGenDecls(tr ptr ctrans:Transl,
                    root ptr ast:PRoot)

  mut len = list:listLen(root'node'node'leaves)
  mut i uintptr = 0
  mut moduleName ptr uint8 = (root'moduleName != null) => root'moduleName'name || null

  while i < len
    mut child = cast<ptr ast:PDecl>(val list:listGet(root'node'node'leaves, i))

    if child'node'type != ast:PALIAS and child'node'type != ast:PENTRY
      mut dinfo = ast:stabGet(root'node'syms, child'sym'name)

      mut sym = ctrans:translGenSym(moduleName, child'sym'name, dinfo'type)

      ctrans:translExtern(tr, sym)

      if child'node'type == ast:PMUT
        mut expr = list:listGet(child'node'leaves, 0)

        ctrans:translGlobVar(tr, sym, expr != null => cast<ptr ast:PExpr>(val expr) || null)
      else
        if child'node'type == ast:PFUNCTION
          ctrans:translFunc(tr, root'fileName, sym, child)
        /if
      /if

      mem:free(sym)

    /if

    i++
  /while
/func


func ctransGenImports(tr ptr ctrans:Transl,
                      root ptr ast:PRoot)

  mut i uintptr = 0
  mut len = list:listLen(root'imports)

  while i < len
    mut impdef = cast<ptr ast:StringDef>(val list:listGet(root'imports, i))

    ctrans:translFordInc(tr, impdef'name)

    i++
  /while
/func


func ctransGenTypedefs(tr ptr ctrans:Transl,
                       root ptr ast:PRoot)

  mut als = root'aliases'syms

  mut i uintptr = 0
  mut len = kv:kvLen(als)

  while i < len
    mut pair = kv:kvGetAt(als, i)
    mut name = cast<ptr uint8>(pair'key)
    mut type = cast<ptr ast:DeclInfo>(pair'value)'type

    ctrans:translTypedef(tr, name, type)

    i++
  /while
/func


# if ford is true, than emit include guards.
func ctransTranslate(tr ptr ctrans:Transl,
                     root ptr ast:PRoot)

  ctransGenImports(tr, root)
  ctransGenTypedefs(tr, root)
  ctransGenDecls(tr, root)

  if root'entryNode != null
    ctrans:ctransGenEntry(tr, root)
  /if
/func
