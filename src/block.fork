#  ctrans, Fork to C transpiler
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2015
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the
#  licenses expressed under Section 1.12 of the MPL v2.


module ctrans


import ast
import cs
import ctrans
import list
import mem
import txt



# LineStr functions
func lsFree(ls ptr ctrans:LineStr)
  mem:free(ls'str)
  mem:free(ls)
/func


func lsNew(line ast:Line, str ptr uint8) ptr ctrans:LineStr
  mut ls = cast<ptr ctrans:LineStr>(mem:alloc(size(ctrans:LineStr)))

  ls'line = line
  ls'str = str

  return ls
/func


# Block functions
func blNew(unit ptr ctrans:Transl, pad uintptr, rvoType ptr ast:Type) ctrans:Block
  mut ret ctrans:Block

  ret'decls = cs:new(20)
  ret'vars = cs:new(20)
  ret'stmts = cs:new(20)
  ret'unit = unit
  ret'pad = pad
  ret'rvoType = rvoType

  return ret
/func


method ctrans:Block.padDecls()
  me'decls.addPad(me'pad)
/method


method ctrans:Block.padStmts()
  me'stmts.addPad(me'pad)
/method


method ctrans:Block.padVars()
  me'vars.addPad(me'pad)
/method


# Deinits the block.
method ctrans:Block.dumpInCs(cs ptr cs:Charstash)
  mut decls = cs:unwrap(me'decls)
  cs.addLine(decls)
  mem:free(decls)

  cs.add("\n\n")

  mut vars = cs:unwrap(me'vars)
  cs.addLine(vars)
  mem:free(vars)

  cs.add("\n\n")

  mut stmts = cs:unwrap(me'stmts)
  cs.addLine(stmts)
  mem:free(stmts)
/method


method ctrans:Block.decPad()
  if me'pad > 0
    me'pad = me'pad - 2
  /if
/method


method ctrans:Block.ifblock(stmt ptr ast:PNode,
                            root ptr ast:PRoot,
                            fname ptr uint8)

  mut pexpr = cast<ptr ast:PExpr>(val stmt'leaves.get(0))

  mut cond = me.expr(root, pexpr, fname, stmt'begin'line)

  me.padStmts()
  me'stmts.addDebugLine(fname, stmt'begin'line)

  me.padStmts()
  me'stmts.add("if (")
  me'stmts.add(cond.value())
  me'stmts.addWord(")")

  mut block = cast<ptr ast:PBlock>(val stmt'leaves.get(1))

  me.subblock(root, block, fname)

  if stmt'type == ast:PIFELSE
    me'stmts.add(" else ")

    block = cast<ptr ast:PBlock>(val stmt'leaves.get(2))

    me.subblock(root, block, fname)
  /if

  cond.wipe()
/method


method ctrans:Block.incPad()
  me'pad = me'pad + 2
/method


method ctrans:Block.returnstmt(stmt ptr ast:PNode,
                               root ptr ast:PRoot,
                               fname ptr uint8)

  mut line = stmt'begin'line

  mut expr = stmt'leaves.get(0)

  mut elem ctrans:Elem

  if expr?
    me'stmts.addChar(32)

    elem = me.expr(root, cast<ptr ast:PExpr>(val expr), fname, line)

    if me'rvoType?
      mut rvoOut ctrans:Elem

      rvoOut'str = "(*_rvoOut)"
      rvoOut'type = me'rvoType

      me.assign(rvoOut, elem, fname, line)

      elem.wipe()
    /if
  /if

  me.padStmts()
  me'stmts.addDebugLine(fname, line)

  me.padStmts()
  me'stmts.add("return")

  if expr? and not me'rvoType?
    me'stmts.add(" ")
    me'stmts.add(elem.value())

    elem.wipe()
  /if
/method


method ctrans:Block.statement(root ptr ast:PRoot,
                              block ptr ast:PBlock,
                              stmt ptr ast:PNode,
                              fname ptr uint8)

  mut semicolon = false

  if stmt'type == ast:PIF or stmt'type == ast:PIFELSE
    me.ifblock(stmt, root, fname)
  else

    if    stmt'type == ast:PMUT \
       or stmt'type == ast:PFUNCTION \
       or stmt'type == ast:PMETHOD

      me.declaration(root, fname, block, stmt)
    else
      if stmt'type == ast:PWHILE
        me.whileblock(stmt, root, fname)
        semicolon = false
      else
        if stmt'type == ast:PCONTINUE
          me'stmts.add("continue")
          semicolon = true
        else
          if stmt'type == ast:PBREAK
            me'stmts.add("break")
            semicolon = true
          else
            if stmt'type == ast:PRETURN
              me.returnstmt(stmt, root, fname)
              semicolon = true
            else
              if stmt'type == ast:PEXPR
                mut ign = me.expr(root, cast<ptr ast:PExpr>(stmt), fname, stmt'begin'line)
                ign.wipe()
              /if
            /if
          /if
        /if
      /if
    /if
  /if


  me'stmts.addLine(semicolon => ";" || "")
/method


method ctrans:Block.subblock(root ptr ast:PRoot,
                             block ptr ast:PBlock,
                             fname ptr uint8)

  ctrans:translBlock(me'stmts, me'unit, root, block, me'rvoType, fname, \
                      me'pad + 2, false)
/method


method ctrans:Block.whileblock(stmt ptr ast:PNode,
                               root ptr ast:PRoot,
                               fname ptr uint8)

  mut line = stmt'begin'line

  me.padStmts()
  me'stmts.addDebugLine(fname, line)

  me.padStmts()
  me'stmts.addLine("for (;;) {")

  me.incPad()

  mut pexpr = cast<ptr ast:PExpr>(val stmt'leaves.get(0))

  mut cond = me.expr(root, pexpr, fname, line)

  me.padStmts()
  me'stmts.addDebugLine(fname, line)

  me.padStmts()
  me'stmts.add("if(")
  me'stmts.add(cond.value())
  me'stmts.addWord(")")

  mut block = cast<ptr ast:PBlock>(val stmt'leaves.get(1))

  me.subblock(root, block, fname)

  me'stmts.addLine(" else {")

  me.incPad()

  me.padStmts()
  me'stmts.addDebugLine(fname, line)

  me.padStmts()
  me'stmts.addLine("break;")

  me.decPad()

  mut endLine = block'node'end'line

  me.padStmts()
  me'stmts.addDebugLine(fname, endLine)

  me.padStmts()
  me'stmts.addLine("}")

  me.decPad()

  me.padStmts()
  me'stmts.addDebugLine(fname, endLine)

  me.padStmts()
  me'stmts.addLine("}\n")

  cond.wipe()
/method


func translBlock(cs ptr cs:Charstash,
                 unit ptr ctrans:Transl,
                 root ptr ast:PRoot,
                 block ptr ast:PBlock,
                 rvoType ptr ast:Type,
                 fname ptr uint8,
                 p uintptr,
                 horribleRVOHack bool)

  mut origp uintptr = p == 0 => 0 || p - 2

  cs.addLine("{")

  mut bl = blNew(unit, p, rvoType)

  if rvoType? and horribleRVOHack
    bl.newDecl(false, null, "*_rvoOut", fname, rvoType, block'node'begin'line - 1)

    bl.padStmts()
    bl'stmts.addDebugLine(fname, block'node'begin'line - 1)

    bl.padStmts()
    bl'stmts.addLine("_rvoOut = _rvoHack;\n")
  /if


  mut bLen = block'node'leaves.len()
  mut i uintptr = 0

  while i < bLen
    mut stmt = cast<ptr ast:PNode>(val block'node'leaves.get(i))

    bl.statement(root, block, stmt, fname)

    i++
  /while

  bl.dumpInCs(cs)

  cs.addPad(origp)
  cs.addDebugLine(fname, block'node'end'line + 1)

  cs.addPad(origp)
  cs.add("}")
/func
