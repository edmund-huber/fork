#  ctrans, Fork to C transpiler
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2015
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the
#  licenses expressed under Section 1.12 of the MPL v2.


module ctrans


import ast
import ctrans
import cs
import mem
import parser
import proc
import tokens
import tty
import txt
import vect


func isShortcircuitOp(op uint16) bool
  return op == tokens:AND or op == tokens:OR
/func


func freeElem(elem ptr ctrans:Elem)
  if elem?
    elem.wipe()
    mem:free(elem)
  /if
/func


func needsStructCopy(to,from ptr ast:Type) bool
  return to? and from? and from.isStruct() and (not to'name? or not from'name?)
/func


method ctrans:Elem.copy() ptr ctrans:Elem
  mut ret = <ptr ctrans:Elem>(mem:alloc(size(ctrans:Elem)))

  mem:copy(ret, me, size(ctrans:Elem))

  return ret
/method


method ctrans:Elem.value() ptr uint8
  return me'str
/method


method ctrans:Elem.type() ptr ast:Type
  return me'type
/method


method ctrans:Elem.wipe()
  mem:free(me'str)
  me'str = null
/method


func boolelem(v bool, type ptr ast:Type) ctrans:Elem
  return elem(v => "1" || "0", type)
/func


func deref(elem ctrans:Elem, ptrType ptr ast:Type) ctrans:Elem
  mut ret ctrans:Elem
  mut cs = cs:new(20)

  cs.add("(*")
  cs.add(elem.value())
  cs.add(")")

  ret'str = cs:unwrap(cs)
  ret'type = ptrType'retType

  return ret
/func


func elem(name ptr uint8, type ptr ast:Type) ctrans:Elem
  mut ret ctrans:Elem

  ret'str = txt:strclone(name)
  ret'type = type

  return ret
/func


func intelem(n uintptr, type ptr ast:Type) ctrans:Elem
  mut ret ctrans:Elem

  ret'str = <ptr uint8>(mem:zalloc(21))
  txt:numtostr(n, ret'str, 20)
  ret'type = type

  return ret
/func


func methelem(name ptr uint8, type ptr ast:Type) ctrans:Elem

  if type.isPtr()
    type = type'retType
  /if

  mut cs = cs:new(20)

  if type.isPtr()
    type = type'retType
  /if

  mut typeName = ctrans:symMod(type'moduleName, type'name)

  cs.addMethSym(typeName, name)

  mem:free(typeName)

  mut ret ctrans:Elem

  ret'str = cs:unwrap(cs)
  ret'type = type

  return ret
/func


func modelem(modName,name ptr uint8, type ptr ast:Type) ctrans:Elem
  mut ret ctrans:Elem
  mut modLen = txt:strlen(modName)
  mut nameLen = txt:strlen(name)

  ret'str = <ptr uint8>(mem:zalloc(modLen + nameLen + 2))

  mem:copy(ret'str, modName, modLen)
  ret'str[modLen] = val "$"
  mem:copy(ret'str + modLen + 1, name, nameLen)

  ret'type = type

  return ret
/func


func refhack(el ctrans:Elem, origType ptr ast:Type) ptr uint8
  mut isToFn = origType.isFunc()

  mut cs = cs:new(20)

  if isToFn
    cs.add("(")
  /if

  cs.add("*")
  cs.add(el.value())

  if isToFn
    cs.add(")")
  /if

  return cs:unwrap(cs)
/func


func sizeelem(opType,aType ptr ast:Type) ctrans:Elem
  return intelem(opType'typeSize, aType)
/func


func structelem(left,field ptr uint8, leftType,fieldType ptr ast:Type) ctrans:Elem
  mut ret ctrans:Elem
  mut accOp = (leftType? and leftType'type == ast:TYPE_PTR) => "->" || "."
  mut leftLen = txt:strlen(left)
  mut accLen = txt:strlen(accOp)
  mut fieldLen = txt:strlen(field)

  ret'str = <ptr uint8>(mem:zalloc(leftLen + fieldLen + accLen + 1))

  mem:copy(ret'str, left, leftLen)
  mem:copy(ret'str + leftLen, accOp, accLen)
  mem:copy(ret'str + leftLen + accLen, field, fieldLen)

  ret'type = fieldType

  return ret
/func


method ctrans:Block.access(from,index ctrans:Elem,
                           fromType ptr ast:Type,
                           fname ptr uint8,
                           line uintptr) ctrans:Elem

  mut rightPtr = me.binop(tokens:PLUS, fromType, from, index, fname, line)

  mut ret = deref(rightPtr, fromType)

  rightPtr.wipe()

  return ret
/method


method ctrans:Block.assign(to,from ctrans:Elem, fname ptr uint8, line uintptr)

  if needsStructCopy(to'type, from'type)
    me.assignAnonStruct(to, from, fname, line)
  else
    me.padStmts()
    me'stmts.addDebugLine(fname, line)

    me.padStmts()
    me'stmts.addWord(to.value())
    me'stmts.addWord("=")
    me'stmts.add(from.value())
    me'stmts.addLine(";")
  /if
/method


method ctrans:Block.assignAnonStruct(to,from ctrans:Elem,
                                     fname ptr uint8,
                                     line uintptr)

  mut toMembers = to'type'members
  mut fromMembers = from'type'members

  mut len = toMembers.len()
  mut i uintptr = 0

  while i < len
    mut toPair = toMembers.getAt(i)
    mut fromPair = fromMembers.getAt(i)

    mut toName = <ptr uint8>(toPair'key)
    mut fromName = <ptr uint8>(fromPair'key)

    mut toType = <ptr ast:Type>(toPair'value)
    mut fromType = <ptr ast:Type>(fromPair'value)

    mut toMem = structelem(to.value(), toName, to'type, toType)
    mut fromMem = structelem(from.value(), fromName, from'type, fromType)

    me.assign(toMem, fromMem, fname, line)

    toMem.wipe()
    fromMem.wipe()

    i++
  /while
/method


method ctrans:Block.binop(op uint16,
                          destType ptr ast:Type,
                          op1,op2 ctrans:Elem,
                          fname ptr uint8,
                          line uintptr) ctrans:Elem

  if op == tokens:POW
    return me.pow(op1, op2, destType, fname, line)
  /if

  mut ret = me.nextvar(destType, fname, line)

  me.padStmts()
  me'stmts.addDebugLine(fname, line)

  me.padStmts()
  me'stmts.addWord(ret.value())
  me'stmts.addWord("=")
  me'stmts.addWord(op1.value())
  me'stmts.addWord(ctrans:opConv(op))
  me'stmts.add(op2.value())
  me'stmts.addLine(";")

  return ret
/method


method ctrans:Block.castexpr(expr ctrans:Elem,
                             castType ptr ast:Type,
                             fname ptr uint8,
                             line uintptr) ctrans:Elem

  mut ret = me.nextvar(castType, fname, line)

  me.padStmts()
  me'stmts.addDebugLine(fname, line)

  me.padStmts()

  me'stmts.addWord(ret.value())
  me'stmts.addWord("=")

  me'stmts.add("(")
  me'unit.wrapType(me'stmts, castType, -1)
  me'stmts.add(") ")

  me'stmts.add(expr.value())
  me'stmts.addLine(";")

  return ret
/method


method ctrans:Block.dec(op ctrans:Elem,
                        fname ptr uint8,
                        line uintptr)

  me.padStmts()
  me'stmts.addDebugLine(fname, line)

  me.padStmts()
  me'stmts.add("--")
  me'stmts.add(op.value())
  me'stmts.addLine(";")
/method


method ctrans:Block.fncall(name ptr uint8,
                           retval ptr ctrans:Elem,
                           rettype ptr ast:Type,
                           params ptr vect:Vect,
                           fname ptr uint8,
                           line uintptr )

  me.padStmts()
  me'stmts.addDebugLine(fname, line)

  me.padStmts()

  if retval?
    me'stmts.addWord(retval.value())
    me'stmts.addWord("=")
  /if

  me'stmts.add(name)
  me'stmts.add("(")

  mut i uintptr = 0
  mut len = params.len()

  while i < len
    if i > 0
      me'stmts.addWord(",")
    /if

    mut param = <ptr ctrans:Elem>(val params.get(i))

    me'stmts.add(param.value())

    freeElem(param)

    i++
  /while

  me'stmts.addLine(");")

/method


method ctrans:Block.inc(op ctrans:Elem,
                        fname ptr uint8,
                        line uintptr)

  me.padStmts()
  me'stmts.addDebugLine(fname, line)

  me.padStmts()
  me'stmts.add("++")
  me'stmts.add(op.value())
  me'stmts.addLine(";")
/method


method ctrans:Block.label(lb ctrans:Elem, empty bool)
  me'stmts.add(lb.value())
  me'stmts.add(":")

  me'stmts.addLine(empty => " ;" || "")
/method


method Block.mulassign(to ptr ctrans:Elem,
                       from ctrans:Elem,
                       fname ptr uint8,
                       line uintptr)

  mut type = from'type
  mut i uintptr = 0
  mut len = type'members.len()
  mut fromName = from.value()

  while i < len
    mut member = type'members.getAt(i)
    mut memName = <ptr uint8>(member'key)
    mut memType = <ptr ast:Type>(member'value)

    mut structElem = structelem(fromName, memName, type, memType)

    me.assign(val to, structElem, fname, line)

    structElem.wipe()
    i++
    to++
  /while
/method


method ctrans:Block.nextlabel() ctrans:Elem
  mut ret ctrans:Elem

  ret'str = <ptr uint8>(mem:zalloc(22))
  ret'str[0] = "_"[0]

  txt:numtostr(me'unit'cnt, ptr ret'str[1], 255)

  me'unit'cnt++

  ret'type = null

  return ret
/method


method ctrans:Block.nextvar(type ptr ast:Type,
                            fname ptr uint8,
                            line uintptr) ctrans:Elem

  mut ret = me.ssavar(type)

  if type.isLoc()
    mut hackStr = refhack(ret, type'retType)

    me.newDecl(false, hackStr, fname, type'retType, line)

    mem:free(hackStr)
  else
    me.newDecl(false, ret.value(), fname, type, line)
  /if

  return ret
/method


method ctrans:Block.pow(base,exp ctrans:Elem,
                        type ptr ast:Type,
                        fname ptr uint8,
                        line uintptr) ctrans:Elem

  mut ret = me.nextvar(type, fname, line)

  me.padStmts()
  me'stmts.addDebugLine(fname, line)

  me.padStmts()
  me'stmts.addWord(ret.value())
  me'stmts.addWord("=")
  me'stmts.add("math$__forkpow(")
  me'stmts.add(base.value())
  me'stmts.add(", ")
  me'stmts.add(exp.value())
  me'stmts.add(")")
  me'stmts.addLine(";")

  return ret
/method


method ctrans:Block.quest(elem ctrans:Elem,
                          type ptr ast:Type,
                          fname ptr uint8,
                          line uintptr) ctrans:Elem

  me.padStmts()
  me'stmts.addDebugLine(fname, line)

  mut ret = me.nextvar(type, fname, line)

  me.padStmts()
  me'stmts.addWord(ret.value())
  me'stmts.addWord("=")
  me'stmts.add(elem.value())
  me'stmts.addLine(" != (void*) 0;")

  return ret
/method


method ctrans:Block.ref(elem ctrans:Elem,
                        origType ptr ast:Type,
                        fname ptr uint8,
                        line uintptr) ctrans:Elem

  mut ret = me.ssavar(null)
  mut hackStr = refhack(ret, origType)

  me.newDecl(false, hackStr, fname, origType, line)

  mem:free(hackStr)

  me.padStmts()
  me'stmts.addDebugLine(fname, line)

  me.padStmts()
  me'stmts.addWord(ret.value())
  me'stmts.add("= &")
  me'stmts.add(elem.value())
  me'stmts.addLine(";")

  return ret
/method


method ctrans:Block.ssavar(type ptr ast:Type) ctrans:Elem
  mut ret ctrans:Elem

  ret'str = <ptr uint8>(mem:zalloc(22))
  ret'str[0] = "_"[0]

  txt:numtostr(me'unit'cnt, ptr ret'str[1], 21)

  me'unit'cnt++

  ret'type = type

  return ret
/method


method ctrans:Block.str(value ptr uint8,
                        destType ptr ast:Type,
                        fname ptr uint8,
                        line uintptr) ctrans:Elem

  mut ret = me.nextvar(destType, fname, line)

  me.padStmts()
  me'stmts.addDebugLine(fname, line)

  me.padStmts()
  me'stmts.addWord(ret.value())
  me'stmts.addWord("=")
  me'stmts.addCStr(value)
  me'stmts.addLine(";")

  return ret
/method


method ctrans:Block.structaccess(root ptr ast:PRoot,
                                 e1,e2 ptr ast:PExpr,
                                 type ptr ast:Type,
                                 fname ptr uint8,
                                 line uintptr) ctrans:Elem

  mut s = me.expr(e1, root, fname, line)


  mut ret = structelem(s.value(), <ptr uint8>(e2'node'value), e1'type, type)

  s.wipe()

  return ret
/method


method ctrans:Block.unop(op uint16,
                         destType ptr ast:Type,
                         op1 ctrans:Elem,
                         fname ptr uint8,
                         line uintptr) ctrans:Elem

  mut ret = me.nextvar(destType, fname, line)

  me.padStmts()
  me'stmts.addDebugLine(fname, line)

  me.padStmts()
  me'stmts.addWord(ret.value())
  me'stmts.addWord("=")
  me'stmts.add(ctrans:opConv(op))
  me'stmts.addWord(op1.value())
  me'stmts.addLine(";")

  return ret
/method


method ctrans:Block.varcopy(to,from ctrans:Elem,
                            deref bool,
                            fname ptr uint8,
                            line uintptr)

  me.padStmts()
  me'stmts.addDebugLine(fname, line)

  me.padStmts()

  if deref
    me'stmts.add("*")
  /if

  me'stmts.addWord(to.value())
  me'stmts.addWord("=")
  me'stmts.addWord(from.value())
  me'stmts.addLine(";")
/method


method Block.muldecl(pmuldecl ptr ast:PMulDecl,
                     root ptr ast:PRoot,
                     fname ptr uint8)

  mut pnode = <ptr ast:PNode>(pmuldecl)

  if pnode'leaves.len() > 0
    mut expr = <ptr ast:PExpr>(val pnode'leaves.get(0))
    mut exprEl = me.expr(expr, root, fname, pnode'begin'line)

    mut len = pmuldecl'syms.len()
    mut i uintptr = 0

    # Old style C array, way easier this way
    mut elems = <ptr ctrans:Elem>(mem:zalloc(len * size(ctrans:Elem)))

    while i < len
      mut sym = <ptr ast:PSymbol>(val pmuldecl'syms.get(i))
      mut type = pnode.findSym(sym'name)

      elems[i] = elem(sym'name, type)

      i++
    /while

    me.mulassign(elems, exprEl, fname, pnode'begin'line)

    i = 0
    while i < len
      elems[i].wipe()
      i++
    /while

    exprEl.wipe()
    mem:free(elems)
  /if
/method


method ctrans:Block.declaration(pdecl ptr ast:PDecl,
                                root ptr ast:PRoot,
                                fname ptr uint8)

  mut pnode = <ptr ast:PNode>(pdecl)

  if pnode'leaves.len() > 0
    mut name = pdecl'sym'name
    mut type = pnode.findSym(name)

    mut id = elem(name, type)

    mut expr = <ptr ast:PExpr>(val pnode'leaves.get(0))
    mut exprEl = me.expr(expr, root, fname, pnode'begin'line)

    me.assign(id, exprEl, fname, pnode'begin'line)

    exprEl.wipe()
    id.wipe()
  /if
/method


method ctrans:Block.handleAnd(root ptr ast:PRoot,
                              type ptr ast:Type,
                              e1,e2 ptr ast:PExpr,
                              fname ptr uint8,
                              line uintptr) ctrans:Elem

  mut ret = me.nextvar(type, fname, line)

  mut el1 = me.expr(e1, root, fname, line)

  me.padStmts()
  me'stmts.addDebugLine(fname, line)

  me.padStmts()
  me'stmts.add("if (!")
  me'stmts.add(el1.value())
  me'stmts.add(") goto ")

  mut fail = me.nextlabel()

  me'stmts.add(fail.value())
  me'stmts.addLine(";")

  mut el2 = me.expr(e2, root, fname, line)

  me.assign(ret, el2, fname, line)

  me.padStmts()
  me'stmts.addDebugLine(fname, line)

  me.padStmts()
  me'stmts.addWord("goto")

  mut goOut = me.nextlabel()
  me'stmts.add(goOut.value())
  me'stmts.addLine(";")

  me.label(fail, false)

  me.padStmts()
  me'stmts.addDebugLine(fname, line)

  me.padStmts()
  me'stmts.addWord(ret.value())
  me'stmts.addWord("=")
  me'stmts.addLine("0;")

  me.label(goOut, true)

  fail.wipe()
  goOut.wipe()

  return ret
/method


method ctrans:Block.handleDQuest(root ptr ast:PRoot,
                                 c1,c2 ptr ast:PExpr,
                                 type ptr ast:Type,
                                 fname ptr uint8,
                                 line uintptr) ctrans:Elem

  mut el1 = me.expr(c1, root, fname, line)
  mut ret = me.nextvar(type, fname, line)

  me.padStmts()
  me'stmts.addDebugLine(fname, line)

  me.padStmts()
  me'stmts.add("if (")
  me'stmts.add(el1.value())
  me'stmts.addLine(" != (void*) 0) {")

  # increase - temporarely - padding
  me'pad = me'pad + 2

  me.assign(ret, el1, fname, line)

  el1.wipe()

  me'pad = me'pad - 2

  me.padStmts()
  me'stmts.addLine("} else {")

  # increase - temporarely - padding
  me'pad = me'pad + 2

  mut el2 = me.expr(c2, root, fname, line)

  me.assign(ret, el2, fname, line)

  el2.wipe()

  me'pad = me'pad - 2

  me.padStmts()
  me'stmts.addLine("}\n")

  return ret
/method


method ctrans:Block.handleFn(root ptr ast:PRoot,
                             pexpr ptr ast:PExpr,
                             fname ptr uint8,
                             line uintptr) ctrans:Elem


  mut toCall = <ptr ast:PExpr>(val pexpr'node'leaves.get(0))
  mut methCall = toCall'opType == tokens:DOT

  mut len = pexpr'node'leaves.len()

  # n params + me + rvo (eventally)
  mut params = vect:new(len + 1)

  mut callElem ctrans:Elem

  if methCall
    mut target = <ptr ast:PExpr>(val toCall'node'leaves.get(0))
    mut meth = <ptr ast:PExpr>(val toCall'node'leaves.get(1))
    mut targetType = target'type

    callElem = methelem(<ptr uint8>(meth'node'value), targetType)

    # add me parameter

    mut notPtr = not targetType.isPtr()
    mut meElem = me.expr(target, root, fname, line)

    if notPtr
      mut ptrElem = me.ref(meElem, target'type, fname, line)
      meElem.wipe()

      meElem = ptrElem
    /if

    params.append(meElem.copy())
  else
    callElem = me.expr(toCall, root, fname, line)
  /if


  mut rvo = pexpr'type.isStruct() or pexpr'type'type == ast:TYPE_RECALIAS
  mut ret ctrans:Elem

  mem:set(ptr ret, 0, size(ctrans:Elem))

  # RVO
  if rvo
    ret = me.nextvar(pexpr'type, fname, line)
    mut rvoRet = me.ref(ret, pexpr'type, fname, line)
    params.append(rvoRet.copy())
  /if

  mut memTypes = toCall'type.isPtr() \
                  => toCall'type'retType'members \
                  || toCall'type'members

  mut i uintptr = 1

  while i < len
    mut type = <ptr ast:Type>(memTypes.getAt(i - 1)'value)
    mut param = <ptr ast:PExpr>(val pexpr'node'leaves.get(i))

    mut paramExpr = me.exprWithOptimizedType(param, root, type, fname, line)
    params.append(paramExpr.copy())

    i++
  /while

  mut wantsRet = not rvo and (pexpr'type? and pexpr'type'type != ast:TYPE_EMPTY)

  if wantsRet
    ret = me.nextvar(pexpr'type, fname, line)
  /if

  me.fncall(callElem.value(), wantsRet => ptr ret || null, pexpr'type, params, fname, line)

  callElem.wipe()

  return ret
/method


method ctrans:Block.handleMulAssign(exprs ptr ast:PExpr,
                                    from ctrans:Elem,
                                    root ptr ast:PRoot,
                                    fname ptr uint8,
                                    line uintptr)

  mut pnode = <ptr ast:PNode>(exprs)

  mut len = pnode'leaves.len()
  mut i uintptr = 0

  mut elems = <ptr ctrans:Elem>(mem:zalloc(len * size(ctrans:Elem)))

  while i < len
    mut member = <ptr ast:PExpr>(val pnode'leaves.get(i))

    elems[i] = me.expr(member, root, fname, line)

    i++
  /while

  me.mulassign(elems, from, fname, pnode'begin'line)

  i = 0
  while i < len
    elems[i].wipe()
    i++
  /while

/method


method ctrans:Block.handleOr(root ptr ast:PRoot,
                             type ptr ast:Type,
                             e1,e2 ptr ast:PExpr,
                             fname ptr uint8,
                             line uintptr) ctrans:Elem

  mut ret = me.nextvar(type, fname, line)

  mut el1 = me.expr(e1, root, fname, line)

  me.padStmts()
  me'stmts.addDebugLine(fname, line)

  me.padStmts()
  me'stmts.add("if (")
  me'stmts.add(el1.value())
  me'stmts.add(") goto ")

  mut succ = me.nextlabel()

  me'stmts.add(succ.value())
  me'stmts.addLine(";")

  mut el2 = me.expr(e2, root, fname, line)

  me.assign(ret, el2, fname, line)

  me.padStmts()
  me'stmts.addDebugLine(fname, line)

  me.padStmts()
  me'stmts.addWord("goto")

  mut goOut = me.nextlabel()
  me'stmts.add(goOut.value())
  me'stmts.addLine(";")

  me.label(succ, false)

  me.padStmts()
  me'stmts.addDebugLine(fname, line)

  me.padStmts()
  me'stmts.addWord(ret.value())
  me'stmts.addWord("=")
  me'stmts.addLine("1;")

  me.label(goOut, true)

  succ.wipe()
  goOut.wipe()

  return ret
/method


method ctrans:Block.handleShortcircuit(root ptr ast:PRoot,
                                       op uint16,
                                       type ptr ast:Type,
                                       e1,e2 ptr ast:PExpr,
                                       fname ptr uint8,
                                       line uintptr) ctrans:Elem

  if op == tokens:AND
    return me.handleAnd(root, type, e1, e2, fname, line)
  /if

  return me.handleOr(root, type, e1, e2, fname, line)
/method


method ctrans:Block.handleStructLiteral(root ptr ast:PRoot,
                                        lit ptr ast:PExpr,
                                        type ptr ast:Type,
                                        fname ptr uint8,
                                        line uintptr) ctrans:Elem

  type = type ?? lit'type

  mut ret = me.nextvar(type, fname, line)
  mut members = type'members

  mut len = lit'node'leaves.len()
  mut i uintptr = 0

  while i < len
    mut param = <ptr ast:PExpr>(val lit'node'leaves.get(i))
    mut paramExpr = me.expr(param, root, fname, line)
    mut memberName = <ptr uint8>(members.getAt(i)'key)

    mut member = structelem(ret.value(), memberName, type, param'type)

    me.assign(member, paramExpr, fname, line)

    member.wipe()
    i++
  /while

  return ret
/method


method ctrans:Block.handleTern(root ptr ast:PRoot,
                               condEx,c1,c2 ptr ast:PExpr,
                               type ptr ast:Type,
                               fname ptr uint8,
                               line uintptr) ctrans:Elem

  mut cond = me.expr(condEx, root, fname, line)
  mut ret = me.nextvar(type, fname, line)

  me.padStmts()
  me'stmts.addDebugLine(fname, line)

  me.padStmts()
  me'stmts.add("if (")
  me'stmts.add(cond.value())
  me'stmts.addLine(") {")

  cond.wipe()

  # increase - temporarely - padding
  me.incPad()

  mut el1 = me.expr(c1, root, fname, line)

  me.assign(ret, el1, fname, line)

  el1.wipe()

  me.decPad()

  me.padStmts()
  me'stmts.addDebugLine(fname, line)

  me.padStmts()
  me'stmts.addLine("} else {")

  # increase - temporarely - padding
  me.incPad()

  mut el2 = me.expr(c2, root, fname, line)

  me.assign(ret, el2, fname, line)

  el2.wipe()

  me.decPad()

  me.padStmts()
  me'stmts.addDebugLine(fname, line)

  me.padStmts()
  me'stmts.addLine("}\n")

  return ret
/method


method ctrans:Block.exprWithOptimizedType(pexpr ptr ast:PExpr,
                                          root ptr ast:PRoot,
                                          destType ptr ast:Type,
                                          fname ptr uint8,
                                          line uintptr) ctrans:Elem

  mut value = pexpr'node'value

  if pexpr'opType == tokens:ASSIGN
    mut to ctrans:Elem = {null, null} # ensure segfault if used
    mut e1 = <ptr ast:PExpr>(val pexpr'node'leaves.get(0))
    mut e2 = <ptr ast:PExpr>(val pexpr'node'leaves.get(1))

    mut from = me.expr(e2, root, fname, line)

    if e1'opType == tokens:OCURLY
      me.handleMulAssign(e1, from, root, fname, line)
    else
      to = me.expr(e1, root, fname, line)

      me.assign(to, from, fname, line)
    /if

    from.wipe()
    return to
  /if

  if pexpr'opType == tokens:NUMBER
    return intelem(value, pexpr'type)
  /if

  if pexpr'opType == tokens:STRING
    return me.str(<ptr uint8>(value), pexpr'type, fname, line)
  /if

  if pexpr'opType == tokens:ID

    mut name = <ptr uint8>(value)
    mut modName ptr uint8 = root'moduleName? => root'moduleName'name || null
    mut fDecl = root'node'syms.get(name)

    if     fDecl? \
       and modName? \
       and not fDecl'declOnly \
       and <ptr ast:PNode>(pexpr).findSym(name) == fDecl'type

      return modelem(modName, name, pexpr'type)
    else
      return elem(name, pexpr'type)
    /if
  /if

  if pexpr'opType == tokens:ME
    return elem("me", pexpr'type)
  /if

  if pexpr'opType == tokens:NULL
    return elem("(void*) 0", pexpr'type)
  /if

  if pexpr'opType == tokens:TRUE or pexpr'opType == tokens:FALSE
    return boolelem(pexpr'opType == tokens:TRUE, pexpr'type)
  /if

  if pexpr'opType == tokens:COLON
    mut modName = <ptr uint8>(<ptr ast:PNode>(val pexpr'node'leaves.get(0))'value)
    mut name = <ptr uint8>(<ptr ast:PNode>(val pexpr'node'leaves.get(1))'value)

    return modelem(modName, name, pexpr'type)
  /if

  if pexpr'opType == tokens:APOS
    mut e1 = <ptr ast:PExpr>(val pexpr'node'leaves.get(0))
    mut e2 = <ptr ast:PExpr>(val pexpr'node'leaves.get(1))

    return me.structaccess(root, e1, e2, pexpr'type, fname, line)
  /if

  if pexpr'opType == tokens:SIZE
    return sizeelem(pexpr'sizeType, pexpr'type)
  /if

  if pexpr'opType == tokens:CAST
    mut tocast = <ptr ast:PExpr>(val pexpr'node'leaves.get(0))
    mut expr = me.expr(tocast, root, fname, line)

    mut ret = me.castexpr(expr, pexpr'type, fname, line)

    expr.wipe()

    return ret
  /if

  if pexpr'opType == tokens:OPAR
    return me.handleFn(root, pexpr, fname, line)
  /if

  if pexpr'opType == tokens:OBRAC
    mut e1 = <ptr ast:PExpr>(val pexpr'node'leaves.get(0))
    mut e2 = <ptr ast:PExpr>(val pexpr'node'leaves.get(1))

    mut from = me.expr(e1, root, fname, line)
    mut index = me.expr(e2, root, fname, line)

    mut ret = me.access(from, index, e1'type, fname, line)

    from.wipe()
    index.wipe()

    return ret
  /if

  if pexpr'opType == tokens:OCURLY
    return me.handleStructLiteral(root, pexpr, destType, fname, line)
  /if

  if pexpr'opType == tokens:DQUEST
    mut e1 = <ptr ast:PExpr>(val pexpr'node'leaves.get(0))
    mut e2 = <ptr ast:PExpr>(val pexpr'node'leaves.get(1))

    return me.handleDQuest(root, e1, e2, pexpr'type, fname, line)
  /if

  if pexpr'opType == tokens:FATARROW
    mut e1 = <ptr ast:PExpr>(val pexpr'node'leaves.get(0))
    mut e2 = <ptr ast:PExpr>(val pexpr'node'leaves.get(1))
    mut e3 = <ptr ast:PExpr>(val pexpr'node'leaves.get(2))

    return me.handleTern(root, e1, e2, e3, pexpr'type, fname, line)
  /if

  if pexpr'opType == tokens:DEC
    mut e = <ptr ast:PExpr>(val pexpr'node'leaves.get(0))

    mut el = me.expr(e, root, fname, line)

    me.dec(el, fname, line)

    return el
  /if

  if pexpr'opType == tokens:INC
    mut e = <ptr ast:PExpr>(val pexpr'node'leaves.get(0))

    mut el = me.expr(e, root, fname, line)

    me.inc(el, fname, line)

    return el
  /if

  if pexpr'opType == tokens:QUEST
    mut e = <ptr ast:PExpr>(val pexpr'node'leaves.get(0))

    mut el = me.expr(e, root, fname, line)

    mut ret = me.quest(el, pexpr'type, fname, line)

    el.wipe()

    return ret
  /if

  if pexpr'opType == tokens:PTR
    mut e = <ptr ast:PExpr>(val pexpr'node'leaves.get(0))

    mut el = me.expr(e, root, fname, line)

    mut ret = me.ref(el, e'type, fname, line)

    el.wipe()

    return ret
  /if

  if pexpr'opType == tokens:VAL
    mut e = <ptr ast:PExpr>(val pexpr'node'leaves.get(0))

    mut el = me.expr(e, root, fname, line)

    mut ret = deref(el, e'type)

    el.wipe()

    return ret
  /if

  if ctrans:isBinOp(pexpr'opType) or pexpr'opType == tokens:MINUS
    mut e1 = <ptr ast:PExpr>(val pexpr'node'leaves.get(0))
    mut e2 = <ptr ast:PExpr>(val pexpr'node'leaves.get(1))

    if isShortcircuitOp(pexpr'opType)
      return me.handleShortcircuit(root, pexpr'opType, pexpr'type, e1, e2, fname, line)
    /if

    mut el1 = me.expr(e1, root, fname, line)
    mut el2 = me.expr(e2, root, fname, line)

    mut ret = me.binop(pexpr'opType, pexpr'type, el1, el2, fname, line)

    el1.wipe()
    el2.wipe()

    return ret
  /if

  #assume prefix unary now

  mut e = <ptr ast:PExpr>(val pexpr'node'leaves.get(0))
  mut el = me.expr(e, root, fname, line)

  mut ret = me.unop(pexpr'opType, pexpr'type, el, fname, line)

  el.wipe()

  return ret
/method


method ctrans:Block.expr(pexpr ptr ast:PExpr,
                         root ptr ast:PRoot,
                         fname ptr uint8,
                         line uintptr) ctrans:Elem

  return me.exprWithOptimizedType(pexpr, root, null, fname, line)
/method
