#  libfork, a base library for the Fork language
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2015
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the
#  licenses expressed under Section 1.12 of the MPL v2.


module ast


import ast
import astfn
import cs
import hash
import lex
import list
import mem
import txt
import utils


func methodKey(typeModule,typeName,methodName ptr uint8) ptr uint8
  mut cs = cs:new(10)

  if typeModule?
    cs.add(typeModule)
    cs.add(":")
  /if

  cs.add(typeName)

  cs.add(".")

  cs.add(methodName)

  return cs:unwrap(cs)
/func


func declKey(pdecl ptr ast:PDecl) ptr uint8
  mut isMet =  pdecl'node'type == ast:PMETHOD

  if not isMet
    return txt:strclone(pdecl'sym'name)
  /if

  return ast:methodKey(pdecl'methodTypeModule, pdecl'methodType, pdecl'sym'name)
/func


method ast:PNode.findPBlock() ptr ast:PNode
  if me.isBlock()
    return me
  /if

  if me'parent?
    return me'parent.findPBlock()
  /if

  return null
/method


method ast:PNode.findPRoot() ptr ast:PRoot
  if me.isRoot()
    return <ptr ast:PRoot>(me)
  /if

  if me'parent?
    return me'parent.findPRoot()
  /if

  return null
/method


method ast:PNode.findStab() ptr ast:Symtable
  mut pblock = me.findPBlock()

  return pblock? => <ptr ast:PBlock>(pblock)'syms || null
/method


method ast:PNode.findSym(name ptr uint8) ptr ast:Type
  mut pblock = me.findPBlock()

  if pblock?
    mut stab = pblock.findStab()
    mut type = stab.typeof(name)

    return type ?? (pblock'parent? => pblock'parent.findSym(name) || null)
  /if

  return null
/method


method ast:PNode.findSymLocal(name ptr uint8) ptr ast:Type
  mut stab = me.findStab()

  return stab.typeof(name)
/method


method ast:PNode.isBlock() bool
  return me'type == ast:PBLOCK or me.isRoot()
/method


method ast:PNode.isBreakContinue() bool
  return me'type == ast:PBREAK or me'type == ast:PCONTINUE
/method


method ast:PNode.isDecl() bool
  return me'type == ast:PALIAS or me'type == ast:PMUT or me'type == ast:PENTRY or me'type == ast:PFUNCTION or me'type == ast:PMETHOD
/method


method ast:PNode.isExpr() bool
  return me'type == ast:PEXPR
/method


method ast:PNode.isIf() bool
  return me'type == ast:PIF or me'type == ast:PIFELSE
/method


method ast:PNode.isMulDecl() bool
  return me'type == ast:PMUTEXP
/method


method ast:PNode.isMutOrDecl() bool
  return me'type == ast:PMUT or (me.isDecl() and <ptr ast:PDecl>(me)'isDecl)
/method


method ast:PNode.isReturn() bool
  return me'type == ast:PRETURN
/method


method ast:PNode.isRoot() bool
  return me'type == ast:PROOT
/method


method ast:PNode.isWhile() bool
  return me'type == ast:PWHILE
/method


method ast:PRoot.hasImported(name ptr uint8) bool
  mut i uintptr = 0
  mut len = me'imports.len()

  while i < len
    mut elem = <ptr ast:StringDef>(val me'imports.get(i))

    if txt:strequals(elem'name, name)
      return true
    /if

    i++
  /while

  return false
/method


func pnodeFree(pnode ptr ast:PNode)
  if pnode?
    if pnode.isRoot()

      mut proot = <ptr ast:PRoot>(pnode)
      astfn:strdefFree(proot'moduleName)
      mem:free(proot'fileName)
      list:freeAll(proot'imports, <ptr func(inst data)>(ptr astfn:strdefFree))
      ast:stabFree(proot'aliases)

      mem:fpFree(proot'typePool)
    /if

    if pnode.isDecl()

      mut pdecl = <ptr ast:PDecl>(pnode)
      mem:decRef(pdecl'sym)

      mem:free(pdecl'methodTypeModule)
      mem:free(pdecl'methodType)

    /if

    if pnode.isBlock()
      ast:stabFree(<ptr ast:PBlock>(pnode)'syms)
    /if

    # remember to fix PBLOCK leaks.

    # remember to fix PEXPR leaks.

    list:freeAll(pnode'leaves, ptr pnodeFree)

    mem:free(pnode)
  /if
/func


mut PROOT      uint16 = 10
mut PENTRY     uint16 = 20
mut PFUNCTION  uint16 = 30
mut PALIAS     uint16 = 40
mut PMUT       uint16 = 60
mut PMUTEXP    uint16 = 65
mut PIF        uint16 = 70
mut PEXPR      uint16 = 80
mut PBREAK     uint16 = 90
mut PCONTINUE  uint16 = 100
mut PRETURN    uint16 = 110
mut PIFELSE    uint16 = 120
mut PWHILE     uint16 = 130
mut PBLOCK     uint16 = 140
mut PMETHOD    uint16 = 150
