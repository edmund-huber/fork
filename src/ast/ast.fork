#  libfork, a base library for the Fork language
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2015
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the
#  licenses expressed under Section 1.12 of the MPL v2.


module ast


import ast
import astfn
import lex
import list
import mem
import txt
import utils


func findPBlock(node ptr ast:PNode) ptr ast:PNode
  if node == null
    return null
  /if

  if !ast:isPBlock(node)
    return findPBlock(node'parent)
  /if

  return node
/func


func findStab(node ptr ast:PNode) ptr ast:Symtable
  mut pblock = ast:findPBlock(node)

  return pblock != null => cast<ptr ast:PBlock>(pblock)'syms || null
/func


func findSymLocal(node ptr ast:PNode, name ptr uint8) ptr ast:Type
  mut stab = findStab(node)

  return ast:stabTypeof(stab, name)
/func


func findSym(node ptr ast:PNode, name ptr uint8) ptr ast:Type
  mut pblock = ast:findPBlock(node)

  if pblock != null
    mut stab = findStab(pblock)
    mut type = ast:stabTypeof(stab, name)

    return type != null => type || findSym(pblock'parent, name)
  /if

  return null
/func


func pnodeFree(pnode ptr ast:PNode)
  if pnode != null
    if ast:isPRoot(pnode)

      mut proot = cast<ptr ast:PRoot>(pnode)
      astfn:strdefFree(proot'moduleName)
      mem:free(proot'fileName)
      list:listFreeAll(proot'imports, cast<ptr func(inst data)>(ptr astfn:strdefFree))
      ast:stabFree(proot'aliases)
      ast:stabFree(proot'methods)

      mem:fpFree(proot'typePool)
    /if

    if ast:isPDecl(pnode)

      mut pdecl = cast<ptr ast:PDecl>(pnode)
      mem:decRef(pdecl'sym)

      mem:free(pdecl'methodTypeModule)
      mem:free(pdecl'methodType)

    /if

    if ast:isPBlock(pnode)
      ast:stabFree(cast<ptr ast:PBlock>(pnode)'syms)
    /if

    # remember to fix PBLOCK leaks.

    # remember to fix PEXPR leaks.

    list:listFreeAll(pnode'leaves, ptr pnodeFree)

    mem:free(pnode)
  /if
/func


func pnodeIsBreakContinue(pnode ptr ast:PNode) bool
  return pnode'type == ast:PBREAK or pnode'type == ast:PCONTINUE
/func


func pnodeIsDecl(pnode ptr ast:PNode) bool
  return pnode'type == ast:PDECL or pnode'type == ast:PMUT
/func


func pnodeIsExpr(pnode ptr ast:PNode) bool
  return pnode'type == ast:PEXPR
/func


func pnodeIsIf(pnode ptr ast:PNode) bool
  return pnode'type == ast:PIF or pnode'type == ast:PIFELSE
/func


func pnodeIsReturn(pnode ptr ast:PNode) bool
  return pnode'type == ast:PRETURN
/func


func pnodeIsWhile(pnode ptr ast:PNode) bool
  return pnode'type == ast:PWHILE
/func


func prootHasImported(root ptr ast:PRoot, name ptr uint8) bool
  mut i uintptr = 0
  mut len = list:listLen(root'imports)

  while i < len
    mut elem = cast<ptr ast:StringDef>(val list:listGet(root'imports, i))

    if txt:strequals(elem'name, name)
      return true
    /if

    i++
  /while

  return false
/func


func isPDecl(pnode ptr ast:PNode) bool
  return pnode != null and pnode'type == ast:PALIAS or pnode'type == ast:PDECL or pnode'type == ast:PMUT or pnode'type == ast:PENTRY or pnode'type == ast:PFUNCTION or pnode'type == ast:PMETHOD
/func


func isPBlock(pnode ptr ast:PNode) bool
  return pnode != null and (pnode'type == ast:PBLOCK or ast:isPRoot(pnode))
/func


func isPExpr(pnode ptr ast:PNode) bool
  return pnode != null and pnode'type == ast:PEXPR
/func


func isPRoot(pnode ptr ast:PNode) bool
  return pnode != null and pnode'type == ast:PROOT
/func


mut PROOT      uint16 = 10
mut PENTRY     uint16 = 20
mut PFUNCTION  uint16 = 30
mut PALIAS     uint16 = 40
mut PDECL      uint16 = 50
mut PMUT       uint16 = 60
mut PIF        uint16 = 70
mut PEXPR      uint16 = 80
mut PBREAK     uint16 = 90
mut PCONTINUE  uint16 = 100
mut PRETURN    uint16 = 110
mut PIFELSE    uint16 = 120
mut PWHILE     uint16 = 130
mut PBLOCK     uint16 = 140
mut PMETHOD    uint16 = 150
