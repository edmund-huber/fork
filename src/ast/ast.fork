#  libfork, a base library for the Fork language
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2015
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the
#  licenses expressed under Section 1.12 of the MPL v2.


module ast


import ast
import astfn
import lex
import list
import mem
import txt
import utils


func findPBlock(node ptr ast:PNode) ptr ast:PNode
  if node == null
    return null
  /if

  if !ast:isPBlock(node)
    return findPBlock(node'parent)
  /if

  return node
/func


func findStab(node ptr ast:PNode) ptr ast:Symtable
  mut pblock = ast:findPBlock(node)

  return pblock != null => cast<ptr ast:PBlock>(pblock)'syms || null
/func


func findSymLocal(node ptr ast:PNode, name ptr uint8) ptr ast:Type
  mut stab = findStab(node)

  return ast:stabTypeof(stab, name)
/func


func findSym(node ptr ast:PNode, name ptr uint8) ptr ast:Type
  mut pblock = ast:findPBlock(node)

  if pblock != null
    mut stab = findStab(pblock)
    mut type = ast:stabTypeof(stab, name)

    return type != null => type || findSym(pblock'parent, name)
  /if

  return null
/func


func pnodeAppendChild(pnode, child ptr ast:PNode) ptr ast:PNode

  if pnode != null and child != null
    list:listAppend(pnode'leaves, child)

    child'parent = pnode
  /if

  return pnode
/func


func pnodeFree(pnode ptr ast:PNode)
  if pnode != null
    if ast:isPRoot(pnode)

      mut proot = cast<ptr ast:PRoot>(pnode)
      astfn:strdefFree(proot'moduleName)
      mem:free(proot'fileName)
      list:listFreeAll(proot'imports, cast<ptr func(inst data)>(ptr astfn:strdefFree))
      ast:stabFree(proot'aliases)

      mem:fpFree(proot'typePool)
    /if

    if ast:isPDecl(pnode)

      mut pdecl = cast<ptr ast:PDecl>(pnode)
      mem:decRef(pdecl'sym)

    /if

    if ast:isPBlock(pnode)
      ast:stabFree(cast<ptr ast:PBlock>(pnode)'syms)
    /if

    # remember to fix PBLOCK leaks.

    # remember to fix PEXPR leaks.

    list:listFreeAll(pnode'leaves, ptr pnodeFree)

    mem:free(pnode)
  /if
/func


func pnodeNew(type uint16, value uintptr) ptr ast:PNode

  mut pnode = cast<ptr ast:PNode>(mem:zalloc(size(ast:PNode)))
  pnode'type = type
  pnode'value = value
  pnode'leaves = list:listNew()

  return pnode
/func


func pnodeIsBreakContinue(pnode ptr ast:PNode) bool
  return pnode'type == ast:PBREAK or pnode'type == ast:PCONTINUE
/func


func pnodeIsDecl(pnode ptr ast:PNode) bool
  return pnode'type == ast:PDECL or pnode'type == ast:PMUT
/func


func pnodeIsExpr(pnode ptr ast:PNode) bool
  return pnode'type == ast:PEXPR
/func


func pnodeIsIf(pnode ptr ast:PNode) bool
  return pnode'type == ast:PIF or pnode'type == ast:PIFELSE
/func


func pnodeIsReturn(pnode ptr ast:PNode) bool
  return pnode'type == ast:PRETURN
/func


func pnodeIsWhile(pnode ptr ast:PNode) bool
  return pnode'type == ast:PWHILE
/func


func pblockNew() ptr ast:PBlock
  mut pblock = cast<ptr ast:PBlock>(mem:zalloc(size(ast:PBlock)))
  mut pnode = cast<ptr ast:PNode>(pblock)

  pnode'type = ast:PBLOCK
  pnode'leaves = list:listNew()

  return pblock
/func


func pdeclNew(nodeType uint16, sym ptr ast:PSymbol) ptr ast:PDecl

  mut pdecl = cast<ptr ast:PDecl>(mem:zalloc(size(ast:PDecl)))
  pdecl'node'type = nodeType
  pdecl'node'leaves = list:listNew()

  mem:incRef(sym)

  pdecl'sym = sym

  return pdecl
/func


func pexprNewTernary(tok ptr lex:Token, lhs,mid,rhs ptr ast:PExpr, begin,end ast:Line) ptr ast:PExpr
    mut pexpr = cast<ptr ast:PExpr>(mem:zalloc(size(ast:PExpr)))
    pexpr'node'type = ast:PEXPR
    pexpr'node'value = tok'value
    pexpr'node'leaves = list:listNew()
    pexpr'opType = tok'type
    tok'value = 0 # now the value belongs to this PExpr

    mut pnode = ptr pexpr'node
    pnode'begin = begin
    pnode'end = end

    astfn:pnodeAppendChild(pnode, ptr lhs'node)
    astfn:pnodeAppendChild(pnode, ptr mid'node)
    astfn:pnodeAppendChild(pnode, ptr rhs'node)

    lex:tokenFree(tok)

    return pexpr
/func


func pexprNew(tok ptr lex:Token, lhs,rhs ptr ast:PExpr, begin,end ast:Line) ptr ast:PExpr
  return pexprNewTernary(tok, lhs, null, rhs, begin, end)
/func


func pexprNewSingle(tok ptr lex:Token) ptr ast:PExpr
  return pexprNew(tok, null, null, lex:tokExtractBegin(tok), lex:tokExtractEnd(tok))
/func


func prootNew(moduleName ptr ast:StringDef, imports ptr list:List, fileName ptr uint8) ptr ast:PRoot

  mut proot = cast<ptr ast:PRoot>(mem:zalloc(size(ast:PRoot)))
  mut pnode = cast<ptr ast:PNode>(proot)

  pnode'type = ast:PROOT
  pnode'leaves = list:listNew()
  pnode'parent = null

  proot'moduleName = moduleName
  proot'imports = imports
  proot'fileName = txt:strclone(fileName)

  return proot

/func


func prootHasImported(root ptr ast:PRoot, name ptr uint8) bool
  mut i uintptr = 0
  mut len = list:listLen(root'imports)

  while i < len
    mut elem = cast<ptr ast:StringDef>(val list:listGet(root'imports, i))

    if txt:strequals(elem'name, name)
      return true
    /if

    i++
  /while

  return false
/func


func isPDecl(pnode ptr ast:PNode) bool
  return pnode != null and pnode'type == ast:PALIAS or pnode'type == ast:PDECL or pnode'type == ast:PMUT or pnode'type == ast:PENTRY or pnode'type == ast:PFUNCTION
/func

func isPBlock(pnode ptr ast:PNode) bool
  return pnode != null and (pnode'type == ast:PBLOCK or ast:isPRoot(pnode))
/func

func isPExpr(pnode ptr ast:PNode) bool
  return pnode != null and pnode'type == ast:PEXPR
/func


func isPRoot(pnode ptr ast:PNode) bool
  return pnode != null and pnode'type == ast:PROOT
/func

func strdefFree(strdef ptr ast:StringDef)
  if strdef != null
    mem:free(strdef'name)
    mem:free(strdef)
  /if
/func


func strdefNew(name ptr uint8, begin,end ast:Line) ptr ast:StringDef
  mut strdef = cast<ptr ast:StringDef>(mem:zalloc(size(ast:StringDef)))
  strdef'name = name
  strdef'begin = begin
  strdef'end = end

  return strdef
/func


mut PROOT      uint16 = 10
mut PENTRY     uint16 = 20
mut PFUNCTION  uint16 = 30
mut PALIAS     uint16 = 40
mut PDECL      uint16 = 50
mut PMUT       uint16 = 60
mut PIF        uint16 = 70
mut PEXPR      uint16 = 80
mut PBREAK     uint16 = 90
mut PCONTINUE  uint16 = 100
mut PRETURN    uint16 = 110
mut PIFELSE    uint16 = 120
mut PWHILE     uint16 = 130
mut PBLOCK     uint16 = 140
