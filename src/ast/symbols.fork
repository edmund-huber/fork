#  Second Step - Experimental Fork Compiler
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2014
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the
#  licenses expressed under Section 1.12 of the MPL v2.

import ast
import platform
import spring
import utils


func symbolClone(sym ptr ast:Symbol) ptr ast:Symbol
  if sym == null
    return null
  /if

  mut newInst = cast<ptr ast:Symbol>(spring:alloc(size(ast:Symbol)))
  newInst'name = spring:strclone(sym'name)
  newInst'type = sym'type

  return newInst
/func


func symbolFree(sym ptr ast:Symbol)
  if sym != null
    spring:free(sym'name)

    spring:free(sym)
  /if
/func


func symbolNew(name ptr uint8, type ptr ast:Type) ptr ast:Symbol
  mut sym = cast<ptr ast:Symbol>(spring:alloc(size(ast:Symbol)))

  sym'name = spring:strclone(name)
  sym'type = type

  return sym
/func


func symbolListClone(pool ptr utils:FreePool, symList ptr spring:List) ptr spring:List
  if symList == null
    return null
  /if

  mut len = spring:listLen(symList)
  mut ret = spring:listNew()
  mut i uintptr = 0

  while i < len
    mut elem = cast<ptr ast:Symbol>(val spring:listGet(symList, i))
    spring:listAppend(ret, ast:symbolClone(elem))
    i++
  /while

  return ret
/func


func typeClone(pool ptr utils:FreePool, type ptr ast:Type) ptr ast:Type
  if type == null
    return null
  /if

  mut newInst = cast<ptr ast:Type>(spring:memcpy(utils:fpAlloc(pool, size(ast:Type)), type, size(ast:Type)))
  newInst'moduleName = spring:strclone(type'moduleName)
  newInst'name = spring:strclone(type'name)
  newInst'retType = ast:typeClone(pool, type'retType)
  newInst'members = symbolListClone(pool, type'members)

  return newInst
/func


func typeFree(type ptr ast:Type)
  if type != null
    spring:free(type'moduleName)
    spring:free(type'name)

    if type'members != null
      spring:listFreeAll(type'members, cast<ptr func(p data)>(ast:symbolFree))
    /if

    spring:free(type)
  /if
/func


func typeNew(pool ptr utils:FreePool, type uint16, moduleName, name ptr uint8, isSigned bool,
  typeSize, typeAlign intptr, itemCount uintptr, retType ptr ast:Type, members ptr spring:List) ptr ast:Type

  mut location = pool != null => utils:fpAlloc(pool, size(ast:Type)) || spring:alloc(size(ast:Type))
  mut ret = cast<ptr ast:Type>(location)

  ret'type = type
  ret'moduleName = spring:strclone(moduleName)
  ret'name = spring:strclone(name)
  ret'isSigned = isSigned
  ret'typeSize = typeSize
  ret'typeAlign = typeAlign
  ret'itemCount = itemCount
  ret'retType = retType
  ret'members = members

  return ret
/func


func typeNewBuiltin(type uint16, name ptr uint8, isSigned bool,
  typeSize, typeAlign intptr, itemCount uintptr, retType ptr ast:Type, members ptr spring:List) ptr ast:Type
  mut ret = typeNew(null, type, null, name, isSigned, typeSize, typeAlign, itemCount, retType, members)
  ret'builtin = true

  return ret
/func


func typeNewBuiltinInt(name ptr uint8, len uint8, isSigned bool) ptr ast:Type
  return typeNewBuiltin(ast:TYPE_INT, name, isSigned, len, len, 1, null, null)
/func


func typeNewBuiltinBool() ptr ast:Type
  return typeNewBuiltin(ast:TYPE_BOOL, "bool", false, 1, 1, 1, null, null)
/func


func typeNewBuiltinData() ptr ast:Type
  return typeNewBuiltin(ast:TYPE_DATA, "data", false, platform:ptrSize, platform:ptrSize, 1, null, null)
/func


func builtinSetNew() ptr spring:Map

  mut ret = spring:strmapNew()

  spring:mapPut(ret, "uint8", typeNewBuiltinInt("uint8", 1, false), spring:FREE_VALUE)
  spring:mapPut(ret, "uint16", typeNewBuiltinInt("uint16", 2, false), spring:FREE_VALUE)
  spring:mapPut(ret, "uint32", typeNewBuiltinInt("uint32", 4, false), spring:FREE_VALUE)
  spring:mapPut(ret, "uint64", typeNewBuiltinInt("uint64", 8, false), spring:FREE_VALUE)
  spring:mapPut(ret, "int8", typeNewBuiltinInt("int8", 1, true), spring:FREE_VALUE)
  spring:mapPut(ret, "int16", typeNewBuiltinInt("int16", 2, true), spring:FREE_VALUE)
  spring:mapPut(ret, "int32", typeNewBuiltinInt("int32", 4, true), spring:FREE_VALUE)
  spring:mapPut(ret, "int64", typeNewBuiltinInt("int64", 8, true), spring:FREE_VALUE)
  spring:mapPut(ret, "uintptr", typeNewBuiltinInt("uintptr", platform:ptrSize, false), spring:FREE_VALUE)
  spring:mapPut(ret, "intptr", typeNewBuiltinInt("intptr", platform:ptrSize, true), spring:FREE_VALUE)
  spring:mapPut(ret, "bool", typeNewBuiltinBool(), spring:FREE_VALUE)
  spring:mapPut(ret, "data", typeNewBuiltinData(), spring:FREE_VALUE)

  return ret
/func


func typeNewFunc(pool ptr utils:FreePool, moduleName, name ptr uint8, retVal ptr ast:Type, members ptr spring:List) ptr ast:Type
  return typeNew(pool, ast:TYPE_FUNC, moduleName, name, false, 0, 0, 0, retVal, members)
/func


func typeNewLoc(pool ptr utils:FreePool, moduleName, name ptr uint8, itemCount uintptr, retVal ptr ast:Type) ptr ast:Type
  return typeNew(pool, ast:TYPE_LOC, moduleName, name, false, retVal'typeSize * cast<intptr>(itemCount), retVal'typeAlign, itemCount, retVal, null)
/func


func typeNewPtr(pool ptr utils:FreePool, moduleName, name ptr uint8, retVal ptr ast:Type) ptr ast:Type
  return typeNew(pool, ast:TYPE_PTR, moduleName, name, false, platform:ptrSize, platform:ptrSize, 1, retVal, null)
/func


alias AlignResult struct(typeAlign,typeSize intptr)

# members is a list of ast:Symbol
func typeCalculateAlign(members ptr spring:List) AlignResult
  mut ret AlignResult
  ret'typeAlign = 1
  ret'typeSize  = 0

  mut i uintptr = 0
  mut len = spring:listLen(members)

  while i < len
    mut member = cast<ptr ast:Symbol>(val spring:listGet(members, i))'type

    # calculate the alignment offset of the member against the current starting address.
    mut offset = ret'typeSize mod member'typeAlign

    # if offset is not 0, then the member to be inserted is currently misaligned.
    # padding is needed.
    if offset != 0
      mut padding = member'typeAlign - offset
      ret'typeSize = ret'typeSize + padding
    /if

    ret'typeSize = ret'typeSize + member'typeSize
    ret'typeAlign = (member'typeAlign > ret'typeAlign) => member'typeAlign || ret'typeAlign

    i++
  /while

  # for being sequentially stackable, structs must be padded at the end, according to their alignment.
  mut finalOffset = ret'typeSize mod ret'typeAlign

  # if there is misalignment at the end of the struct, we need additional padding to reach
  # a size which is a multiple of the alignment value.
  if finalOffset > 0
    ret'typeSize = ret'typeSize + (ret'typeAlign - finalOffset)
  /if

  return ret
/func


func typeNewRecursiveAlias(pool ptr utils:FreePool, moduleName, name ptr uint8) ptr ast:Type
  return typeNew(pool, ast:TYPE_REC_ALIAS, moduleName, name, false, -1, -1, 0, null, null)
/func


func typeNewStruct(pool ptr utils:FreePool, moduleName, name ptr uint8, members ptr spring:List) ptr ast:Type
  mut alignInfo = typeCalculateAlign(members)

  return typeNew(pool, ast:TYPE_STRUCT, moduleName, name, false, alignInfo'typeSize, alignInfo'typeAlign, 1, null, members)
/func


func typeSetAlias(type ptr ast:Type, moduleName, name ptr uint8)
  if type != null
    type'moduleName = spring:strclone(moduleName)
    type'name = spring:strclone(name)
  /if
/func


func typeSetBoundaries(type ptr ast:Type, begin,end utils:Line)
  if type != null
    type'begin = begin
    type'end = end
  /if
/func


func stabNew() ptr ast:Symtable
  mut stab = cast<ptr ast:Symtable>(spring:zalloc(size(ast:Symtable)))

  stab'syms = spring:strmapNew()

  return stab
/func


func stabAdd(stab ptr ast:Symtable, name ptr uint8, type ptr ast:Type)
  spring:mapPut(stab'syms, spring:strclone(name), type, spring:FREE_KEY)
/func


func stabTypeof(stab ptr ast:Symtable, name ptr uint8) ptr ast:Type
  mut value ptr ast:Type = null

  spring:mapGet(stab'syms, name, ptr value)

  return value
/func


func stabFree(stab ptr ast:Symtable)
  if stab != null
    spring:mapFreeSpec(stab'syms, ptr spring:free, null)
    spring:free(stab)
  /if
/func


mut TYPE_FUNC      uint16 = 10
mut TYPE_PTR       uint16 = 20
mut TYPE_STRUCT    uint16 = 30
mut TYPE_LOC       uint16 = 40
mut TYPE_BOOL      uint16 = 50
mut TYPE_INT       uint16 = 60
mut TYPE_DATA      uint16 = 70
mut TYPE_REC_ALIAS uint16 = 80
mut TYPE_NULL      uint16 = 90
