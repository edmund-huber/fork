#  libfork, a base library for the Fork language
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2015
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the
#  licenses expressed under Section 1.12 of the MPL v2.


module ast


import ast
import astfn
import kv
import map
import mem
import proc
import platform
import tty
import txt
import utils


method ast:Symbol.equals(other ptr ast:Symbol) bool
  return txt:strequals(me'name, other'name) and me'type.equals(other'type)
/method


func typeEqualsList(list1, list2 ptr kv:KVList) bool
  mut len = list1.len()

  if len != list2.len()
    return false
  /if

  mut i uintptr = 0

  while i < len
    mut pair1 = list1.getAt(i)
    mut pair2 = list2.getAt(i)

    mut name1 = <ptr uint8>(pair1'key)
    mut name2 = <ptr uint8>(pair2'key)

    mut type1 = <ptr ast:Type>(pair1'value)
    mut type2 = <ptr ast:Type>(pair2'value)

    if not txt:strequals(name1, name2) or not type1.equals(type2)
      return false
    /if

    i++
  /while

  return true
/func


func typeFree(type ptr ast:Type)
  if type?
    mem:free(type'moduleName)
    mem:free(type'name)

    if type'members?
      kv:free(type'members)
    /if

    mem:free(type)
  /if
/func


method ast:Type.equals(other ptr ast:Type) bool
  if not other?
    return false
  /if

  if me'name? and other'name?
    mut res = txt:strequals(me'name, other'name)

    if res and me'moduleName? and other'moduleName?
      res = txt:strequals(me'moduleName, other'moduleName)
    /if

    return res
  /if

  if me'type != other'type
    return false
  /if

  if me'type == ast:TYPE_FUNC
    return me'retType.equals(other'retType) and typeEqualsList(me'members, other'members)
  else
    if me'type == ast:TYPE_PTR
      return me'retType.equals(other'retType)
    else
      if me'type == ast:TYPE_STRUCT
        return typeEqualsList(me'members, other'members)
      else
        if me'type == ast:TYPE_LOC
          return me'retType.equals(other'retType) and me'itemCount == other'itemCount
        else
          if me'type == ast:TYPE_BOOL
            return true
          else
            if me'type == ast:TYPE_INT
              return me'isSigned == other'isSigned and me'typeSize == other'typeSize
            else
              if me'type == ast:TYPE_DATA
                return true
              else
                if me'type == ast:TYPE_NULL
                  return true
                else
                  tty:errln("Unreachable: unknown type comparison")
                  proc:abort()
                /if
              /if
            /if
          /if
        /if
      /if
    /if
  /if
/method


method ast:Type.isBool() bool
  return me'type == ast:TYPE_BOOL
/method


method ast:Type.isData() bool
  return me'type == ast:TYPE_DATA
/method


method ast:Type.isFunc() bool
  return me'type == ast:TYPE_FUNC
/method


method ast:Type.isInt() bool
  return me'type == ast:TYPE_INT
/method


method ast:Type.isLoc() bool
  return me'type == ast:TYPE_LOC
/method


method ast:Type.isNull() bool
  return me'type == ast:TYPE_NULL
/method


method ast:Type.isPtr() bool
  return me'type == ast:TYPE_PTR or me'type == ast:TYPE_DATA
/method


method ast:Type.isStruct() bool
  return me'type == ast:TYPE_STRUCT
/method


func stabNew() ptr ast:Symtable
  mut stab = <ptr ast:Symtable>(mem:zalloc(size(ast:Symtable)))

  stab'syms = kv:strnew(10)

  stab'syms.setFreeFuncs(ptr mem:free, ptr astfn:declInfoFree)

  return stab
/func


func stabFree(stab ptr ast:Symtable)
  if stab?
    kv:free(stab'syms)
    mem:free(stab)
  /if
/func


method ast:Symtable.add(name ptr uint8,
                        isDecl,funcParam bool,
                        type ptr ast:Type,
                        symType uint16)

  me'syms.put(txt:strclone(name), \
                astfn:declInfoNew(symType, isDecl, funcParam, type))
/method


method ast:Symtable.get(name ptr uint8) ptr ast:DeclInfo
  return <ptr ast:DeclInfo>(me'syms.get(name))
/method


method ast:Symtable.typeof(name ptr uint8) ptr ast:Type
  mut di = me.get(name)

  return di? => di'type || null
/method


mut TYPE_FUNC      uint16 = 10
mut TYPE_PTR       uint16 = 20
mut TYPE_STRUCT    uint16 = 30
mut TYPE_LOC       uint16 = 40
mut TYPE_BOOL      uint16 = 50
mut TYPE_INT       uint16 = 60
mut TYPE_DATA      uint16 = 70
mut TYPE_RECALIAS  uint16 = 80
mut TYPE_NULL      uint16 = 90
mut TYPE_EMPTY     uint16 = 100
