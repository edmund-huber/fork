#  Second Step - Experimental Fork Compiler
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2014
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the
#  licenses expressed under Section 1.12 of the MPL v2.

import ast
import platform
import spring


func symbolClone(sym ptr ast:Symbol) ptr ast:Symbol
  if sym == null
    return null
  /if

  mut newInst = cast<ptr ast:Symbol>(spring:alloc(size(ast:Symbol)))
  newInst'name = spring:strclone(sym'name)
  newInst'type = ast:typeClone(sym'type)

  return newInst
/func


func symbolFree(sym ptr ast:Symbol)
  if sym != null
    spring:free(sym'name)
    ast:typeFree(sym'type)

    spring:free(sym)
  /if
/func


func symbolNew(name ptr uint8, type ptr ast:Type) ptr ast:Symbol
  mut sym = cast<ptr ast:Symbol>(spring:alloc(size(ast:Symbol)))

  sym'name = spring:strclone(name)
  sym'type = type

  return sym
/func


func symbolListClone(symList ptr spring:List) ptr spring:List
  if symList == null
    return null
  /if

  mut len = spring:listLen(symList)
  mut ret = spring:listNew()
  mut i uintptr = 0

  while i < len
    mut elem = cast<ptr ast:Symbol>(val spring:listGet(symList, i))
    spring:listAppend(ret, ast:symbolClone(elem))
    i++
  /while

  return ret
/func


func typeClone(type ptr ast:Type) ptr ast:Type
  if type == null
    return null
  /if

  mut newInst = cast<ptr ast:Type>(spring:memcpy(spring:alloc(size(ast:Type)), type, size(ast:Type)))
  newInst'moduleName = spring:strclone(type'moduleName)
  newInst'name = spring:strclone(type'name)
  newInst'retType = ast:typeClone(type'retType)
  newInst'members = symbolListClone(type'members)

  return newInst
/func


func typeFree(type ptr ast:Type)
  if type != null
    spring:free(type'moduleName)
    spring:free(type'name)
    ast:typeFree(type'retType)
    spring:listFreeAll(type'members, cast<ptr func(p data)>(ast:symbolFree))
  /if
/func


func typeNew(type uint16, moduleName, name ptr uint8, isSigned bool,
  typeSize, typeAlign intptr, itemCount uintptr, retType ptr ast:Type, members ptr spring:List) ptr ast:Type
  mut ret = cast<ptr ast:Type>(spring:alloc(size(ast:Type)))

  ret'type = type
  ret'moduleName = spring:strclone(moduleName)
  ret'name = spring:strclone(name)
  ret'isSigned = isSigned
  ret'typeSize = typeSize
  ret'typeAlign = typeAlign
  ret'itemCount = itemCount
  ret'retType = retType
  ret'members = members

  return ret
/func


func typeNewBuiltinInt(name ptr uint8, len uint8, isSigned bool) ptr ast:Type
  return typeNew(ast:TYPE_INT, null, name, isSigned, len, len, 1, null, null)
/func


func typeNewBuiltinBool() ptr ast:Type
  return typeNew(ast:TYPE_BOOL, null, "bool", false, 1, 1, 1, null, null)
/func


func typeNewBuiltinData() ptr ast:Type
  return typeNew(ast:TYPE_DATA, null, "data", false, platform:ptrSize, platform:ptrSize, 1, null, null)
/func


func typeNewBuiltin(name ptr uint8) ptr ast:Type

  if spring:strequals(name, "uint8")
    return typeNewBuiltinInt(name, 1, false)
  /if

  if spring:strequals(name, "uint16")
    return typeNewBuiltinInt(name, 2, false)
  /if

  if spring:strequals(name, "uint32")
    return typeNewBuiltinInt(name, 4, false)
  /if

  if spring:strequals(name, "uint64")
    return typeNewBuiltinInt(name, 8, false)
  /if

  if spring:strequals(name, "int8")
    return typeNewBuiltinInt(name, 1, true)
  /if

  if spring:strequals(name, "int16")
    return typeNewBuiltinInt(name, 2, true)
  /if

  if spring:strequals(name, "int32")
    return typeNewBuiltinInt(name, 4, true)
  /if

  if spring:strequals(name, "int64")
    return typeNewBuiltinInt(name, 8, true)
  /if

  if spring:strequals(name, "uintptr")
    return typeNewBuiltinInt(name, platform:ptrSize, false)
  /if

  if spring:strequals(name, "intptr")
    return typeNewBuiltinInt(name, platform:ptrSize, true)
  /if

  if spring:strequals(name, "bool")
    return typeNewBuiltinBool()
  /if

  if spring:strequals(name, "data")
    return typeNewBuiltinData()
  /if

  return null

/func


func typeNewFunc(moduleName, name ptr uint8, retVal ptr ast:Type, members ptr spring:List) ptr ast:Type
  return typeNew(ast:TYPE_FUNC, moduleName, name, false, 0, 0, 0, retVal, members)
/func


func typeNewLoc(moduleName, name ptr uint8, itemCount intptr, retVal ptr ast:Type) ptr ast:Type
  return typeNew(ast:TYPE_LOC, moduleName, name, false, retVal'typeSize * itemCount, retVal'typeAlign, itemCount, retVal, null)
/func


func typeNewPtr(moduleName, name ptr uint8, retVal ptr ast:Type) ptr ast:Type
  return typeNew(ast:TYPE_PTR, moduleName, name, false, platform:ptrSize, platform:ptrSize, 1, retVal, null)
/func


alias AlignResult struct(typeAlign,typeSize intptr)


func typeCalculateAlign(members ptr spring:List) AlignResult
  mut ret AlignResult
  ret'typeAlign = 1
  ret'typeSize  = 0

  mut i uintptr = 0
  mut len = spring:listLen(members)

  while i < len
    mut member = cast<ptr ast:Type>(val spring:listGet(members, i))

    # calculate the alignment offset of the member against the current starting address.
    mut offset = ret'typeSize mod member'typeAlign

    # if offset is not 0, then the member to be inserted is currently misaligned.
    # padding is needed.
    if offset != 0
      mut padding = member'typeAlign - offset
      ret'typeSize = ret'typeSize + padding
    /if

    ret'typeSize = member'typeSize
    ret'typeAlign = (member'typeAlign > ret'typeAlign) => member'typeAlign || ret'typeAlign

    i++
  /while

  # for being sequentially stackable, structs must be padded at the end, according to their alignment.
  mut finalOffset = ret'typeSize mod ret'typeAlign

  # if there is misalignment at the end of the struct, we need additional padding to reach
  # a size which is a multiple of the alignment value.
  if finalOffset > 0
    ret'typeSize = ret'typeSize + (ret'typeAlign - finalOffset)
  /if

  return ret
/func


func typeNewRecursiveAlias(moduleName, name ptr uint8) ptr ast:Type
  return typeNew(ast:TYPE_REC_ALIAS, moduleName, name, false, -1, -1, 0, null, null)
/func


func typeNewStruct(moduleName, name ptr uint8, members ptr spring:List) ptr ast:Type
  mut alignInfo = typeCalculateAlign(members)

  return typeNew(ast:TYPE_STRUCT, moduleName, name, false, alignInfo'typeSize, alignInfo'typeAlign, 1, null, members)
/func


func typeSetAlias(type ptr ast:Type, moduleName, name ptr uint8) ptr ast:Type
  if type != null
    type'moduleName = spring:strclone(moduleName)
    type'name = spring:strclone(name)
  /if
/func


func stabNew() ptr ast:Symtable
  mut stab = cast<ptr ast:Symtable>(spring:zalloc(size(ast:Symtable)))

  stab'syms = spring:strmapNew()

  return stab
/func


func stabAdd(stab ptr ast:Symtable, name ptr uint8, type ptr ast:Type)
  spring:mapPut(stab'syms, spring:strclone(name), type, spring:FREE_KEY | spring:FREE_VALUE)
/func


func stabTypeof(stab ptr ast:Symtable, name ptr uint8) ptr ast:Type
  mut value ptr ast:Type = null

  spring:mapGet(stab'syms, name, ptr value)

  return value
/func


func stabFree(stab ptr ast:Symtable)
  if stab != null
    spring:mapFreeSpec(stab'syms, ptr spring:free, cast<ptr func(item data)>(ast:typeFree))
    spring:free(stab)
  /if
/func


mut TYPE_FUNC      uint16 = 10
mut TYPE_PTR       uint16 = 20
mut TYPE_STRUCT    uint16 = 30
mut TYPE_LOC       uint16 = 40
mut TYPE_BOOL      uint16 = 50
mut TYPE_INT       uint16 = 60
mut TYPE_DATA      uint16 = 70
mut TYPE_REC_ALIAS uint16 = 80
mut TYPE_NULL      uint16 = 90
