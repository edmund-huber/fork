#  libfork, a base library for the Fork language
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2015
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the
#  licenses expressed under Section 1.12 of the MPL v2.


module ast


import ast
import astfn
import kv
import map
import mem
import proc
import platform
import tty
import txt
import utils


func symbolEquals(sym1,sym2 ptr ast:Symbol) bool
  return txt:strequals(sym1'name, sym2'name) and ast:typeEquals(sym1'type, sym2'type)
/func


func typeEqualsList(list1, list2 ptr kv:KVList) bool
  mut len = kv:kvLen(list1)

  if len != kv:kvLen(list2)
    return false
  /if

  mut i uintptr = 0

  while i < len
    mut pair1 = kv:kvGetAt(list1, i)
    mut pair2 = kv:kvGetAt(list2, i)

    mut name1 = cast<ptr uint8>(pair1'key)
    mut name2 = cast<ptr uint8>(pair2'key)

    mut type1 = cast<ptr ast:Type>(pair1'value)
    mut type2 = cast<ptr ast:Type>(pair2'value)

    if !txt:strequals(name1, name2) or !ast:typeEquals(type1, type2)
      return false
    /if

    i++
  /while

  return true
/func


func typeEquals(type1, type2 ptr ast:Type) bool
  if type1 == null or type2 == null
    return false
  /if

  if type1'name != null and type2'name != null
    mut res = txt:strequals(type1'name, type2'name)

    if res and type1'moduleName != null and type2'moduleName != null
      res = txt:strequals(type1'moduleName, type2'moduleName)
    /if

    return res
  /if

  if type1'type != type2'type
    return false
  /if

  if type1'type == ast:TYPE_FUNC
    return typeEquals(type1'retType, type2'retType) and typeEqualsList(type1'members, type2'members)
  else
    if type1'type == ast:TYPE_PTR
      return typeEquals(type1'retType, type2'retType)
    else
      if type1'type == ast:TYPE_STRUCT
        return typeEqualsList(type1'members, type2'members)
      else
        if type1'type == ast:TYPE_LOC
          return typeEquals(type1'retType, type2'retType) and type1'itemCount == type2'itemCount
        else
          if type1'type == ast:TYPE_BOOL
            return true
          else
            if type1'type == ast:TYPE_INT
              return type1'isSigned == type2'isSigned and type1'typeSize == type2'typeSize
            else
              if type1'type == ast:TYPE_DATA
                return true
              else
                if type1'type == ast:TYPE_NULL
                  return true
                else
                  tty:errln("Unreachable: unknown type comparison")
                  proc:abort()
                /if
              /if
            /if
          /if
        /if
      /if
    /if
  /if
/func


func typeFree(type ptr ast:Type)
  if type != null
    mem:free(type'moduleName)
    mem:free(type'name)

    if type'members != null
      kv:kvFree(type'members)
    /if

    mem:free(type)
  /if
/func


func typeIsBool(type ptr ast:Type) bool
  return type != null and type'type == ast:TYPE_BOOL
/func


func typeIsData(type ptr ast:Type) bool
  return type != null and type'type == ast:TYPE_DATA
/func


func typeIsFunc(type ptr ast:Type) bool
  return type != null and type'type == ast:TYPE_FUNC
/func


func typeIsInt(type ptr ast:Type) bool
  return type != null and type'type == ast:TYPE_INT
/func


func typeIsLoc(type ptr ast:Type) bool
  return type != null and type'type == ast:TYPE_LOC
/func


func typeIsNull(type ptr ast:Type) bool
  return type != null and type'type == ast:TYPE_NULL
/func


func typeIsPtr(type ptr ast:Type) bool
  return type != null and (type'type == ast:TYPE_PTR or type'type == ast:TYPE_DATA)
/func


func typeIsStruct(type ptr ast:Type) bool
  return type != null and type'type == ast:TYPE_STRUCT
/func


func stabNew() ptr ast:Symtable
  mut stab = cast<ptr ast:Symtable>(mem:zalloc(size(ast:Symtable)))

  stab'syms = kv:strkvNew(10)

  kv:kvSetFreeFuncs(stab'syms, ptr mem:free, ptr astfn:declInfoFree)

  return stab
/func


func stabAdd(stab ptr ast:Symtable, name ptr uint8, isDecl bool, type ptr ast:Type, symType uint16)
  kv:kvPut(stab'syms, txt:strclone(name), astfn:declInfoNew(symType, isDecl, type))
/func


func stabGet(stab ptr ast:Symtable, name ptr uint8) ptr ast:DeclInfo
  mut value ptr ast:DeclInfo = null

  kv:kvGet(stab'syms, name, ptr value)

  return value
/func


func stabTypeof(stab ptr ast:Symtable, name ptr uint8) ptr ast:Type
  mut di = ast:stabGet(stab, name)

  return di != null => di'type || null
/func


func stabFree(stab ptr ast:Symtable)
  if stab != null
    kv:kvFree(stab'syms)
    mem:free(stab)
  /if
/func


mut TYPE_FUNC      uint16 = 10
mut TYPE_PTR       uint16 = 20
mut TYPE_STRUCT    uint16 = 30
mut TYPE_LOC       uint16 = 40
mut TYPE_BOOL      uint16 = 50
mut TYPE_INT       uint16 = 60
mut TYPE_DATA      uint16 = 70
mut TYPE_RECALIAS  uint16 = 80
mut TYPE_NULL      uint16 = 90
mut TYPE_EMPTY     uint16 = 100
