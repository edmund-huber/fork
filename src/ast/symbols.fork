#  Second Step - Experimental Fork Compiler
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2015
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the
#  licenses expressed under Section 1.12 of the MPL v2.

import ast
import platform
import base
import utils


func symbolClone(sym ptr ast:Symbol) ptr ast:Symbol
  if sym == null
    return null
  /if

  mut newInst = cast<ptr ast:Symbol>(base:alloc(size(ast:Symbol)))
  newInst'name = base:strclone(sym'name)
  newInst'type = sym'type

  return newInst
/func

func symbolEquals(sym1,sym2 ptr ast:Symbol) bool
  return base:strequals(sym1'name, sym2'name) and ast:typeEquals(sym1'type, sym2'type)
/func


func symbolFree(sym ptr ast:Symbol)
  if sym != null
    base:free(sym'name)

    base:free(sym)
  /if
/func


func symbolNew(name ptr uint8, type ptr ast:Type) ptr ast:Symbol
  mut sym = cast<ptr ast:Symbol>(base:alloc(size(ast:Symbol)))

  sym'name = base:strclone(name)
  sym'type = type

  return sym
/func


func symbolListClone(pool ptr utils:FreePool, symList ptr utils:KVList) ptr utils:KVList
  if symList == null
    return null
  /if

  mut len = utils:kvLen(symList)
  mut ret = utils:strkvNew()
  mut i uintptr = 0

  while i < len
    mut elem = utils:kvGetAt(symList, i)
    mut newStr = base:strclone(cast<ptr uint8>(elem'key))
    mut newType = ast:typeClone(pool, cast<ptr ast:Type>(elem'value))

    utils:kvPut(ret, newStr, newType)

    i++
  /while

  return ret
/func


func typeClone(pool ptr utils:FreePool, type ptr ast:Type) ptr ast:Type
  if type == null
    return null
  /if

  mut newInst = cast<ptr ast:Type>(base:memcpy(utils:fpAlloc(pool, size(ast:Type)), type, size(ast:Type)))
  newInst'moduleName = base:strclone(type'moduleName)
  newInst'name = base:strclone(type'name)
  newInst'retType = ast:typeClone(pool, type'retType)
  newInst'members = symbolListClone(pool, type'members)

  return newInst
/func


func typeEqualsList(list1, list2 ptr utils:KVList) bool
  mut len = utils:kvLen(list1)

  if len != utils:kvLen(list2)
    return false
  /if

  mut i uintptr = 0

  while i < len
    mut pair1 = utils:kvGetAt(list1, i)
    mut pair2 = utils:kvGetAt(list2, i)

    mut name1 = cast<ptr uint8>(pair1'key)
    mut name2 = cast<ptr uint8>(pair2'key)

    mut type1 = cast<ptr ast:Type>(pair1'value)
    mut type2 = cast<ptr ast:Type>(pair2'value)

    if !base:strequals(name1, name2) or !ast:typeEquals(type1, type2)
      return false
    /if

    i++
  /while

  return true
/func


func typeEquals(type1, type2 ptr ast:Type) bool
  if type1 == null or type2 == null
    return false
  /if

  if type1'name != null and type2'name != null
    mut res = base:strequals(type1'name, type2'name)

    if res and type1'moduleName != null and type2'moduleName != null
      res = base:strequals(type1'moduleName, type2'moduleName)
    /if

    return res
  /if

  if type1'type != type2'type
    return false
  /if

  if type1'type == ast:TYPE_FUNC
    return typeEquals(type1'retType, type2'retType) and typeEqualsList(type1'members, type2'members)
  else
    if type1'type == ast:TYPE_PTR
      return typeEquals(type1'retType, type2'retType)
    else
      if type1'type == ast:TYPE_STRUCT
        return typeEqualsList(type1'members, type2'members)
      else
        if type1'type == ast:TYPE_LOC
          return typeEquals(type1'retType, type2'retType) and type1'itemCount == type2'itemCount
        else
          if type1'type == ast:TYPE_BOOL
            return true
          else
            if type1'type == ast:TYPE_INT
              return type1'isSigned == type2'isSigned and type1'typeSize == type2'typeSize
            else
              if type1'type == ast:TYPE_DATA
                return true
              else
                if type1'type == ast:TYPE_NULL
                  return true
                else
                  base:errln("Unreachable: unknown type comparison")
                  base:abort()
                /if
              /if
            /if
          /if
        /if
      /if
    /if
  /if
/func


func typeFree(type ptr ast:Type)
  if type != null
    base:free(type'moduleName)
    base:free(type'name)

    if type'members != null
      utils:kvFree(type'members)
    /if

    base:free(type)
  /if
/func


func typeIsBool(type ptr ast:Type) bool
  return type != null and type'type == ast:TYPE_BOOL
/func


func typeIsData(type ptr ast:Type) bool
  return type != null and type'type == ast:TYPE_DATA
/func


func typeIsFunc(type ptr ast:Type) bool
  return type != null and type'type == ast:TYPE_FUNC
/func


func typeIsInt(type ptr ast:Type) bool
  return type != null and type'type == ast:TYPE_INT
/func


func typeIsLoc(type ptr ast:Type) bool
  return type != null and type'type == ast:TYPE_LOC
/func


func typeIsNull(type ptr ast:Type) bool
  return type != null and type'type == ast:TYPE_NULL
/func


func typeIsPtr(type ptr ast:Type) bool
  return type != null and (type'type == ast:TYPE_PTR or type'type == ast:TYPE_DATA)
/func


func typeIsStruct(type ptr ast:Type) bool
  return type != null and type'type == ast:TYPE_STRUCT
/func


func typeNew(pool ptr utils:FreePool,
             type uint16,
             moduleName, name ptr uint8,
             isSigned bool,
             typeSize, typeAlign intptr,
             itemCount uintptr,
             retType ptr ast:Type,
             members ptr utils:KVList) ptr ast:Type

  mut location = pool != null => utils:fpAlloc(pool, size(ast:Type)) || base:alloc(size(ast:Type))
  mut ret = cast<ptr ast:Type>(location)

  ret'type = type
  ret'moduleName = base:strclone(moduleName)
  ret'name = base:strclone(name)
  ret'isSigned = isSigned
  ret'typeSize = typeSize
  ret'typeAlign = typeAlign
  ret'itemCount = itemCount
  ret'retType = retType
  ret'members = members

  return ret
/func


func typeNewBuiltin(type uint16,
                    name ptr uint8,
                    isSigned bool,
                    typeSize, typeAlign intptr,
                    itemCount uintptr,
                    retType ptr ast:Type,
                    members ptr utils:KVList) ptr ast:Type

  mut ret = typeNew(null, type, null, name, isSigned, typeSize, typeAlign, itemCount, retType, members)
  ret'builtin = true

  return ret
/func


func typeNewBuiltinInt(name ptr uint8, len uint8, isSigned bool) ptr ast:Type
  return typeNewBuiltin(ast:TYPE_INT, name, isSigned, len, len, 1, null, null)
/func


func typeNewBuiltinBool() ptr ast:Type
  return typeNewBuiltin(ast:TYPE_BOOL, "bool", false, 1, 1, 1, null, null)
/func


func typeNewBuiltinData() ptr ast:Type
  return typeNewBuiltin(ast:TYPE_DATA, "data", false, platform:ptrSize, platform:ptrSize, 1, null, null)
/func


func typeNewBuiltinEmpty() ptr ast:Type
  return typeNewBuiltin(ast:TYPE_EMPTY, "\0", false, 0, 0, 0, null, null)
/func


func typeNewBuiltinNull() ptr ast:Type
  return typeNewBuiltin(ast:TYPE_NULL, "null", false, platform:ptrSize, platform:ptrSize, 1, null, null)
/func


func typeNewBuiltinString(uint8t ptr ast:Type) ptr ast:Type
  return ast:typeNewPtr(null, null, null, uint8t)
/func


func builtinSetNew() ptr base:Map

  mut ret = base:strmapNew()
  mut uint8t = typeNewBuiltinInt("uint8", 1, false)

  base:mapPut(ret, "uint8", uint8t, base:FREE_VALUE)
  base:mapPut(ret, "uint16", typeNewBuiltinInt("uint16", 2, false), base:FREE_VALUE)
  base:mapPut(ret, "uint32", typeNewBuiltinInt("uint32", 4, false), base:FREE_VALUE)
  base:mapPut(ret, "uint64", typeNewBuiltinInt("uint64", 8, false), base:FREE_VALUE)
  base:mapPut(ret, "int8", typeNewBuiltinInt("int8", 1, true), base:FREE_VALUE)
  base:mapPut(ret, "int16", typeNewBuiltinInt("int16", 2, true), base:FREE_VALUE)
  base:mapPut(ret, "int32", typeNewBuiltinInt("int32", 4, true), base:FREE_VALUE)
  base:mapPut(ret, "int64", typeNewBuiltinInt("int64", 8, true), base:FREE_VALUE)
  base:mapPut(ret, "uintptr", typeNewBuiltinInt("uintptr", platform:ptrSize, false), base:FREE_VALUE)
  base:mapPut(ret, "intptr", typeNewBuiltinInt("intptr", platform:ptrSize, true), base:FREE_VALUE)
  base:mapPut(ret, "bool", typeNewBuiltinBool(), base:FREE_VALUE)
  base:mapPut(ret, "data", typeNewBuiltinData(), base:FREE_VALUE)
  base:mapPut(ret, "\0", typeNewBuiltinEmpty(), base:FREE_VALUE)
  base:mapPut(ret, "null", typeNewBuiltinNull(), base:FREE_VALUE)
  base:mapPut(ret, "ptr uint8", typeNewBuiltinString(uint8t), base:FREE_VALUE)

  return ret
/func


func typeNewFunc(pool ptr utils:FreePool, moduleName, name ptr uint8, retVal ptr ast:Type, members ptr utils:KVList) ptr ast:Type
  return typeNew(pool, ast:TYPE_FUNC, moduleName, name, false, 0, 0, 0, retVal, members)
/func


func typeNewLoc(pool ptr utils:FreePool, moduleName, name ptr uint8, itemCount uintptr, retVal ptr ast:Type) ptr ast:Type
  return typeNew(pool, ast:TYPE_LOC, moduleName, name, false, retVal'typeSize * cast<intptr>(itemCount), retVal'typeAlign, itemCount, retVal, null)
/func


func typeNewPtr(pool ptr utils:FreePool, moduleName, name ptr uint8, retVal ptr ast:Type) ptr ast:Type
  return typeNew(pool, ast:TYPE_PTR, moduleName, name, false, platform:ptrSize, platform:ptrSize, 1, retVal, null)
/func


alias AlignResult struct(typeAlign,typeSize intptr)

# members is a list of ast:Symbol
func typeCalculateAlign(members ptr utils:KVList) AlignResult
  mut ret AlignResult
  ret'typeAlign = 1
  ret'typeSize  = 0

  mut i uintptr = 0
  mut len = utils:kvLen(members)

  while i < len
    mut member = cast<ptr ast:Type>(utils:kvGetAt(members, i)'value)

    # calculate the alignment offset of the member against the current starting address.
    mut offset = ret'typeSize mod member'typeAlign

    # if offset is not 0, then the member to be inserted is currently misaligned.
    # padding is needed.
    if offset != 0
      mut padding = member'typeAlign - offset
      ret'typeSize = ret'typeSize + padding
    /if

    ret'typeSize = ret'typeSize + member'typeSize
    ret'typeAlign = (member'typeAlign > ret'typeAlign) => member'typeAlign || ret'typeAlign

    i++
  /while

  # for being sequentially stackable, structs must be padded at the end, according to their alignment.
  mut finalOffset = ret'typeSize mod ret'typeAlign

  # if there is misalignment at the end of the struct, we need additional padding to reach
  # a size which is a multiple of the alignment value.
  if finalOffset > 0
    ret'typeSize = ret'typeSize + (ret'typeAlign - finalOffset)
  /if

  return ret
/func


func typeNewRecursiveAlias(pool ptr utils:FreePool, moduleName, name ptr uint8) ptr ast:Type
  return typeNew(pool, ast:TYPE_RECALIAS, moduleName, name, false, -1, -1, 0, null, null)
/func


func typeNewStruct(pool ptr utils:FreePool, moduleName, name ptr uint8, members ptr utils:KVList) ptr ast:Type
  mut alignInfo = typeCalculateAlign(members)

  return typeNew(pool, ast:TYPE_STRUCT, moduleName, name, false, alignInfo'typeSize, alignInfo'typeAlign, 1, null, members)
/func


func typeSetAlias(type ptr ast:Type, moduleName, name ptr uint8)
  if type != null
    type'moduleName = base:strclone(moduleName)
    type'name = base:strclone(name)
  /if
/func


func typeSetBoundaries(type ptr ast:Type, begin,end utils:Line)
  if type != null
    type'begin = begin
    type'end = end
  /if
/func


func declInfoFree(declInfo ptr ast:DeclInfo)
  base:free(declInfo)
/func


func declInfoNew(declType uint16, type ptr ast:Type) ptr ast:DeclInfo
  mut ret = cast<ptr ast:DeclInfo>(base:alloc(size(ast:DeclInfo)))
  ret'declType = declType
  ret'type = type

  return ret
/func


func stabNew() ptr ast:Symtable
  mut stab = cast<ptr ast:Symtable>(base:zalloc(size(ast:Symtable)))

  stab'syms = base:strmapNew()

  return stab
/func


func stabAdd(stab ptr ast:Symtable, name ptr uint8, type ptr ast:Type, symType uint16)
  base:mapPut(stab'syms, base:strclone(name), ast:declInfoNew(symType, type), base:FREE_KEY | base:FREE_VALUE)
/func


func stabGet(stab ptr ast:Symtable, name ptr uint8) ptr ast:DeclInfo
  mut value ptr ast:DeclInfo = null

  base:mapGet(stab'syms, name, ptr value)

  return value
/func


func stabTypeof(stab ptr ast:Symtable, name ptr uint8) ptr ast:Type
  mut di = ast:stabGet(stab, name)

  return di != null => di'type || null
/func


func stabFree(stab ptr ast:Symtable)
  if stab != null
    base:mapFreeSpec(stab'syms, ptr base:free, ptr ast:declInfoFree)
    base:free(stab)
  /if
/func


mut TYPE_FUNC      uint16 = 10
mut TYPE_PTR       uint16 = 20
mut TYPE_STRUCT    uint16 = 30
mut TYPE_LOC       uint16 = 40
mut TYPE_BOOL      uint16 = 50
mut TYPE_INT       uint16 = 60
mut TYPE_DATA      uint16 = 70
mut TYPE_RECALIAS  uint16 = 80
mut TYPE_NULL      uint16 = 90
mut TYPE_EMPTY     uint16 = 100
