#  libfork, a base library for the Fork language
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2015
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the
#  licenses expressed under Section 1.12 of the MPL v2.


import ast
import astfn
import kv
import map
import mem
import proc
import platform
import tty
import txt
import utils


func symbolClone(sym ptr ast:Symbol) ptr ast:Symbol
  if sym == null
    return null
  /if

  mut newInst = cast<ptr ast:Symbol>(mem:alloc(size(ast:Symbol)))
  newInst'name = txt:strclone(sym'name)
  newInst'type = sym'type

  return newInst
/func

func symbolEquals(sym1,sym2 ptr ast:Symbol) bool
  return txt:strequals(sym1'name, sym2'name) and ast:typeEquals(sym1'type, sym2'type)
/func


func symbolFree(sym ptr ast:Symbol)
  if sym != null
    mem:free(sym'name)

    mem:free(sym)
  /if
/func


func symbolNew(name ptr uint8, type ptr ast:Type) ptr ast:Symbol
  mut sym = cast<ptr ast:Symbol>(mem:alloc(size(ast:Symbol)))

  sym'name = txt:strclone(name)
  sym'type = type

  return sym
/func


func symbolListClone(pool ptr mem:FreePool, symList ptr kv:KVList) ptr kv:KVList
  if symList == null
    return null
  /if

  mut len = kv:kvLen(symList)
  mut ret = kv:strkvNew()
  mut i uintptr = 0

  while i < len
    mut elem = kv:kvGetAt(symList, i)
    mut newStr = txt:strclone(cast<ptr uint8>(elem'key))
    mut newType = astfn:typeClone(pool, cast<ptr ast:Type>(elem'value))

    kv:kvPut(ret, newStr, newType)

    i++
  /while

  return ret
/func


func typeClone(pool ptr mem:FreePool, type ptr ast:Type) ptr ast:Type
  if type == null
    return null
  /if

  mut newInst = cast<ptr ast:Type>(mem:memcpy(mem:fpAlloc(pool, size(ast:Type)), type, size(ast:Type)))
  newInst'moduleName = txt:strclone(type'moduleName)
  newInst'name = txt:strclone(type'name)
  newInst'retType = astfn:typeClone(pool, type'retType)
  newInst'members = symbolListClone(pool, type'members)

  return newInst
/func


func typeEqualsList(list1, list2 ptr kv:KVList) bool
  mut len = kv:kvLen(list1)

  if len != kv:kvLen(list2)
    return false
  /if

  mut i uintptr = 0

  while i < len
    mut pair1 = kv:kvGetAt(list1, i)
    mut pair2 = kv:kvGetAt(list2, i)

    mut name1 = cast<ptr uint8>(pair1'key)
    mut name2 = cast<ptr uint8>(pair2'key)

    mut type1 = cast<ptr ast:Type>(pair1'value)
    mut type2 = cast<ptr ast:Type>(pair2'value)

    if !txt:strequals(name1, name2) or !ast:typeEquals(type1, type2)
      return false
    /if

    i++
  /while

  return true
/func


func typeEquals(type1, type2 ptr ast:Type) bool
  if type1 == null or type2 == null
    return false
  /if

  if type1'name != null and type2'name != null
    mut res = txt:strequals(type1'name, type2'name)

    if res and type1'moduleName != null and type2'moduleName != null
      res = txt:strequals(type1'moduleName, type2'moduleName)
    /if

    return res
  /if

  if type1'type != type2'type
    return false
  /if

  if type1'type == ast:TYPE_FUNC
    return typeEquals(type1'retType, type2'retType) and typeEqualsList(type1'members, type2'members)
  else
    if type1'type == ast:TYPE_PTR
      return typeEquals(type1'retType, type2'retType)
    else
      if type1'type == ast:TYPE_STRUCT
        return typeEqualsList(type1'members, type2'members)
      else
        if type1'type == ast:TYPE_LOC
          return typeEquals(type1'retType, type2'retType) and type1'itemCount == type2'itemCount
        else
          if type1'type == ast:TYPE_BOOL
            return true
          else
            if type1'type == ast:TYPE_INT
              return type1'isSigned == type2'isSigned and type1'typeSize == type2'typeSize
            else
              if type1'type == ast:TYPE_DATA
                return true
              else
                if type1'type == ast:TYPE_NULL
                  return true
                else
                  tty:errln("Unreachable: unknown type comparison")
                  proc:abort()
                /if
              /if
            /if
          /if
        /if
      /if
    /if
  /if
/func


func typeFree(type ptr ast:Type)
  if type != null
    mem:free(type'moduleName)
    mem:free(type'name)

    if type'members != null
      kv:kvFree(type'members)
    /if

    mem:free(type)
  /if
/func


func typeIsBool(type ptr ast:Type) bool
  return type != null and type'type == ast:TYPE_BOOL
/func


func typeIsData(type ptr ast:Type) bool
  return type != null and type'type == ast:TYPE_DATA
/func


func typeIsFunc(type ptr ast:Type) bool
  return type != null and type'type == ast:TYPE_FUNC
/func


func typeIsInt(type ptr ast:Type) bool
  return type != null and type'type == ast:TYPE_INT
/func


func typeIsLoc(type ptr ast:Type) bool
  return type != null and type'type == ast:TYPE_LOC
/func


func typeIsNull(type ptr ast:Type) bool
  return type != null and type'type == ast:TYPE_NULL
/func


func typeIsPtr(type ptr ast:Type) bool
  return type != null and (type'type == ast:TYPE_PTR or type'type == ast:TYPE_DATA)
/func


func typeIsStruct(type ptr ast:Type) bool
  return type != null and type'type == ast:TYPE_STRUCT
/func


func typeNew(pool ptr mem:FreePool,
             type uint16,
             moduleName, name ptr uint8,
             isSigned bool,
             typeSize, typeAlign intptr,
             itemCount uintptr,
             retType ptr ast:Type,
             members ptr kv:KVList) ptr ast:Type

  mut location = pool != null => mem:fpAlloc(pool, size(ast:Type)) || mem:alloc(size(ast:Type))
  mut ret = cast<ptr ast:Type>(location)

  ret'type = type
  ret'moduleName = txt:strclone(moduleName)
  ret'name = txt:strclone(name)
  ret'isSigned = isSigned
  ret'typeSize = typeSize
  ret'typeAlign = typeAlign
  ret'itemCount = itemCount
  ret'retType = retType
  ret'members = members

  return ret
/func


func typeNewBuiltin(type uint16,
                    name ptr uint8,
                    isSigned bool,
                    typeSize, typeAlign intptr,
                    itemCount uintptr,
                    retType ptr ast:Type,
                    members ptr kv:KVList) ptr ast:Type

  mut ret = typeNew(null, type, null, name, isSigned, typeSize, typeAlign, itemCount, retType, members)
  ret'builtin = true

  return ret
/func


func typeNewBuiltinInt(name ptr uint8, len uint8, isSigned bool) ptr ast:Type
  return typeNewBuiltin(ast:TYPE_INT, name, isSigned, len, len, 1, null, null)
/func


func typeNewBuiltinBool() ptr ast:Type
  return typeNewBuiltin(ast:TYPE_BOOL, "bool", false, 1, 1, 1, null, null)
/func


func typeNewBuiltinData() ptr ast:Type
  return typeNewBuiltin(ast:TYPE_DATA, "data", false, platform:ptrSize, platform:ptrSize, 1, null, null)
/func


func typeNewBuiltinEmpty() ptr ast:Type
  return typeNewBuiltin(ast:TYPE_EMPTY, "\0", false, 0, 0, 0, null, null)
/func


func typeNewBuiltinNull() ptr ast:Type
  return typeNewBuiltin(ast:TYPE_NULL, "null", false, platform:ptrSize, platform:ptrSize, 1, null, null)
/func


func typeNewBuiltinString(uint8t ptr ast:Type) ptr ast:Type
  return astfn:typeNewPtr(null, null, null, uint8t)
/func


func builtinSetNew() ptr map:Map

  mut ret = map:strmapNew()
  mut uint8t = typeNewBuiltinInt("uint8", 1, false)

  map:mapPut(ret, "uint8", uint8t, map:FREE_VALUE)
  map:mapPut(ret, "uint16", typeNewBuiltinInt("uint16", 2, false), map:FREE_VALUE)
  map:mapPut(ret, "uint32", typeNewBuiltinInt("uint32", 4, false), map:FREE_VALUE)
  map:mapPut(ret, "uint64", typeNewBuiltinInt("uint64", 8, false), map:FREE_VALUE)
  map:mapPut(ret, "int8", typeNewBuiltinInt("int8", 1, true), map:FREE_VALUE)
  map:mapPut(ret, "int16", typeNewBuiltinInt("int16", 2, true), map:FREE_VALUE)
  map:mapPut(ret, "int32", typeNewBuiltinInt("int32", 4, true), map:FREE_VALUE)
  map:mapPut(ret, "int64", typeNewBuiltinInt("int64", 8, true), map:FREE_VALUE)
  map:mapPut(ret, "uintptr", typeNewBuiltinInt("uintptr", platform:ptrSize, false), map:FREE_VALUE)
  map:mapPut(ret, "intptr", typeNewBuiltinInt("intptr", platform:ptrSize, true), map:FREE_VALUE)
  map:mapPut(ret, "bool", typeNewBuiltinBool(), map:FREE_VALUE)
  map:mapPut(ret, "data", typeNewBuiltinData(), map:FREE_VALUE)
  map:mapPut(ret, "\0", typeNewBuiltinEmpty(), map:FREE_VALUE)
  map:mapPut(ret, "null", typeNewBuiltinNull(), map:FREE_VALUE)
  map:mapPut(ret, "ptr uint8", typeNewBuiltinString(uint8t), map:FREE_VALUE)

  return ret
/func


func typeNewFunc(pool ptr mem:FreePool, moduleName, name ptr uint8, retVal ptr ast:Type, members ptr kv:KVList) ptr ast:Type
  return typeNew(pool, ast:TYPE_FUNC, moduleName, name, false, 0, 0, 0, retVal, members)
/func


func typeNewLoc(pool ptr mem:FreePool, moduleName, name ptr uint8, itemCount uintptr, retVal ptr ast:Type) ptr ast:Type
  return typeNew(pool, ast:TYPE_LOC, moduleName, name, false, retVal'typeSize * cast<intptr>(itemCount), retVal'typeAlign, itemCount, retVal, null)
/func


func typeNewPtr(pool ptr mem:FreePool, moduleName, name ptr uint8, retVal ptr ast:Type) ptr ast:Type
  return typeNew(pool, ast:TYPE_PTR, moduleName, name, false, platform:ptrSize, platform:ptrSize, 1, retVal, null)
/func


alias AlignResult struct(typeAlign,typeSize intptr)

# members is a list of ast:Symbol
func typeCalculateAlign(members ptr kv:KVList) AlignResult
  mut ret AlignResult
  ret'typeAlign = 1
  ret'typeSize  = 0

  mut i uintptr = 0
  mut len = kv:kvLen(members)

  while i < len
    mut member = cast<ptr ast:Type>(kv:kvGetAt(members, i)'value)

    # calculate the alignment offset of the member against the current starting address.
    mut offset = ret'typeSize mod member'typeAlign

    # if offset is not 0, then the member to be inserted is currently misaligned.
    # padding is needed.
    if offset != 0
      mut padding = member'typeAlign - offset
      ret'typeSize = ret'typeSize + padding
    /if

    ret'typeSize = ret'typeSize + member'typeSize
    ret'typeAlign = (member'typeAlign > ret'typeAlign) => member'typeAlign || ret'typeAlign

    i++
  /while

  # for being sequentially stackable, structs must be padded at the end, according to their alignment.
  mut finalOffset = ret'typeSize mod ret'typeAlign

  # if there is misalignment at the end of the struct, we need additional padding to reach
  # a size which is a multiple of the alignment value.
  if finalOffset > 0
    ret'typeSize = ret'typeSize + (ret'typeAlign - finalOffset)
  /if

  return ret
/func


func typeNewRecursiveAlias(pool ptr mem:FreePool, moduleName, name ptr uint8) ptr ast:Type
  return typeNew(pool, ast:TYPE_RECALIAS, moduleName, name, false, -1, -1, 0, null, null)
/func


func typeNewStruct(pool ptr mem:FreePool, moduleName, name ptr uint8, members ptr kv:KVList) ptr ast:Type
  mut alignInfo = typeCalculateAlign(members)

  return typeNew(pool, ast:TYPE_STRUCT, moduleName, name, false, alignInfo'typeSize, alignInfo'typeAlign, 1, null, members)
/func


func typeSetAlias(type ptr ast:Type, moduleName, name ptr uint8)
  if type != null
    type'moduleName = txt:strclone(moduleName)
    type'name = txt:strclone(name)
  /if
/func


func typeSetBoundaries(type ptr ast:Type, begin,end ast:Line)
  if type != null
    type'begin = begin
    type'end = end
  /if
/func


func declInfoFree(declInfo ptr ast:DeclInfo)
  mem:free(declInfo)
/func


func declInfoNew(declType uint16, type ptr ast:Type) ptr ast:DeclInfo
  mut ret = cast<ptr ast:DeclInfo>(mem:alloc(size(ast:DeclInfo)))
  ret'declType = declType
  ret'type = type

  return ret
/func


func stabNew() ptr ast:Symtable
  mut stab = cast<ptr ast:Symtable>(mem:zalloc(size(ast:Symtable)))

  stab'syms = map:strmapNew()

  return stab
/func


func stabAdd(stab ptr ast:Symtable, name ptr uint8, type ptr ast:Type, symType uint16)
  map:mapPut(stab'syms, txt:strclone(name), astfn:declInfoNew(symType, type), map:FREE_KEY | map:FREE_VALUE)
/func


func stabGet(stab ptr ast:Symtable, name ptr uint8) ptr ast:DeclInfo
  mut value ptr ast:DeclInfo = null

  map:mapGet(stab'syms, name, ptr value)

  return value
/func


func stabTypeof(stab ptr ast:Symtable, name ptr uint8) ptr ast:Type
  mut di = ast:stabGet(stab, name)

  return di != null => di'type || null
/func


func stabFree(stab ptr ast:Symtable)
  if stab != null
    map:mapFreeSpec(stab'syms, ptr mem:free, ptr astfn:declInfoFree)
    mem:free(stab)
  /if
/func


mut TYPE_FUNC      uint16 = 10
mut TYPE_PTR       uint16 = 20
mut TYPE_STRUCT    uint16 = 30
mut TYPE_LOC       uint16 = 40
mut TYPE_BOOL      uint16 = 50
mut TYPE_INT       uint16 = 60
mut TYPE_DATA      uint16 = 70
mut TYPE_RECALIAS  uint16 = 80
mut TYPE_NULL      uint16 = 90
mut TYPE_EMPTY     uint16 = 100
