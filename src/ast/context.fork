#  libfork, a base library for the Fork language
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2015
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the
#  licenses expressed under Section 1.12 of the MPL v2.

import ast
import base
import ctx
import sema
import synt
import text
import utils


func findImport(ctx ptr ctx:Context, importName ptr ast:StringDef, importAst ptr ptr ast:PNode) ptr base:List
  mut fordName = text:strappend(importName'name, ".ford")

  mut len = base:listLen(ctx'fordPaths)

  mut i uintptr = 0

  while i < len
    mut path = cast<ptr uint8>(val base:listGet(ctx'fordPaths, i))
    mut joinedPath = base:pathJoin(path, fordName)

    if base:pathExists(joinedPath)

      mut ret = sema:semaParse(ctx, joinedPath, importAst)

      base:free(joinedPath)
      base:free(fordName)
      return ret
    /if

    base:free(joinedPath)

    i++
  /while

  mut errors = base:listNew()

  mut toGlue [4] ptr uint8

  toGlue[0] = "Can't find "
  toGlue[1] = importName'name
  toGlue[2] = " in the given FORDPATHS"
  toGlue[3] = null

  mut glued = text:strglue(ptr toGlue[0])

  base:listAppend(errors, utils:issueNew(utils:ISSUE_ERR, importName'begin, ctx'currentFile, glued))

  base:free(fordName)
  base:free(glued)

  return errors
/func


func contextImport(ctx ptr ctx:Context, importName ptr ast:StringDef, value ptr ptr ast:PNode) ptr base:List

  if !base:mapGet(ctx'imports, importName, value)
    mut errors = findImport(ctx, importName, value)
    if base:listLen(errors) == 0
      base:mapPut(ctx'imports, text:strclone(importName'name), val value, base:FREE_KEY | base:FREE_VALUE)
    /if

    return errors
  else
    return base:listNew()
  /if

/func


func contextImportAll(ctx ptr ctx:Context, imports ptr base:List) ptr base:List
  mut len = base:listLen(imports)
  mut i uintptr = 0

  while i < len
    mut value ptr ast:PNode
    mut importName = cast<ptr ast:StringDef>(val base:listGet(imports, i))
    mut errs = contextImport(ctx, importName, ptr value)

    if base:listLen(errs) != 0
      return errs
    /if

    i++
  /while

  return base:listNew()
/func


func envExtractFordPaths() ptr base:List
  mut list = base:listNew()

  mut paths = base:getenv("FORDPATHS")
  if paths != null
    mut tkz = text:tokenizerNew(paths, 58) #`:`
    mut path ptr uint8

    while (path = text:tokenizerNext(tkz)) != null
      base:listAppend(list, path)
    /while

  /if

  return list
/func


func contextGetImport(ctx ptr ctx:Context, name ptr uint8) ptr ast:PRoot
  mut ret ptr ast:PRoot = null

  base:mapGet(ctx'imports, name, ptr ret)

  return ret
/func


func contextFree(ctx ptr ctx:Context)
  if ctx != null
    if ctx'imports != null
      base:mapFreeSpec(ctx'imports, ptr base:free, cast<ptr func(item data)>(ptr ast:pnodeFree))
    /if

    if ctx'fordPaths != null
      base:listFreeAll(ctx'fordPaths, ptr base:free)
    /if

    base:mapFreeSpec(ctx'builtins, null, cast<ptr func(item data)>(ptr ast:typeFree))

    base:free(ctx'currentFile)
    base:free(ctx)
  /if
/func


func contextSetCurrentFile(ctx ptr ctx:Context, filename ptr uint8)
  base:free(ctx'currentFile)

  ctx'currentFile = text:strclone(filename)
/func


func contextNew() ptr ctx:Context
  mut ctx = cast<ptr ctx:Context>(base:zalloc(size(ctx:Context)))
  ctx'imports = base:strmapNew()

  ctx'fordPaths = envExtractFordPaths()
  ctx'builtins = ast:builtinSetNew()
  return ctx
/func


func contextMatchBuiltin(ctx ptr ctx:Context, name ptr uint8) ptr ast:Type
  mut value ptr ast:Type = null

  base:mapGet(ctx'builtins, name, ptr value)
  return value
/func
