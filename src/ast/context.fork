#  Second Step - Experimental Fork Compiler
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2014
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the
#  licenses expressed under Section 1.12 of the MPL v2.

import ast
import ctx
import sema
import spring
import synt
import utils


func findImport(ctx ptr ctx:Context, importName ptr ast:StringDef, importAst ptr ptr ast:PNode) ptr spring:List
  mut fordName = spring:strappend(importName'name, ".ford")

  mut len = spring:listLen(ctx'fordPaths)

  mut i uintptr = 0

  while i < len
    mut path = cast<ptr uint8>(val spring:listGet(ctx'fordPaths, i))
    mut joinedPath = spring:pathJoin(path, fordName)

    if spring:pathExists(joinedPath)

      mut ret = sema:semaParse(ctx, joinedPath, importAst)

      spring:free(joinedPath)
      spring:free(fordName)
      return ret
    /if

    spring:free(joinedPath)

    i++
  /while

  mut errors = spring:listNew()

  mut toGlue [4] ptr uint8

  toGlue[0] = "Can't find "
  toGlue[1] = importName'name
  toGlue[2] = " in the given FORDPATHS"
  toGlue[3] = null

  mut glued = spring:strglue(ptr toGlue[0])

  spring:listAppend(errors, utils:issueNew(utils:ISSUE_ERR, importName'begin, ctx'currentFile, glued))

  spring:free(fordName)
  spring:free(glued)

  return errors
/func


func contextImport(ctx ptr ctx:Context, importName ptr ast:StringDef, value ptr ptr ast:PNode) ptr spring:List

  if !spring:mapGet(ctx'imports, importName, value)
    mut errors = findImport(ctx, importName, value)
    if spring:listLen(errors) == 0
      spring:mapPut(ctx'imports, spring:strclone(importName'name), val value, spring:FREE_KEY | spring:FREE_VALUE)
    /if

    return errors
  else
    return spring:listNew()
  /if

/func


func contextImportAll(ctx ptr ctx:Context, imports ptr spring:List) ptr spring:List
  mut len = spring:listLen(imports)
  mut i uintptr = 0

  while i < len
    mut value ptr ast:PNode
    mut importName = cast<ptr ast:StringDef>(val spring:listGet(imports, i))
    mut errs = contextImport(ctx, importName, ptr value)

    if spring:listLen(errs) != 0
      return errs
    /if

    i++
  /while

  return spring:listNew()
/func


func envExtractFordPaths() ptr spring:List
  mut list = spring:listNew()

  mut paths = spring:getenv("FORDPATHS")
  if paths != null
    mut tkz = utils:tokenizerNew(paths, 58) #`:`
    mut path ptr uint8

    while (path = utils:tokenizerNext(tkz)) != null
      spring:listAppend(list, path)
    /while

  /if

  return list
/func


func contextGetImport(ctx ptr ctx:Context, name ptr uint8) ptr ast:PRoot
  mut ret ptr ast:PRoot = null

  spring:mapGet(ctx'imports, name, ptr ret)

  return ret
/func


func contextFree(ctx ptr ctx:Context)
  if ctx != null
    if ctx'imports != null
      spring:mapFreeSpec(ctx'imports, ptr spring:free, cast<ptr func(item data)>(ptr ast:pnodeFree))
    /if

    if ctx'fordPaths != null
      spring:listFreeAll(ctx'fordPaths, ptr spring:free)
    /if

    spring:mapFreeSpec(ctx'builtins, null, cast<ptr func(item data)>(ptr ast:typeFree))

    spring:free(ctx'currentFile)
    spring:free(ctx)
  /if
/func


func contextSetCurrentFile(ctx ptr ctx:Context, filename ptr uint8)
  spring:free(ctx'currentFile)

  ctx'currentFile = spring:strclone(filename)
/func


func contextNew() ptr ctx:Context
  mut ctx = cast<ptr ctx:Context>(spring:zalloc(size(ctx:Context)))
  ctx'imports = spring:strmapNew()

  ctx'fordPaths = envExtractFordPaths()
  ctx'builtins = ast:builtinSetNew()
  return ctx
/func


func contextMatchBuiltin(ctx ptr ctx:Context, name ptr uint8) ptr ast:Type
  mut value ptr ast:Type = null

  spring:mapGet(ctx'builtins, name, ptr value)
  return value
/func
