#  Second Step - Experimental Fork Compiler
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2014
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the
#  licenses expressed under Section 1.12 of the MPL v2.

import ast
import lex
import spring
import utils

func printPadding(depth uintptr)
  mut i uintptr = 0

  while i < depth
    spring:out("    ")
    i++
  /while

/func


func lineDump(line utils:Line)
  spring:outint(line'line)
  spring:out(":")
  spring:outint(line'pos)
/func

func linesDump(begin,end utils:Line)
  spring:out("(at ")
  lineDump(begin)
  spring:out("-")
  if begin'line == end'line
    spring:outint(end'pos)
  else
    lineDump(end)
  /if
  spring:out(")")
/func


func symbolDump(sym ptr ast:Symbol)
  if sym == null
    return
  /if

  spring:out(sym'name)
  spring:out(" :: ")
  if sym'type != null
    ast:typeDump(sym'type)
  else
    spring:out("<inferred>")
  /if
/func


func typeDescrDumpStructuredDataArgs(args ptr spring:List)
  if args == null
    spring:out("<null>")
    return
  /if

  mut len = spring:listLen(args)
  mut first = true
  mut i uintptr = 0

  spring:out("(")

  while i < len
    if first
      first = false
    else
      spring:out(", ")
    /if

    mut sym = cast<ptr ast:Symbol>(val spring:listGet(args, i))
    symbolDump(sym)

    i++
  /while

  spring:out(")")
/func


func typeDescrDump(typeDescr ptr ast:TypeDescr)
  if typeDescr == null
    spring:out("<null>")
    return
  /if

  mut type = typeDescr'type

  if type == ast:TYPE_FUNC
    spring:out("func")

    if typeDescr'arguments != null

      typeDescrDumpStructuredDataArgs(typeDescr'arguments)
      spring:outch(32)
    else
      spring:out("()")
    /if

    if typeDescr'retType != null
      ast:typeDump(typeDescr'retType)
    /if
  /if

  if type == ast:TYPE_ID
    return
  /if

  if type == ast:TYPE_LOC
    spring:out("[")
    spring:outint(typeDescr'length)
    spring:out("] ")
    ast:typeDump(typeDescr'retType)
  /if

  if type == ast:TYPE_PTR
    spring:out("ptr ")
    ast:typeDump(typeDescr'retType)
  /if

  if type == ast:TYPE_STRUCT
    spring:out("struct ")
    typeDescrDumpStructuredDataArgs(typeDescr'arguments)
  /if
/func


func typeDump(type ptr ast:Type)
  if type == null
    spring:out("<null>")
    return
  /if

  if type'name != null
    if type'moduleName != null
      spring:out(type'moduleName)
      spring:outch(58)
    /if
    spring:out(type'name)
  /if

  if type'descr != null

    typeDescrDump(cast<ptr ast:TypeDescr>(type'descr))
  /if
/func


func pnodeTypeToString(ptype uint16) ptr uint8

  if ptype == ast:PROOT
    return "Root"
  /if

  if ptype == ast:PENTRY
    return "Entry"
  /if

  if ptype == ast:PEXPR
    return "Expression"
  /if

  if ptype == ast:PFUNCTION
    return "Function"
  /if

  if ptype == ast:PALIAS
    return "Alias"
  /if

  if ptype == ast:PDECL
    return "Decl"
  /if

  if ptype == ast:PMUT
    return "Mut"
  /if

  if ptype == ast:PBREAK
    return "Break"
  /if

  if ptype == ast:PCONTINUE
    return "Continue"
  /if

  if ptype == ast:PRETURN
    return "Return"
  /if

  if ptype == ast:PIF
    return "If"
  /if

  if ptype == ast:PIFELSE
    return "IfElse"
  /if

  if ptype == ast:PWHILE
    return "While"
  /if

  if ptype == ast:PBLOCK
    return "Block"
  /if

  return "<UNKNOWN BLOCK>"
/func


func prootDumpInfo(proot ptr ast:PRoot, depth uintptr)
  if proot'moduleName != null
    spring:out(" [module: ")
    spring:out(proot'moduleName'name)
    spring:outch(32)
    linesDump(proot'moduleName'begin, proot'moduleName'end)
    spring:out("]")
  /if

  spring:outch(10)

  mut len = spring:vectLen(proot'imports)
  if len > 0
    printPadding(depth)
    spring:outln("Imports: ")

    mut i uintptr = 0

    while i < len
      printPadding(depth + 1)
      mut imp = cast<ptr ast:StringDef>(val spring:vectGet(proot'imports, i))

      spring:out(imp'name)
      spring:outch(32)
      linesDump(imp'begin, imp'end)
      spring:outch(10)

      i++
    /while
  /if
/func


func pdeclDumpInfo(pdecl ptr ast:PDecl, depth uintptr)
  spring:outch(10)
  printPadding(depth + 1)

  symbolDump(pdecl'sym)
/func


func pexprDumpInfo(pexpr ptr ast:PExpr, depth uintptr)
  mut tok lex:Token
  tok'type = pexpr'opType

  spring:out(": ")

  if pexpr'opType == lex:ID
    spring:out("an id \"")
    spring:out(cast<ptr uint8>(pexpr'node'value))
    spring:out("\"")
  else
    if pexpr'opType == lex:NUMBER
      spring:outint(pexpr'node'value)
    else
      spring:out(lex:tokenStr(ptr tok))
    /if
  /if
  if pexpr'type != null
    spring:out(", type ")

    typeDump(pexpr'type)
  /if
/func


func pnodeDumpRec(pnode ptr ast:PNode, depth uintptr)

  printPadding(depth)

  spring:out(pnodeTypeToString(pnode'type))
  spring:out(":")

  spring:outch(32)
  linesDump(pnode'begin, pnode'end)

  if ast:isPRoot(pnode)
    prootDumpInfo(cast<ptr ast:PRoot>(pnode), depth)
  /if

  if ast:isPDecl(pnode)
    pdeclDumpInfo(cast<ptr ast:PDecl>(pnode), depth)
  /if

  if ast:isPExpr(pnode)
    pexprDumpInfo(cast<ptr ast:PExpr>(pnode), depth)
  /if

  spring:outch(10)

  mut len = spring:vectLen(pnode'leaves)
  mut i uintptr = 0

  while i < len
    mut child = cast<ptr ast:PNode>(val spring:vectGet(pnode'leaves, i))

    pnodeDumpRec(child, depth + 1)

    i++
  /while

/func


func pnodeDump(pnode ptr ast:PNode)
  pnodeDumpRec(pnode, 0)
/func
