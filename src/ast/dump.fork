#  libfork, a base library for the Fork language
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2015
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the
#  licenses expressed under Section 1.12 of the MPL v2.


module ast


import ast
import kv
import lex
import list
import mem
import tokens
import tty
import txt
import utils


func printPadding(depth uintptr)
  mut i uintptr = 0

  while i < depth
    tty:out("    ")
    i++
  /while

/func


func lineDump(line ast:Line)
  tty:outint(line'line)
  tty:out(":")
  tty:outint(line'pos)
/func

func linesDump(begin,end ast:Line)
  tty:out("(at ")
  lineDump(begin)
  tty:out("-")
  if begin'line == end'line
    tty:outint(end'pos)
  else
    lineDump(end)
  /if
  tty:out(")")
/func


func psymbolDump(psym ptr ast:PSymbol)
  if psym == null
    return
  /if

  tty:out(psym'name)
  tty:out(" :: ")
  if psym'type != null
    ast:ptypeDump(psym'type)
  else
    tty:out("<inferred>")
  /if
/func


func ptypeDescrDumpStructuredDataArgs(args ptr list:List)
  if args == null
    tty:out("<null>")
    return
  /if

  mut len = args.len()
  mut first = true
  mut i uintptr = 0

  tty:out("(")

  while i < len
    if first
      first = false
    else
      tty:out(", ")
    /if

    mut sym = cast<ptr ast:PSymbol>(val args.get(i))
    psymbolDump(sym)

    i++
  /while

  tty:out(")")
/func


func ptypeDescrDump(ptypeDescr ptr ast:PTypeDescr)
  if ptypeDescr == null
    tty:out("<null>")
    return
  /if

  mut ptype = ptypeDescr'type

  if ptype == ast:PTYPE_FUNC
    tty:out("func")

    if ptypeDescr'arguments != null

      ptypeDescrDumpStructuredDataArgs(ptypeDescr'arguments)
      tty:outch(32)
    else
      tty:out("()")
    /if

    if ptypeDescr'retType != null
      ast:ptypeDump(ptypeDescr'retType)
    /if
  /if

  if ptype == ast:PTYPE_ID
    return
  /if

  if ptype == ast:PTYPE_LOC
    tty:out("[")
    tty:outint(ptypeDescr'length)
    tty:out("] ")
    ast:ptypeDump(ptypeDescr'retType)
  /if

  if ptype == ast:PTYPE_PTR
    tty:out("ptr ")
    ast:ptypeDump(ptypeDescr'retType)
  /if

  if ptype == ast:PTYPE_STRUCT
    tty:out("struct ")
    ptypeDescrDumpStructuredDataArgs(ptypeDescr'arguments)
  /if
/func


func ptypeDump(ptype ptr ast:PType)
  if ptype == null
    tty:out("<null>")
    return
  /if

  if ptype'name != null
    if ptype'moduleName != null
      tty:out(ptype'moduleName)
      tty:outch(58)
    /if
    tty:out(ptype'name)
  /if

  if ptype'descr != null

    ptypeDescrDump(ptype'descr)
  /if
/func


func pnodeTypeToString(ptype uint16) ptr uint8

  if ptype == ast:PROOT
    return "Root"
  /if

  if ptype == ast:PENTRY
    return "Entry"
  /if

  if ptype == ast:PEXPR
    return "Expression"
  /if

  if ptype == ast:PFUNCTION
    return "Function"
  /if

  if ptype == ast:PALIAS
    return "Alias"
  /if

  if ptype == ast:PMETHOD
    return "Method"
  /if

  if ptype == ast:PMUT
    return "Mut"
  /if

  if ptype == ast:PBREAK
    return "Break"
  /if

  if ptype == ast:PCONTINUE
    return "Continue"
  /if

  if ptype == ast:PRETURN
    return "Return"
  /if

  if ptype == ast:PIF
    return "If"
  /if

  if ptype == ast:PIFELSE
    return "IfElse"
  /if

  if ptype == ast:PWHILE
    return "While"
  /if

  if ptype == ast:PBLOCK
    return "Block"
  /if

  return "<UNKNOWN BLOCK>"
/func


func prootDumpInfo(proot ptr ast:PRoot, depth uintptr)
  if proot'moduleName != null
    tty:out(" [module: ")
    tty:out(proot'moduleName'name)
    tty:outch(32)
    linesDump(proot'moduleName'begin, proot'moduleName'end)
    tty:out("]")
  /if

  tty:outch(10)

  mut len = proot'imports.len()
  if len > 0
    printPadding(depth)
    tty:outln("Imports: ")

    mut i uintptr = 0

    while i < len
      printPadding(depth + 1)
      mut imp = cast<ptr ast:StringDef>(val proot'imports.get(i))

      tty:out(imp'name)
      tty:outch(32)
      linesDump(imp'begin, imp'end)
      tty:outch(10)

      i++
    /while
  /if
/func


func pdeclDumpInfo(pdecl ptr ast:PDecl, depth uintptr)
  tty:outch(10)
  printPadding(depth + 1)

  psymbolDump(pdecl'sym)

  if pdecl'isDecl
    tty:out(" (decl only)")
  /if

  if pdecl'methodType != null
    tty:outch(10)
    printPadding(depth + 1)

    tty:out("(method of ")

    if pdecl'methodTypeModule != null
      tty:out(pdecl'methodTypeModule)
      tty:out(":")
    /if

    tty:out(pdecl'methodType)
    tty:outln(")")
  /if
/func


func pexprDumpInfo(pexpr ptr ast:PExpr, depth uintptr)
  mut tok lex:Token
  tok'type = pexpr'opType

  tty:out(": ")

  if pexpr'opType == tokens:ID
    tty:out("an id - \"")
    tty:out(cast<ptr uint8>(pexpr'node'value))
    tty:out("\"")
  else
    if pexpr'opType == tokens:NUMBER
      tty:outint(pexpr'node'value)
    else
      if pexpr'opType == tokens:STRING
        tty:out("a string - \"")
        tty:out(cast<ptr uint8>(pexpr'node'value))
        tty:out("\"")
      else
        if pexpr'opType == tokens:OPAR
          tty:out("a function call")
        else
          if pexpr'opType == tokens:OBRAC
            tty:out("an array access")
          else
            tty:out(lex:tokenStr(ptr tok))

            if pexpr'opType == tokens:CAST or pexpr'opType == tokens:SIZE
              tty:out(" to ")

              ptypeDump(cast<ptr ast:PType>(pexpr'node'value))
            /if
          /if
        /if
      /if
    /if
  /if
/func


func pnodeDumpRec(pnode ptr ast:PNode, depth uintptr)

  printPadding(depth)

  tty:out(pnodeTypeToString(pnode'type))
  tty:out(":")

  tty:outch(32)
  linesDump(pnode'begin, pnode'end)

  if ast:isPRoot(pnode)
    prootDumpInfo(cast<ptr ast:PRoot>(pnode), depth)
  /if

  if ast:isPDecl(pnode)
    pdeclDumpInfo(cast<ptr ast:PDecl>(pnode), depth)
  /if

  if ast:isPExpr(pnode)
    pexprDumpInfo(cast<ptr ast:PExpr>(pnode), depth)
  /if

  tty:outch(10)

  mut len = pnode'leaves.len()
  mut i uintptr = 0

  while i < len
    mut child = cast<ptr ast:PNode>(val pnode'leaves.get(i))

    pnodeDumpRec(child, depth + 1)

    i++
  /while

/func


func pnodeDump(pnode ptr ast:PNode)
  pnodeDumpRec(pnode, 0)
/func


func symbolDump(cs ptr txt:Charstash, sym ptr ast:Symbol)
  if sym == null
    return
  /if

  txt:csAppendStr(cs, sym'name)
  txt:csAppend(cs, 32)
  ast:typeDump(cs, sym'type)
/func


func symlistDump(cs ptr txt:Charstash, symlist ptr kv:KVList)

  txt:csAppendStr(cs, "(")

  if symlist?
    mut len = symlist.len()
    mut i uintptr = 0

    while i < len
      mut pair = symlist.getAt(i)
      mut sym ast:Symbol

      sym'name = cast<ptr uint8>(pair'key)
      sym'type = cast<ptr ast:Type>(pair'value)

      ast:symbolDump(cs, ptr sym)

      if i + 1 < len
        txt:csAppendStr(cs, ", ")
      /if

      i++
    /while
  /if

  txt:csAppendStr(cs, ")")
/func


func typeDumpName(cs ptr txt:Charstash, type ptr ast:Type)
  if type'name != null
    txt:csAppendStr(cs, "{ ")

    if type'moduleName != null
      txt:csAppendStr(cs, type'moduleName)
      txt:csAppendStr(cs, ":")
    /if
    txt:csAppendStr(cs, type'name)

    txt:csAppendStr(cs, " } ")
  /if
/func


func typeDump(cs ptr txt:Charstash, type ptr ast:Type)

  if type == null
    return
  /if

  if type'type == ast:TYPE_FUNC
    typeDumpName(cs, type)

    txt:csAppendStr(cs, "func")

    symlistDump(cs, type'members)

    if type'retType != null
      txt:csAppend(cs, 32)

      typeDump(cs, type'retType)
    /if
  else
    if type'type == ast:TYPE_PTR
      txt:csAppendStr(cs, "ptr ")

      typeDump(cs, type'retType)
    else
      if type'type == ast:TYPE_STRUCT
        typeDumpName(cs, type)

        txt:csAppendStr(cs, "struct")

        symlistDump(cs, type'members)
      else
        if type'type == ast:TYPE_LOC
          txt:csAppendStr(cs, "[")
          txt:csAppendInt(cs, type'itemCount)
          txt:csAppendStr(cs, "] ")

          typeDump(cs, type'retType)
        else
          if type'type == ast:TYPE_BOOL
            txt:csAppendStr(cs, "bool")
          else
            if type'type == ast:TYPE_INT
              if not type'isSigned
                txt:csAppendStr(cs, "u")
              /if

              txt:csAppendStr(cs, "int")
              txt:csAppendInt(cs, type'typeSize * 8)

            else
              if type'type == ast:TYPE_DATA
                txt:csAppendStr(cs, "data")
              else
                if type'type == ast:TYPE_RECALIAS
                  txt:csAppendStr(cs, "<< alias to ")
                  txt:csAppendStr(cs, type'name)
                  txt:csAppendStr(cs, " >>")
                else
                  if type'type == ast:TYPE_NULL
                    txt:csAppendStr(cs, "null")
                  else
                    if type'type == ast:TYPE_EMPTY
                      txt:csAppendStr(cs, "<<empty type>>")
                    /if
                  /if
                /if
              /if
            /if
          /if
        /if
      /if
    /if
  /if

/func


func symbolSummarize(cs ptr txt:Charstash, sym ptr ast:Symbol)
  if not sym?
    return
  /if

  txt:csAppendStr(cs, sym'name)
  txt:csAppend(cs, 32)
  ast:typeSummarize(cs, sym'type)
/func


func symlistSummarize(cs ptr txt:Charstash, symlist ptr kv:KVList)

  txt:csAppendStr(cs, "(")

  if symlist?
    mut len = symlist.len()
    mut i uintptr = 0

    while i < len
      mut pair = symlist.getAt(i)
      mut sym ast:Symbol

      sym'name = cast<ptr uint8>(pair'key)
      sym'type = cast<ptr ast:Type>(pair'value)

      ast:symbolSummarize(cs, ptr sym)

      if i + 1 < len
        txt:csAppendStr(cs, ", ")
      /if

      i++
    /while
  /if

  txt:csAppendStr(cs, ")")
/func


func typeSummarize(cs ptr txt:Charstash, type ptr ast:Type)
  if not type?
    txt:csAppendStr(cs, "<<null type please report>>")
    return
  /if

  if type'name?
    if type'moduleName?
      txt:csAppendStr(cs, type'moduleName)
      txt:csAppendStr(cs, ":")
    /if

    txt:csAppendStr(cs, type'name)
    return
  /if

  if type'type == ast:TYPE_PTR
    txt:csAppendStr(cs, "ptr ")
    typeSummarize(cs, type'retType)
    return
  /if

  if type'type == ast:TYPE_LOC
    txt:csAppendStr(cs, "loc[")
    txt:csAppendInt(cs, type'itemCount)
    txt:csAppendStr(cs, "] ")
    typeSummarize(cs, type'retType)
    return
  /if

  if type'type == ast:TYPE_FUNC
    txt:csAppendStr(cs, "func")

    symlistSummarize(cs, type'members)

    if type'retType != null
      txt:csAppend(cs, 32)

      typeSummarize(cs, type'retType)
    /if

    return
  /if


  ast:typeDump(cs, type)
/func


func declDump(prefix,name ptr uint8, type ptr ast:Type)
  tty:out(prefix)
  tty:outch(32)

  tty:out(name)
  tty:outch(32)

  mut cs = txt:csNew(40)
  ast:typeDump(cs, type)
  mut str = txt:csUnwrap(cs)

  tty:out(str)

  mem:free(str)

  tty:outch(10)

  tty:out("[[ size: ")
  tty:outint(type'typeSize)
  tty:out(", align: ")
  tty:outint(type'typeAlign)
  tty:out(" ]]")

  tty:outch(10)
/func
