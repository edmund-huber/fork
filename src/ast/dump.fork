#  libfork, a base library for the Fork language
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2015
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the
#  licenses expressed under Section 1.12 of the MPL v2.


module ast


import ast
import cs
import kv
import lex
import list
import mem
import tokens
import tty
import utils


func printPadding(depth uintptr)
  mut i uintptr = 0

  while i < depth
    tty:out("    ")
    i++
  /while

/func


method ast:Line.dump()
  tty:outint(me'line)
  tty:out(":")
  tty:outint(me'pos)
/method

func linesDump(begin,end ast:Line)
  tty:out("(at ")
  begin.dump()
  tty:out("-")
  if begin'line == end'line
    tty:outint(end'pos)
  else
    end.dump()
  /if
  tty:out(")")
/func


func psymbolDump(psym ptr ast:PSymbol)
  if not psym?
    return
  /if

  tty:out(psym'name)
  tty:out(" :: ")
  if psym'type?
    psym'type.dump()
  else
    tty:out("<inferred>")
  /if
/func


func ptypeDescrDumpStructuredDataArgs(args ptr list:List)
  if not args?
    tty:out("<null>")
    return
  /if

  mut len = args.len()
  mut first = true
  mut i uintptr = 0

  tty:out("(")

  while i < len
    if first
      first = false
    else
      tty:out(", ")
    /if

    mut sym = <ptr ast:PSymbol>(val args.get(i))
    psymbolDump(sym)

    i++
  /while

  tty:out(")")
/func


func pnodeTypeToString(ptype uint16) ptr uint8

  if ptype == ast:PROOT
    return "Root"
  /if

  if ptype == ast:PENTRY
    return "Entry"
  /if

  if ptype == ast:PEXPR
    return "Expression"
  /if

  if ptype == ast:PFUNCTION
    return "Function"
  /if

  if ptype == ast:PALIAS
    return "Alias"
  /if

  if ptype == ast:PMETHOD
    return "Method"
  /if

  if ptype == ast:PMUT
    return "Mut"
  /if

  if ptype == ast:PMUTEXP
    return "Mut expansion"
  /if

  if ptype == ast:PBREAK
    return "Break"
  /if

  if ptype == ast:PCONTINUE
    return "Continue"
  /if

  if ptype == ast:PRETURN
    return "Return"
  /if

  if ptype == ast:PIF
    return "If"
  /if

  if ptype == ast:PIFELSE
    return "IfElse"
  /if

  if ptype == ast:PWHILE
    return "While"
  /if

  if ptype == ast:PBLOCK
    return "Block"
  /if

  return "<UNKNOWN BLOCK>"
/func


func prootDumpInfo(proot ptr ast:PRoot, depth uintptr)
  if proot'moduleName?
    tty:out(" [module: ")
    tty:out(proot'moduleName'name)
    tty:outch(32)
    linesDump(proot'moduleName'begin, proot'moduleName'end)
    tty:out("]")
  /if

  tty:outch(10)

  mut len = proot'imports.len()
  if len > 0
    printPadding(depth)
    tty:outln("Imports: ")

    mut i uintptr = 0

    while i < len
      printPadding(depth + 1)
      mut imp = <ptr ast:StringDef>(val proot'imports.get(i))

      tty:out(imp'name)
      tty:outch(32)
      linesDump(imp'begin, imp'end)
      tty:outch(10)

      i++
    /while
  /if
/func


func pdeclDumpInfo(pdecl ptr ast:PDecl, depth uintptr)
  tty:outch(10)
  printPadding(depth + 1)

  psymbolDump(pdecl'sym)

  if pdecl'isDecl
    tty:out(" (decl only)")
  /if

  if pdecl'methodType?
    tty:outch(10)
    printPadding(depth + 1)

    tty:out("(method of ")

    if pdecl'methodTypeModule?
      tty:out(pdecl'methodTypeModule)
      tty:out(":")
    /if

    tty:out(pdecl'methodType)
    tty:outln(")")
  /if
/func


func pmuldeclDumpInfo(pmuldecl ptr ast:PMulDecl, depth uintptr)
  mut len = pmuldecl'syms.len()
  mut i uintptr = 0

  while i < len
    tty:outch(10)
    printPadding(depth + 1)

    psymbolDump(<ptr ast:PSymbol>(val pmuldecl'syms.get(i)))

    i++
  /while
/func


func pexprDumpInfo(pexpr ptr ast:PExpr, depth uintptr)
  mut tok lex:Token
  tok'type = pexpr'opType

  tty:out(": ")

  if pexpr'opType == tokens:ID
    tty:out("an id - \"")
    tty:out(<ptr uint8>(pexpr'node'value))
    tty:out("\"")
  else
    if pexpr'opType == tokens:NUMBER
      tty:outint(pexpr'node'value)
    else
      if pexpr'opType == tokens:STRING
        tty:out("a string - \"")
        tty:out(<ptr uint8>(pexpr'node'value))
        tty:out("\"")
      else
        if pexpr'opType == tokens:OPAR
          tty:out("a function call")
        else
          if pexpr'opType == tokens:OBRAC
            tty:out("an array access")
          else
            if pexpr'opType == tokens:OCURLY
              tty:out("a struct literal")
            else
              tty:out(lex:tokenStr(ptr tok))

              if pexpr'opType == tokens:CAST or pexpr'opType == tokens:SIZE
                tty:out(" to ")

                <ptr ast:PType>(pexpr'node'value).dump()
              /if
            /if
          /if
        /if
      /if
    /if
  /if
/func


func pnodeDumpRec(pnode ptr ast:PNode, depth uintptr)

  printPadding(depth)

  tty:out(pnodeTypeToString(pnode'type))
  tty:out(":")

  tty:outch(32)
  linesDump(pnode'begin, pnode'end)

  if pnode.isRoot()
    prootDumpInfo(<ptr ast:PRoot>(pnode), depth)
  /if

  if pnode.isDecl()
    pdeclDumpInfo(<ptr ast:PDecl>(pnode), depth)
  /if

  if pnode.isExpr()
    pexprDumpInfo(<ptr ast:PExpr>(pnode), depth)
  /if

  if pnode.isMulDecl()
    pmuldeclDumpInfo(<ptr ast:PMulDecl>(pnode), depth)
  /if

  tty:outch(10)

  mut len = pnode'leaves.len()
  mut i uintptr = 0

  while i < len
    mut child = <ptr ast:PNode>(val pnode'leaves.get(i))

    pnodeDumpRec(child, depth + 1)

    i++
  /while

/func


method ast:PNode.dump()
  pnodeDumpRec(me, 0)
/method


method ast:PModule.dump()
  tty:out("Module ")

  tty:outln(me'name ?? "<main>")

  tty:outln("")

  mut i uintptr = 0
  mut len = me'roots.len()

  while i < len
    mut root = <ptr ast:PRoot>(val me'roots.get(i))

    tty:out("\nfile ")
    tty:out(root'fileName)
    tty:outln(":\n")

    root'node'node.dump()

    i++
  /while
/method


method ast:Symbol.dump(cs ptr cs:Charstash)
  cs.add(me'name)
  cs.addChar(32)
  me'type.dump(cs)
/method


func symlistDump(cs ptr cs:Charstash, symlist ptr kv:KVList)

  if symlist?
    mut len = symlist.len()
    mut i uintptr = 0

    while i < len
      mut pair = symlist.getAt(i)
      mut sym ast:Symbol

      sym'name = <ptr uint8>(pair'key)
      sym'type = <ptr ast:Type>(pair'value)

      sym.dump(cs)

      if i + 1 < len
        cs.add(", ")
      /if

      i++
    /while
  /if
/func


func typeDumpName(cs ptr cs:Charstash, type ptr ast:Type)
  if type'name?
    cs.add("{ ")

    if type'moduleName?
      cs.add(type'moduleName)
      cs.add(":")
    /if
    cs.add(type'name)

    cs.add(" } ")
  /if
/func


method ast:Type.dump(cs ptr cs:Charstash)
  if me'type == ast:TYPE_FUNC
    typeDumpName(cs, me)

    cs.add("func (")

    symlistDump(cs, me'members)

    cs.add(")")

    if me'retType?
      cs.addChar(32)

      me'retType.dump(cs)
    /if
  else
    if me'type == ast:TYPE_PTR
      cs.add("ptr ")

      me'retType.dump(cs)
    else
      if me'type == ast:TYPE_STRUCT
        typeDumpName(cs, me)

        cs.add("{")
        symlistDump(cs, me'members)
        cs.add("}")
      else
        if me'type == ast:TYPE_LOC
          cs.add("[")
          cs.addInt(me'itemCount)
          cs.add("] ")

          me'retType.dump(cs)
        else
          if me'type == ast:TYPE_BOOL
            cs.add("bool")
          else
            if me'type == ast:TYPE_INT
              if not me'isSigned
                cs.add("u")
              /if

              cs.add("int")
              cs.addInt(me'typeSize * 8)

            else
              if me'type == ast:TYPE_DATA
                cs.add("data")
              else
                if me'type == ast:TYPE_RECALIAS
                  cs.add("<< alias to ")
                  cs.add(me'name)
                  cs.add(" >>")
                else
                  if me'type == ast:TYPE_NULL
                    cs.add("null")
                  else
                    if me'type == ast:TYPE_EMPTY
                      cs.add("<<empty type>>")
                    /if
                  /if
                /if
              /if
            /if
          /if
        /if
      /if
    /if
  /if

/method


method ast:Symbol.summarize(cs ptr cs:Charstash)
  cs.add(me'name)
  cs.addChar(32)
  me'type.summarize(cs)
/method


func symlistSummarize(cs ptr cs:Charstash, symlist ptr kv:KVList)

  if symlist?
    mut len = symlist.len()
    mut i uintptr = 0

    while i < len
      mut pair = symlist.getAt(i)
      mut sym ast:Symbol

      sym'name = <ptr uint8>(pair'key)
      sym'type = <ptr ast:Type>(pair'value)

      sym.summarize(cs)

      if i + 1 < len
        cs.add(", ")
      /if

      i++
    /while
  /if
/func


method ast:Type.summarize(cs ptr cs:Charstash)
  if me'name?
    if me'moduleName?
      cs.add(me'moduleName)
      cs.add(":")
    /if

    cs.add(me'name)
    return
  /if

  if me.isPtr()
    cs.add("ptr ")
    me'retType.summarize(cs)
    return
  /if

  if me.isLoc()
    cs.add("loc[")
    cs.addInt(me'itemCount)
    cs.add("] ")
    me'retType.summarize(cs)
    return
  /if

  if me.isFunc()
    cs.add("func (")
    symlistSummarize(cs, me'members)
    cs.add(")")

    if me'retType?
      cs.addChar(32)

      me'retType.summarize(cs)
    /if

    return
  /if

  if me.isStruct()
    cs.add("{")
    symlistSummarize(cs, me'members)
    cs.add("}")

    return
  /if

  me.dump(cs)
/method


func declDump(prefix,name ptr uint8, type ptr ast:Type)
  tty:out(prefix)
  tty:outch(32)

  tty:out(name)
  tty:outch(32)

  mut cs = cs:new(40)
  type.dump(cs)
  mut str = cs:unwrap(cs)

  tty:out(str)

  mem:free(str)

  tty:outch(10)

  tty:out("[[ size: ")
  tty:outint(type'typeSize)
  tty:out(", align: ")
  tty:outint(type'typeAlign)
  tty:out(" ]]")

  tty:outch(10)
/func


method ast:PTypeDescr.dump()
  mut ptype = me'type

  if ptype == ast:PTYPE_FUNC
    tty:out("func")

    if me'arguments?

      ptypeDescrDumpStructuredDataArgs(me'arguments)
      tty:outch(32)
    else
      tty:out("()")
    /if

    if me'retType?
      me'retType.dump()
    /if
  /if

  if ptype == ast:PTYPE_ID
    return
  /if

  if ptype == ast:PTYPE_LOC
    tty:out("[")
    tty:outint(me'length)
    tty:out("] ")
    me'retType.dump()
  /if

  if ptype == ast:PTYPE_PTR
    tty:out("ptr ")
    me'retType.dump()
  /if

  if ptype == ast:PTYPE_STRUCT
    tty:out("struct ")
    ptypeDescrDumpStructuredDataArgs(me'arguments)
  /if
/method


method ast:PType.dump()
  if me'name?
    if me'moduleName?
      tty:out(me'moduleName)
      tty:outch(58)
    /if
    tty:out(me'name)
  /if

  if me'descr?
    me'descr.dump()
  /if
/method
