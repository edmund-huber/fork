#  libfork, a base library for the Fork language
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2015
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the
#  licenses expressed under Section 1.12 of the MPL v2.


module ast


import ast
import cs
import kv
import lex
import list
import mem
import tokens
import tty
import utils


func printPadding(depth uintptr)
  mut i uintptr = 0

  while i < depth
    tty:out("    ")
    i++
  /while

/func


func lineDump(line ast:Line)
  tty:outint(line'line)
  tty:out(":")
  tty:outint(line'pos)
/func

func linesDump(begin,end ast:Line)
  tty:out("(at ")
  lineDump(begin)
  tty:out("-")
  if begin'line == end'line
    tty:outint(end'pos)
  else
    lineDump(end)
  /if
  tty:out(")")
/func


func psymbolDump(psym ptr ast:PSymbol)
  if psym == null
    return
  /if

  tty:out(psym'name)
  tty:out(" :: ")
  if psym'type != null
    ast:ptypeDump(psym'type)
  else
    tty:out("<inferred>")
  /if
/func


func ptypeDescrDumpStructuredDataArgs(args ptr list:List)
  if args == null
    tty:out("<null>")
    return
  /if

  mut len = args.len()
  mut first = true
  mut i uintptr = 0

  tty:out("(")

  while i < len
    if first
      first = false
    else
      tty:out(", ")
    /if

    mut sym = cast<ptr ast:PSymbol>(val args.get(i))
    psymbolDump(sym)

    i++
  /while

  tty:out(")")
/func


func ptypeDescrDump(ptypeDescr ptr ast:PTypeDescr)
  if ptypeDescr == null
    tty:out("<null>")
    return
  /if

  mut ptype = ptypeDescr'type

  if ptype == ast:PTYPE_FUNC
    tty:out("func")

    if ptypeDescr'arguments != null

      ptypeDescrDumpStructuredDataArgs(ptypeDescr'arguments)
      tty:outch(32)
    else
      tty:out("()")
    /if

    if ptypeDescr'retType != null
      ast:ptypeDump(ptypeDescr'retType)
    /if
  /if

  if ptype == ast:PTYPE_ID
    return
  /if

  if ptype == ast:PTYPE_LOC
    tty:out("[")
    tty:outint(ptypeDescr'length)
    tty:out("] ")
    ast:ptypeDump(ptypeDescr'retType)
  /if

  if ptype == ast:PTYPE_PTR
    tty:out("ptr ")
    ast:ptypeDump(ptypeDescr'retType)
  /if

  if ptype == ast:PTYPE_STRUCT
    tty:out("struct ")
    ptypeDescrDumpStructuredDataArgs(ptypeDescr'arguments)
  /if
/func


func ptypeDump(ptype ptr ast:PType)
  if ptype == null
    tty:out("<null>")
    return
  /if

  if ptype'name != null
    if ptype'moduleName != null
      tty:out(ptype'moduleName)
      tty:outch(58)
    /if
    tty:out(ptype'name)
  /if

  if ptype'descr != null

    ptypeDescrDump(ptype'descr)
  /if
/func


func pnodeTypeToString(ptype uint16) ptr uint8

  if ptype == ast:PROOT
    return "Root"
  /if

  if ptype == ast:PENTRY
    return "Entry"
  /if

  if ptype == ast:PEXPR
    return "Expression"
  /if

  if ptype == ast:PFUNCTION
    return "Function"
  /if

  if ptype == ast:PALIAS
    return "Alias"
  /if

  if ptype == ast:PMETHOD
    return "Method"
  /if

  if ptype == ast:PMUT
    return "Mut"
  /if

  if ptype == ast:PBREAK
    return "Break"
  /if

  if ptype == ast:PCONTINUE
    return "Continue"
  /if

  if ptype == ast:PRETURN
    return "Return"
  /if

  if ptype == ast:PIF
    return "If"
  /if

  if ptype == ast:PIFELSE
    return "IfElse"
  /if

  if ptype == ast:PWHILE
    return "While"
  /if

  if ptype == ast:PBLOCK
    return "Block"
  /if

  return "<UNKNOWN BLOCK>"
/func


func prootDumpInfo(proot ptr ast:PRoot, depth uintptr)
  if proot'moduleName != null
    tty:out(" [module: ")
    tty:out(proot'moduleName'name)
    tty:outch(32)
    linesDump(proot'moduleName'begin, proot'moduleName'end)
    tty:out("]")
  /if

  tty:outch(10)

  mut len = proot'imports.len()
  if len > 0
    printPadding(depth)
    tty:outln("Imports: ")

    mut i uintptr = 0

    while i < len
      printPadding(depth + 1)
      mut imp = cast<ptr ast:StringDef>(val proot'imports.get(i))

      tty:out(imp'name)
      tty:outch(32)
      linesDump(imp'begin, imp'end)
      tty:outch(10)

      i++
    /while
  /if
/func


func pdeclDumpInfo(pdecl ptr ast:PDecl, depth uintptr)
  tty:outch(10)
  printPadding(depth + 1)

  psymbolDump(pdecl'sym)

  if pdecl'isDecl
    tty:out(" (decl only)")
  /if

  if pdecl'methodType != null
    tty:outch(10)
    printPadding(depth + 1)

    tty:out("(method of ")

    if pdecl'methodTypeModule != null
      tty:out(pdecl'methodTypeModule)
      tty:out(":")
    /if

    tty:out(pdecl'methodType)
    tty:outln(")")
  /if
/func


func pexprDumpInfo(pexpr ptr ast:PExpr, depth uintptr)
  mut tok lex:Token
  tok'type = pexpr'opType

  tty:out(": ")

  if pexpr'opType == tokens:ID
    tty:out("an id - \"")
    tty:out(cast<ptr uint8>(pexpr'node'value))
    tty:out("\"")
  else
    if pexpr'opType == tokens:NUMBER
      tty:outint(pexpr'node'value)
    else
      if pexpr'opType == tokens:STRING
        tty:out("a string - \"")
        tty:out(cast<ptr uint8>(pexpr'node'value))
        tty:out("\"")
      else
        if pexpr'opType == tokens:OPAR
          tty:out("a function call")
        else
          if pexpr'opType == tokens:OBRAC
            tty:out("an array access")
          else
            if pexpr'opType == tokens:OCURLY
              tty:out("a struct literal")
            else
              tty:out(lex:tokenStr(ptr tok))

              if pexpr'opType == tokens:CAST or pexpr'opType == tokens:SIZE
                tty:out(" to ")

                ptypeDump(cast<ptr ast:PType>(pexpr'node'value))
              /if
            /if
          /if
        /if
      /if
    /if
  /if
/func


func pnodeDumpRec(pnode ptr ast:PNode, depth uintptr)

  printPadding(depth)

  tty:out(pnodeTypeToString(pnode'type))
  tty:out(":")

  tty:outch(32)
  linesDump(pnode'begin, pnode'end)

  if ast:isPRoot(pnode)
    prootDumpInfo(cast<ptr ast:PRoot>(pnode), depth)
  /if

  if ast:isPDecl(pnode)
    pdeclDumpInfo(cast<ptr ast:PDecl>(pnode), depth)
  /if

  if ast:isPExpr(pnode)
    pexprDumpInfo(cast<ptr ast:PExpr>(pnode), depth)
  /if

  tty:outch(10)

  mut len = pnode'leaves.len()
  mut i uintptr = 0

  while i < len
    mut child = cast<ptr ast:PNode>(val pnode'leaves.get(i))

    pnodeDumpRec(child, depth + 1)

    i++
  /while

/func


func pnodeDump(pnode ptr ast:PNode)
  pnodeDumpRec(pnode, 0)
/func


func symbolDump(cs ptr cs:Charstash, sym ptr ast:Symbol)
  if sym == null
    return
  /if

  cs.add(sym'name)
  cs.addChar(32)
  ast:typeDump(cs, sym'type)
/func


func symlistDump(cs ptr cs:Charstash, symlist ptr kv:KVList)

  cs.add("(")

  if symlist?
    mut len = symlist.len()
    mut i uintptr = 0

    while i < len
      mut pair = symlist.getAt(i)
      mut sym ast:Symbol

      sym'name = cast<ptr uint8>(pair'key)
      sym'type = cast<ptr ast:Type>(pair'value)

      ast:symbolDump(cs, ptr sym)

      if i + 1 < len
        cs.add(", ")
      /if

      i++
    /while
  /if

  cs.add(")")
/func


func typeDumpName(cs ptr cs:Charstash, type ptr ast:Type)
  if type'name != null
    cs.add("{ ")

    if type'moduleName != null
      cs.add(type'moduleName)
      cs.add(":")
    /if
    cs.add(type'name)

    cs.add(" } ")
  /if
/func


func typeDump(cs ptr cs:Charstash, type ptr ast:Type)

  if type == null
    return
  /if

  if type'type == ast:TYPE_FUNC
    typeDumpName(cs, type)

    cs.add("func")

    symlistDump(cs, type'members)

    if type'retType != null
      cs.addChar(32)

      typeDump(cs, type'retType)
    /if
  else
    if type'type == ast:TYPE_PTR
      cs.add("ptr ")

      typeDump(cs, type'retType)
    else
      if type'type == ast:TYPE_STRUCT
        typeDumpName(cs, type)

        cs.add("struct")

        symlistDump(cs, type'members)
      else
        if type'type == ast:TYPE_LOC
          cs.add("[")
          cs.addInt(type'itemCount)
          cs.add("] ")

          typeDump(cs, type'retType)
        else
          if type'type == ast:TYPE_BOOL
            cs.add("bool")
          else
            if type'type == ast:TYPE_INT
              if not type'isSigned
                cs.add("u")
              /if

              cs.add("int")
              cs.addInt(type'typeSize * 8)

            else
              if type'type == ast:TYPE_DATA
                cs.add("data")
              else
                if type'type == ast:TYPE_RECALIAS
                  cs.add("<< alias to ")
                  cs.add(type'name)
                  cs.add(" >>")
                else
                  if type'type == ast:TYPE_NULL
                    cs.add("null")
                  else
                    if type'type == ast:TYPE_EMPTY
                      cs.add("<<empty type>>")
                    /if
                  /if
                /if
              /if
            /if
          /if
        /if
      /if
    /if
  /if

/func


func symbolSummarize(cs ptr cs:Charstash, sym ptr ast:Symbol)
  if not sym?
    return
  /if

  cs.add(sym'name)
  cs.addChar(32)
  ast:typeSummarize(cs, sym'type)
/func


func symlistSummarize(cs ptr cs:Charstash, symlist ptr kv:KVList)

  cs.add("(")

  if symlist?
    mut len = symlist.len()
    mut i uintptr = 0

    while i < len
      mut pair = symlist.getAt(i)
      mut sym ast:Symbol

      sym'name = cast<ptr uint8>(pair'key)
      sym'type = cast<ptr ast:Type>(pair'value)

      ast:symbolSummarize(cs, ptr sym)

      if i + 1 < len
        cs.add(", ")
      /if

      i++
    /while
  /if

  cs.add(")")
/func


func typeSummarize(cs ptr cs:Charstash, type ptr ast:Type)
  if not type?
    cs.add("<<null type please report>>")
    return
  /if

  if type'name?
    if type'moduleName?
      cs.add(type'moduleName)
      cs.add(":")
    /if

    cs.add(type'name)
    return
  /if

  if type'type == ast:TYPE_PTR
    cs.add("ptr ")
    typeSummarize(cs, type'retType)
    return
  /if

  if type'type == ast:TYPE_LOC
    cs.add("loc[")
    cs.addInt(type'itemCount)
    cs.add("] ")
    typeSummarize(cs, type'retType)
    return
  /if

  if type'type == ast:TYPE_FUNC
    cs.add("func")

    symlistSummarize(cs, type'members)

    if type'retType != null
      cs.addChar(32)

      typeSummarize(cs, type'retType)
    /if

    return
  /if


  ast:typeDump(cs, type)
/func


func declDump(prefix,name ptr uint8, type ptr ast:Type)
  tty:out(prefix)
  tty:outch(32)

  tty:out(name)
  tty:outch(32)

  mut cs = cs:new(40)
  ast:typeDump(cs, type)
  mut str = cs:unwrap(cs)

  tty:out(str)

  mem:free(str)

  tty:outch(10)

  tty:out("[[ size: ")
  tty:outint(type'typeSize)
  tty:out(", align: ")
  tty:outint(type'typeAlign)
  tty:out(" ]]")

  tty:outch(10)
/func
