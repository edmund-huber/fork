#  libfork, a base library for the Fork language
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2015
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the
#  licenses expressed under Section 1.12 of the MPL v2.


import ast
import kv
import lex
import list
import mem
import text
import tty
import utils


func printPadding(depth uintptr)
  mut i uintptr = 0

  while i < depth
    tty:out("    ")
    i++
  /while

/func


func lineDump(line ast:Line)
  tty:outint(line'line)
  tty:out(":")
  tty:outint(line'pos)
/func

func linesDump(begin,end ast:Line)
  tty:out("(at ")
  lineDump(begin)
  tty:out("-")
  if begin'line == end'line
    tty:outint(end'pos)
  else
    lineDump(end)
  /if
  tty:out(")")
/func


func psymbolDump(psym ptr ast:PSymbol)
  if psym == null
    return
  /if

  tty:out(psym'name)
  tty:out(" :: ")
  if psym'type != null
    ast:ptypeDump(psym'type)
  else
    tty:out("<inferred>")
  /if
/func


func ptypeDescrDumpStructuredDataArgs(args ptr list:List)
  if args == null
    tty:out("<null>")
    return
  /if

  mut len = list:listLen(args)
  mut first = true
  mut i uintptr = 0

  tty:out("(")

  while i < len
    if first
      first = false
    else
      tty:out(", ")
    /if

    mut sym = cast<ptr ast:PSymbol>(val list:listGet(args, i))
    psymbolDump(sym)

    i++
  /while

  tty:out(")")
/func


func ptypeDescrDump(ptypeDescr ptr ast:PTypeDescr)
  if ptypeDescr == null
    tty:out("<null>")
    return
  /if

  mut ptype = ptypeDescr'type

  if ptype == ast:PTYPE_FUNC
    tty:out("func")

    if ptypeDescr'arguments != null

      ptypeDescrDumpStructuredDataArgs(ptypeDescr'arguments)
      tty:outch(32)
    else
      tty:out("()")
    /if

    if ptypeDescr'retType != null
      ast:ptypeDump(ptypeDescr'retType)
    /if
  /if

  if ptype == ast:PTYPE_ID
    return
  /if

  if ptype == ast:PTYPE_LOC
    tty:out("[")
    tty:outint(ptypeDescr'length)
    tty:out("] ")
    ast:ptypeDump(ptypeDescr'retType)
  /if

  if ptype == ast:PTYPE_PTR
    tty:out("ptr ")
    ast:ptypeDump(ptypeDescr'retType)
  /if

  if ptype == ast:PTYPE_STRUCT
    tty:out("struct ")
    ptypeDescrDumpStructuredDataArgs(ptypeDescr'arguments)
  /if
/func


func ptypeDump(ptype ptr ast:PType)
  if ptype == null
    tty:out("<null>")
    return
  /if

  if ptype'name != null
    if ptype'moduleName != null
      tty:out(ptype'moduleName)
      tty:outch(58)
    /if
    tty:out(ptype'name)
  /if

  if ptype'descr != null

    ptypeDescrDump(cast<ptr ast:PTypeDescr>(ptype'descr))
  /if
/func


func pnodeTypeToString(ptype uint16) ptr uint8

  if ptype == ast:PROOT
    return "Root"
  /if

  if ptype == ast:PENTRY
    return "Entry"
  /if

  if ptype == ast:PEXPR
    return "Expression"
  /if

  if ptype == ast:PFUNCTION
    return "Function"
  /if

  if ptype == ast:PALIAS
    return "Alias"
  /if

  if ptype == ast:PDECL
    return "Decl"
  /if

  if ptype == ast:PMUT
    return "Mut"
  /if

  if ptype == ast:PBREAK
    return "Break"
  /if

  if ptype == ast:PCONTINUE
    return "Continue"
  /if

  if ptype == ast:PRETURN
    return "Return"
  /if

  if ptype == ast:PIF
    return "If"
  /if

  if ptype == ast:PIFELSE
    return "IfElse"
  /if

  if ptype == ast:PWHILE
    return "While"
  /if

  if ptype == ast:PBLOCK
    return "Block"
  /if

  return "<UNKNOWN BLOCK>"
/func


func prootDumpInfo(proot ptr ast:PRoot, depth uintptr)
  if proot'moduleName != null
    tty:out(" [module: ")
    tty:out(proot'moduleName'name)
    tty:outch(32)
    linesDump(proot'moduleName'begin, proot'moduleName'end)
    tty:out("]")
  /if

  tty:outch(10)

  mut len = list:listLen(proot'imports)
  if len > 0
    printPadding(depth)
    tty:outln("Imports: ")

    mut i uintptr = 0

    while i < len
      printPadding(depth + 1)
      mut imp = cast<ptr ast:StringDef>(val list:listGet(proot'imports, i))

      tty:out(imp'name)
      tty:outch(32)
      linesDump(imp'begin, imp'end)
      tty:outch(10)

      i++
    /while
  /if
/func


func pdeclDumpInfo(pdecl ptr ast:PDecl, depth uintptr)
  tty:outch(10)
  printPadding(depth + 1)

  psymbolDump(pdecl'sym)
/func


func pexprDumpInfo(pexpr ptr ast:PExpr, depth uintptr)
  mut tok lex:Token
  tok'type = pexpr'opType

  tty:out(": ")

  if pexpr'opType == lex:ID
    tty:out("an id - \"")
    tty:out(cast<ptr uint8>(pexpr'node'value))
    tty:out("\"")
  else
    if pexpr'opType == lex:NUMBER
      tty:outint(pexpr'node'value)
    else
      if pexpr'opType == lex:STRING
        tty:out("a string - \"")
        tty:out(cast<ptr uint8>(pexpr'node'value))
        tty:out("\"")
      else
        if pexpr'opType == lex:OPAR
          tty:out("a function call")
        else
          if pexpr'opType == lex:OBRAC
            tty:out("an array access")
          else
            tty:out(lex:tokenStr(ptr tok))

            if pexpr'opType == lex:CAST or pexpr'opType == lex:SIZE
              tty:out(" to ")

              ptypeDump(cast<ptr ast:PType>(pexpr'node'value))
            /if
          /if
        /if
      /if
    /if
  /if
/func


func pnodeDumpRec(pnode ptr ast:PNode, depth uintptr)

  printPadding(depth)

  tty:out(pnodeTypeToString(pnode'type))
  tty:out(":")

  tty:outch(32)
  linesDump(pnode'begin, pnode'end)

  if ast:isPRoot(pnode)
    prootDumpInfo(cast<ptr ast:PRoot>(pnode), depth)
  /if

  if ast:isPDecl(pnode)
    pdeclDumpInfo(cast<ptr ast:PDecl>(pnode), depth)
  /if

  if ast:isPExpr(pnode)
    pexprDumpInfo(cast<ptr ast:PExpr>(pnode), depth)
  /if

  tty:outch(10)

  mut len = list:listLen(pnode'leaves)
  mut i uintptr = 0

  while i < len
    mut child = cast<ptr ast:PNode>(val list:listGet(pnode'leaves, i))

    pnodeDumpRec(child, depth + 1)

    i++
  /while

/func


func pnodeDump(pnode ptr ast:PNode)
  pnodeDumpRec(pnode, 0)
/func


func symbolDump(cs ptr text:Charstash, sym ptr ast:Symbol)
  if sym == null
    return
  /if

  text:csAppendStr(cs, sym'name)
  text:csAppend(cs, 32)
  ast:typeDump(cs, sym'type)
/func


func symlistDump(cs ptr text:Charstash, symlist ptr kv:KVList)

  text:csAppendStr(cs, "(")

  if symlist != null
    mut len = kv:kvLen(symlist)
    mut i uintptr = 0

    while i < len
      mut pair = kv:kvGetAt(symlist, i)
      mut sym ast:Symbol

      sym'name = cast<ptr uint8>(pair'key)
      sym'type = cast<ptr ast:Type>(pair'value)

      ast:symbolDump(cs, ptr sym)

      if i + 1 < len
        text:csAppendStr(cs, ", ")
      /if

      i++
    /while
  /if

  text:csAppendStr(cs, ")")
/func


func typeDumpName(cs ptr text:Charstash, type ptr ast:Type)
  if type'name != null
    text:csAppendStr(cs, "{ ")

    if type'moduleName != null
      text:csAppendStr(cs, type'moduleName)
      text:csAppendStr(cs, ":")
    /if
    text:csAppendStr(cs, type'name)

    text:csAppendStr(cs, " } ")
  /if
/func


func typeDump(cs ptr text:Charstash, type ptr ast:Type)

  if type == null
    return
  /if

  if type'type == ast:TYPE_FUNC
    typeDumpName(cs, type)

    text:csAppendStr(cs, "func")

    symlistDump(cs, type'members)

    if type'retType != null
      text:csAppend(cs, 32)

      typeDump(cs, type'retType)
    /if
  else
    if type'type == ast:TYPE_PTR
      text:csAppendStr(cs, "ptr ")

      typeDump(cs, type'retType)
    else
      if type'type == ast:TYPE_STRUCT
        typeDumpName(cs, type)

        text:csAppendStr(cs, "struct")

        symlistDump(cs, type'members)
      else
        if type'type == ast:TYPE_LOC
          text:csAppendStr(cs, "[")
          text:csAppendInt(cs, type'itemCount)
          text:csAppendStr(cs, "] ")

          typeDump(cs, type'retType)
        else
          if type'type == ast:TYPE_BOOL
            text:csAppendStr(cs, "bool")
          else
            if type'type == ast:TYPE_INT
              if !type'isSigned
                text:csAppendStr(cs, "u")
              /if

              text:csAppendStr(cs, "int")
              text:csAppendInt(cs, type'typeSize * 8)

            else
              if type'type == ast:TYPE_DATA
                text:csAppendStr(cs, "data")
              else
                if type'type == ast:TYPE_RECALIAS
                  text:csAppendStr(cs, "<< alias to ")
                  text:csAppendStr(cs, type'name)
                  text:csAppendStr(cs, " >>")
                else
                  if type'type == ast:TYPE_NULL
                    text:csAppendStr(cs, "null")
                  else
                    if type'type == ast:TYPE_EMPTY
                      text:csAppendStr(cs, "<<empty type>>")
                    /if
                  /if
                /if
              /if
            /if
          /if
        /if
      /if
    /if
  /if

/func


func symbolSummarize(cs ptr text:Charstash, sym ptr ast:Symbol)
  if sym == null
    return
  /if

  text:csAppendStr(cs, sym'name)
  text:csAppend(cs, 32)
  ast:typeSummarize(cs, sym'type)
/func


func symlistSummarize(cs ptr text:Charstash, symlist ptr kv:KVList)

  text:csAppendStr(cs, "(")

  if symlist != null
    mut len = kv:kvLen(symlist)
    mut i uintptr = 0

    while i < len
      mut pair = kv:kvGetAt(symlist, i)
      mut sym ast:Symbol

      sym'name = cast<ptr uint8>(pair'key)
      sym'type = cast<ptr ast:Type>(pair'value)

      ast:symbolSummarize(cs, ptr sym)

      if i + 1 < len
        text:csAppendStr(cs, ", ")
      /if

      i++
    /while
  /if

  text:csAppendStr(cs, ")")
/func


func typeSummarize(cs ptr text:Charstash, type ptr ast:Type)
  if type == null
    text:csAppendStr(cs, "<<null type please report>>")
    return
  /if

  if type'name != null
    if type'moduleName != null
      text:csAppendStr(cs, type'moduleName)
      text:csAppendStr(cs, ":")
    /if

    text:csAppendStr(cs, type'name)
    return
  /if

  if type'type == ast:TYPE_PTR
    text:csAppendStr(cs, "ptr ")
    typeSummarize(cs, type'retType)
    return
  /if

  if type'type == ast:TYPE_LOC
    text:csAppendStr(cs, "loc[")
    text:csAppendInt(cs, type'itemCount)
    text:csAppendStr(cs, "] ")
    typeSummarize(cs, type'retType)
    return
  /if

  if type'type == ast:TYPE_FUNC
    text:csAppendStr(cs, "func")

    symlistSummarize(cs, type'members)

    if type'retType != null
      text:csAppend(cs, 32)

      typeSummarize(cs, type'retType)
    /if

    return
  /if


  ast:typeDump(cs, type)
/func


func declDump(prefix,name ptr uint8, type ptr ast:Type)
  tty:out(prefix)
  tty:outch(32)

  tty:out(name)
  tty:outch(32)

  mut cs = text:csNew(40)
  ast:typeDump(cs, type)
  mut str = text:csUnwrap(cs)

  tty:out(str)

  mem:free(str)

  tty:outch(10)

  tty:out("[[ size: ")
  tty:outint(type'typeSize)
  tty:out(", align: ")
  tty:outint(type'typeAlign)
  tty:out(" ]]")

  tty:outch(10)
/func
