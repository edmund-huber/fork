#  Second Step - Experimental Fork Compiler
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2014
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the
#  licenses expressed under Section 1.12 of the MPL v2.

import ast
import lex
import spring
import utils

func printPadding(depth uintptr)
  mut i uintptr = 0

  while i < depth
    spring:out("    ")
    i++
  /while

/func


func lineDump(line utils:Line)
  spring:outint(line'line)
  spring:out(":")
  spring:outint(line'pos)
/func

func linesDump(begin,end utils:Line)
  spring:out("(at ")
  lineDump(begin)
  spring:out("-")
  if begin'line == end'line
    spring:outint(end'pos)
  else
    lineDump(end)
  /if
  spring:out(")")
/func


func psymbolDump(psym ptr ast:PSymbol)
  if psym == null
    return
  /if

  spring:out(psym'name)
  spring:out(" :: ")
  if psym'type != null
    ast:ptypeDump(psym'type)
  else
    spring:out("<inferred>")
  /if
/func


func ptypeDescrDumpStructuredDataArgs(args ptr spring:List)
  if args == null
    spring:out("<null>")
    return
  /if

  mut len = spring:listLen(args)
  mut first = true
  mut i uintptr = 0

  spring:out("(")

  while i < len
    if first
      first = false
    else
      spring:out(", ")
    /if

    mut sym = cast<ptr ast:PSymbol>(val spring:listGet(args, i))
    psymbolDump(sym)

    i++
  /while

  spring:out(")")
/func


func ptypeDescrDump(ptypeDescr ptr ast:PTypeDescr)
  if ptypeDescr == null
    spring:out("<null>")
    return
  /if

  mut ptype = ptypeDescr'type

  if ptype == ast:PTYPE_FUNC
    spring:out("func")

    if ptypeDescr'arguments != null

      ptypeDescrDumpStructuredDataArgs(ptypeDescr'arguments)
      spring:outch(32)
    else
      spring:out("()")
    /if

    if ptypeDescr'retType != null
      ast:ptypeDump(ptypeDescr'retType)
    /if
  /if

  if ptype == ast:PTYPE_ID
    return
  /if

  if ptype == ast:PTYPE_LOC
    spring:out("[")
    spring:outint(ptypeDescr'length)
    spring:out("] ")
    ast:ptypeDump(ptypeDescr'retType)
  /if

  if ptype == ast:PTYPE_PTR
    spring:out("ptr ")
    ast:ptypeDump(ptypeDescr'retType)
  /if

  if ptype == ast:PTYPE_STRUCT
    spring:out("struct ")
    ptypeDescrDumpStructuredDataArgs(ptypeDescr'arguments)
  /if
/func


func ptypeDump(ptype ptr ast:PType)
  if ptype == null
    spring:out("<null>")
    return
  /if

  if ptype'name != null
    if ptype'moduleName != null
      spring:out(ptype'moduleName)
      spring:outch(58)
    /if
    spring:out(ptype'name)
  /if

  if ptype'descr != null

    ptypeDescrDump(cast<ptr ast:PTypeDescr>(ptype'descr))
  /if
/func


func pnodeTypeToString(ptype uint16) ptr uint8

  if ptype == ast:PROOT
    return "Root"
  /if

  if ptype == ast:PENTRY
    return "Entry"
  /if

  if ptype == ast:PEXPR
    return "Expression"
  /if

  if ptype == ast:PFUNCTION
    return "Function"
  /if

  if ptype == ast:PALIAS
    return "Alias"
  /if

  if ptype == ast:PDECL
    return "Decl"
  /if

  if ptype == ast:PMUT
    return "Mut"
  /if

  if ptype == ast:PBREAK
    return "Break"
  /if

  if ptype == ast:PCONTINUE
    return "Continue"
  /if

  if ptype == ast:PRETURN
    return "Return"
  /if

  if ptype == ast:PIF
    return "If"
  /if

  if ptype == ast:PIFELSE
    return "IfElse"
  /if

  if ptype == ast:PWHILE
    return "While"
  /if

  if ptype == ast:PBLOCK
    return "Block"
  /if

  return "<UNKNOWN BLOCK>"
/func


func prootDumpInfo(proot ptr ast:PRoot, depth uintptr)
  if proot'moduleName != null
    spring:out(" [module: ")
    spring:out(proot'moduleName'name)
    spring:outch(32)
    linesDump(proot'moduleName'begin, proot'moduleName'end)
    spring:out("]")
  /if

  spring:outch(10)

  mut len = spring:listLen(proot'imports)
  if len > 0
    printPadding(depth)
    spring:outln("Imports: ")

    mut i uintptr = 0

    while i < len
      printPadding(depth + 1)
      mut imp = cast<ptr ast:StringDef>(val spring:listGet(proot'imports, i))

      spring:out(imp'name)
      spring:outch(32)
      linesDump(imp'begin, imp'end)
      spring:outch(10)

      i++
    /while
  /if
/func


func pdeclDumpInfo(pdecl ptr ast:PDecl, depth uintptr)
  spring:outch(10)
  printPadding(depth + 1)

  psymbolDump(pdecl'sym)
/func


func pexprDumpInfo(pexpr ptr ast:PExpr, depth uintptr)
  mut tok lex:Token
  tok'type = pexpr'opType

  spring:out(": ")

  if pexpr'opType == lex:ID
    spring:out("an id - \"")
    spring:out(cast<ptr uint8>(pexpr'node'value))
    spring:out("\"")
  else
    if pexpr'opType == lex:NUMBER
      spring:outint(pexpr'node'value)
    else
      if pexpr'opType == lex:STRING
        spring:out("a string - \"")
        spring:out(cast<ptr uint8>(pexpr'node'value))
        spring:out("\"")
      else
        if pexpr'opType == lex:OPAR
          spring:out("a function call")
        else
          if pexpr'opType == lex:OBRAC
            spring:out("an array access")
          else
            spring:out(lex:tokenStr(ptr tok))
            
            if pexpr'opType == lex:CAST or pexpr'opType == lex:SIZE
              spring:out(" to ")

              ptypeDump(cast<ptr ast:PType>(pexpr'node'value))
            /if
          /if
        /if
      /if
    /if
  /if
/func


func pnodeDumpRec(pnode ptr ast:PNode, depth uintptr)

  printPadding(depth)

  spring:out(pnodeTypeToString(pnode'type))
  spring:out(":")

  spring:outch(32)
  linesDump(pnode'begin, pnode'end)

  if ast:isPRoot(pnode)
    prootDumpInfo(cast<ptr ast:PRoot>(pnode), depth)
  /if

  if ast:isPDecl(pnode)
    pdeclDumpInfo(cast<ptr ast:PDecl>(pnode), depth)
  /if

  if ast:isPExpr(pnode)
    pexprDumpInfo(cast<ptr ast:PExpr>(pnode), depth)
  /if

  spring:outch(10)

  mut len = spring:listLen(pnode'leaves)
  mut i uintptr = 0

  while i < len
    mut child = cast<ptr ast:PNode>(val spring:listGet(pnode'leaves, i))

    pnodeDumpRec(child, depth + 1)

    i++
  /while

/func


func pnodeDump(pnode ptr ast:PNode)
  pnodeDumpRec(pnode, 0)
/func


func symbolDump(sym ptr ast:Symbol)
  if sym == null
    return
  /if

  spring:out(sym'name)
  spring:outch(32)
  ast:typeDump(sym'type)
/func


func symlistDump(symlist ptr spring:List)

  spring:out("(")

  if symlist != null
    mut len = spring:listLen(symlist)
    mut i uintptr = 0

    while i < len
      mut sym = cast<ptr ast:Symbol>(val spring:listGet(symlist, i))

      ast:symbolDump(sym)

      if i + 1 < len
        spring:out(", ")
      /if

      i++
    /while
  /if

  spring:out(")")
/func


func typeDumpName(type ptr ast:Type)
  if type'name != null
    spring:out("{ ")

    if type'moduleName != null
      spring:out(type'moduleName)
      spring:out(":")
    /if
    spring:out(type'name)

    spring:out(" } ")
  /if
/func


func typeDump(type ptr ast:Type)

  if type == null
    return
  /if

  if type'type == ast:TYPE_FUNC
    typeDumpName(type)

    spring:out("func")

    symlistDump(type'members)

    spring:outch(32)

    typeDump(type'retType)
  else
    if type'type == ast:TYPE_PTR
      spring:out("ptr ")

      typeDump(type'retType)
    else
      if type'type == ast:TYPE_STRUCT
        typeDumpName(type)

        spring:out("struct")

        symlistDump(type'members)
      else
        if type'type == ast:TYPE_LOC
          spring:out("[")
          spring:outint(type'itemCount)
          spring:out("] ")

          typeDump(type'retType)
        else
          if type'type == ast:TYPE_BOOL
            spring:out("bool")
          else
            if type'type == ast:TYPE_INT
              if !type'isSigned
                spring:out("u")
              /if

              spring:out("int")
              spring:outint(type'typeSize * 8)

            else
              if type'type == ast:TYPE_DATA
                spring:out("data")
              else
                if type'type == ast:TYPE_REC_ALIAS
                  spring:out("<< alias to ")
                  spring:out(type'name)
                  spring:out(" >>")
                else
                  if type'type == ast:TYPE_NULL
                    spring:out("<< type of null >>")
                  else
                  /if
                /if
              /if
            /if
          /if
        /if
      /if
    /if
  /if

/func


func declDump(prefix,name ptr uint8, type ptr ast:Type)
  spring:out(prefix)
  spring:outch(32)

  spring:out(name)
  spring:outch(32)

  ast:typeDump(type)

  spring:outch(10)

  spring:out("[[ size: ")
  spring:outint(type'typeSize)
  spring:out(", align: ")
  spring:outint(type'typeAlign)
  spring:out(" ]]")

  spring:outch(10)
/func
