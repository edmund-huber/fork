#  Second Step - Experimental Fork Compiler
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2015
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the
#  licenses expressed under Section 1.12 of the MPL v2.

import ast
import lex
import base
import utils

func printPadding(depth uintptr)
  mut i uintptr = 0

  while i < depth
    base:out("    ")
    i++
  /while

/func


func lineDump(line utils:Line)
  base:outint(line'line)
  base:out(":")
  base:outint(line'pos)
/func

func linesDump(begin,end utils:Line)
  base:out("(at ")
  lineDump(begin)
  base:out("-")
  if begin'line == end'line
    base:outint(end'pos)
  else
    lineDump(end)
  /if
  base:out(")")
/func


func psymbolDump(psym ptr ast:PSymbol)
  if psym == null
    return
  /if

  base:out(psym'name)
  base:out(" :: ")
  if psym'type != null
    ast:ptypeDump(psym'type)
  else
    base:out("<inferred>")
  /if
/func


func ptypeDescrDumpStructuredDataArgs(args ptr base:List)
  if args == null
    base:out("<null>")
    return
  /if

  mut len = base:listLen(args)
  mut first = true
  mut i uintptr = 0

  base:out("(")

  while i < len
    if first
      first = false
    else
      base:out(", ")
    /if

    mut sym = cast<ptr ast:PSymbol>(val base:listGet(args, i))
    psymbolDump(sym)

    i++
  /while

  base:out(")")
/func


func ptypeDescrDump(ptypeDescr ptr ast:PTypeDescr)
  if ptypeDescr == null
    base:out("<null>")
    return
  /if

  mut ptype = ptypeDescr'type

  if ptype == ast:PTYPE_FUNC
    base:out("func")

    if ptypeDescr'arguments != null

      ptypeDescrDumpStructuredDataArgs(ptypeDescr'arguments)
      base:outch(32)
    else
      base:out("()")
    /if

    if ptypeDescr'retType != null
      ast:ptypeDump(ptypeDescr'retType)
    /if
  /if

  if ptype == ast:PTYPE_ID
    return
  /if

  if ptype == ast:PTYPE_LOC
    base:out("[")
    base:outint(ptypeDescr'length)
    base:out("] ")
    ast:ptypeDump(ptypeDescr'retType)
  /if

  if ptype == ast:PTYPE_PTR
    base:out("ptr ")
    ast:ptypeDump(ptypeDescr'retType)
  /if

  if ptype == ast:PTYPE_STRUCT
    base:out("struct ")
    ptypeDescrDumpStructuredDataArgs(ptypeDescr'arguments)
  /if
/func


func ptypeDump(ptype ptr ast:PType)
  if ptype == null
    base:out("<null>")
    return
  /if

  if ptype'name != null
    if ptype'moduleName != null
      base:out(ptype'moduleName)
      base:outch(58)
    /if
    base:out(ptype'name)
  /if

  if ptype'descr != null

    ptypeDescrDump(cast<ptr ast:PTypeDescr>(ptype'descr))
  /if
/func


func pnodeTypeToString(ptype uint16) ptr uint8

  if ptype == ast:PROOT
    return "Root"
  /if

  if ptype == ast:PENTRY
    return "Entry"
  /if

  if ptype == ast:PEXPR
    return "Expression"
  /if

  if ptype == ast:PFUNCTION
    return "Function"
  /if

  if ptype == ast:PALIAS
    return "Alias"
  /if

  if ptype == ast:PDECL
    return "Decl"
  /if

  if ptype == ast:PMUT
    return "Mut"
  /if

  if ptype == ast:PBREAK
    return "Break"
  /if

  if ptype == ast:PCONTINUE
    return "Continue"
  /if

  if ptype == ast:PRETURN
    return "Return"
  /if

  if ptype == ast:PIF
    return "If"
  /if

  if ptype == ast:PIFELSE
    return "IfElse"
  /if

  if ptype == ast:PWHILE
    return "While"
  /if

  if ptype == ast:PBLOCK
    return "Block"
  /if

  return "<UNKNOWN BLOCK>"
/func


func prootDumpInfo(proot ptr ast:PRoot, depth uintptr)
  if proot'moduleName != null
    base:out(" [module: ")
    base:out(proot'moduleName'name)
    base:outch(32)
    linesDump(proot'moduleName'begin, proot'moduleName'end)
    base:out("]")
  /if

  base:outch(10)

  mut len = base:listLen(proot'imports)
  if len > 0
    printPadding(depth)
    base:outln("Imports: ")

    mut i uintptr = 0

    while i < len
      printPadding(depth + 1)
      mut imp = cast<ptr ast:StringDef>(val base:listGet(proot'imports, i))

      base:out(imp'name)
      base:outch(32)
      linesDump(imp'begin, imp'end)
      base:outch(10)

      i++
    /while
  /if
/func


func pdeclDumpInfo(pdecl ptr ast:PDecl, depth uintptr)
  base:outch(10)
  printPadding(depth + 1)

  psymbolDump(pdecl'sym)
/func


func pexprDumpInfo(pexpr ptr ast:PExpr, depth uintptr)
  mut tok lex:Token
  tok'type = pexpr'opType

  base:out(": ")

  if pexpr'opType == lex:ID
    base:out("an id - \"")
    base:out(cast<ptr uint8>(pexpr'node'value))
    base:out("\"")
  else
    if pexpr'opType == lex:NUMBER
      base:outint(pexpr'node'value)
    else
      if pexpr'opType == lex:STRING
        base:out("a string - \"")
        base:out(cast<ptr uint8>(pexpr'node'value))
        base:out("\"")
      else
        if pexpr'opType == lex:OPAR
          base:out("a function call")
        else
          if pexpr'opType == lex:OBRAC
            base:out("an array access")
          else
            base:out(lex:tokenStr(ptr tok))

            if pexpr'opType == lex:CAST or pexpr'opType == lex:SIZE
              base:out(" to ")

              ptypeDump(cast<ptr ast:PType>(pexpr'node'value))
            /if
          /if
        /if
      /if
    /if
  /if
/func


func pnodeDumpRec(pnode ptr ast:PNode, depth uintptr)

  printPadding(depth)

  base:out(pnodeTypeToString(pnode'type))
  base:out(":")

  base:outch(32)
  linesDump(pnode'begin, pnode'end)

  if ast:isPRoot(pnode)
    prootDumpInfo(cast<ptr ast:PRoot>(pnode), depth)
  /if

  if ast:isPDecl(pnode)
    pdeclDumpInfo(cast<ptr ast:PDecl>(pnode), depth)
  /if

  if ast:isPExpr(pnode)
    pexprDumpInfo(cast<ptr ast:PExpr>(pnode), depth)
  /if

  base:outch(10)

  mut len = base:listLen(pnode'leaves)
  mut i uintptr = 0

  while i < len
    mut child = cast<ptr ast:PNode>(val base:listGet(pnode'leaves, i))

    pnodeDumpRec(child, depth + 1)

    i++
  /while

/func


func pnodeDump(pnode ptr ast:PNode)
  pnodeDumpRec(pnode, 0)
/func


func symbolDump(cs ptr base:Charstash, sym ptr ast:Symbol)
  if sym == null
    return
  /if

  base:csAppendStr(cs, sym'name)
  base:csAppend(cs, 32)
  ast:typeDump(cs, sym'type)
/func


func symlistDump(cs ptr base:Charstash, symlist ptr utils:KVList)

  base:csAppendStr(cs, "(")

  if symlist != null
    mut len = utils:kvLen(symlist)
    mut i uintptr = 0

    while i < len
      mut pair = utils:kvGetAt(symlist, i)
      mut sym ast:Symbol

      sym'name = cast<ptr uint8>(pair'key)
      sym'type = cast<ptr ast:Type>(pair'value)

      ast:symbolDump(cs, ptr sym)

      if i + 1 < len
        base:csAppendStr(cs, ", ")
      /if

      i++
    /while
  /if

  base:csAppendStr(cs, ")")
/func


func typeDumpName(cs ptr base:Charstash, type ptr ast:Type)
  if type'name != null
    base:csAppendStr(cs, "{ ")

    if type'moduleName != null
      base:csAppendStr(cs, type'moduleName)
      base:csAppendStr(cs, ":")
    /if
    base:csAppendStr(cs, type'name)

    base:csAppendStr(cs, " } ")
  /if
/func


func typeDump(cs ptr base:Charstash, type ptr ast:Type)

  if type == null
    return
  /if

  if type'type == ast:TYPE_FUNC
    typeDumpName(cs, type)

    base:csAppendStr(cs, "func")

    symlistDump(cs, type'members)

    if type'retType != null
      base:csAppend(cs, 32)

      typeDump(cs, type'retType)
    /if
  else
    if type'type == ast:TYPE_PTR
      base:csAppendStr(cs, "ptr ")

      typeDump(cs, type'retType)
    else
      if type'type == ast:TYPE_STRUCT
        typeDumpName(cs, type)

        base:csAppendStr(cs, "struct")

        symlistDump(cs, type'members)
      else
        if type'type == ast:TYPE_LOC
          base:csAppendStr(cs, "[")
          base:csAppendInt(cs, type'itemCount)
          base:csAppendStr(cs, "] ")

          typeDump(cs, type'retType)
        else
          if type'type == ast:TYPE_BOOL
            base:csAppendStr(cs, "bool")
          else
            if type'type == ast:TYPE_INT
              if !type'isSigned
                base:csAppendStr(cs, "u")
              /if

              base:csAppendStr(cs, "int")
              base:csAppendInt(cs, type'typeSize * 8)

            else
              if type'type == ast:TYPE_DATA
                base:csAppendStr(cs, "data")
              else
                if type'type == ast:TYPE_RECALIAS
                  base:csAppendStr(cs, "<< alias to ")
                  base:csAppendStr(cs, type'name)
                  base:csAppendStr(cs, " >>")
                else
                  if type'type == ast:TYPE_NULL
                    base:csAppendStr(cs, "null")
                  else
                    if type'type == ast:TYPE_EMPTY
                      base:csAppendStr(cs, "<<empty type>>")
                    /if
                  /if
                /if
              /if
            /if
          /if
        /if
      /if
    /if
  /if

/func


func symbolSummarize(cs ptr base:Charstash, sym ptr ast:Symbol)
  if sym == null
    return
  /if

  base:csAppendStr(cs, sym'name)
  base:csAppend(cs, 32)
  ast:typeSummarize(cs, sym'type)
/func


func symlistSummarize(cs ptr base:Charstash, symlist ptr utils:KVList)

  base:csAppendStr(cs, "(")

  if symlist != null
    mut len = utils:kvLen(symlist)
    mut i uintptr = 0

    while i < len
      mut pair = utils:kvGetAt(symlist, i)
      mut sym ast:Symbol

      sym'name = cast<ptr uint8>(pair'key)
      sym'type = cast<ptr ast:Type>(pair'value)

      ast:symbolSummarize(cs, ptr sym)

      if i + 1 < len
        base:csAppendStr(cs, ", ")
      /if

      i++
    /while
  /if

  base:csAppendStr(cs, ")")
/func


func typeSummarize(cs ptr base:Charstash, type ptr ast:Type)
  if type == null
    base:csAppendStr(cs, "<<null type please report>>")
    return
  /if

  if type'name != null
    if type'moduleName != null
      base:csAppendStr(cs, type'moduleName)
      base:csAppendStr(cs, ":")
    /if

    base:csAppendStr(cs, type'name)
    return
  /if

  if type'type == ast:TYPE_PTR
    base:csAppendStr(cs, "ptr ")
    typeSummarize(cs, type'retType)
    return
  /if

  if type'type == ast:TYPE_LOC
    base:csAppendStr(cs, "loc[")
    base:csAppendInt(cs, type'itemCount)
    base:csAppendStr(cs, "] ")
    typeSummarize(cs, type'retType)
    return
  /if

  if type'type == ast:TYPE_FUNC
    base:csAppendStr(cs, "func")

    symlistSummarize(cs, type'members)

    if type'retType != null
      base:csAppend(cs, 32)

      typeSummarize(cs, type'retType)
    /if

    return
  /if


  ast:typeDump(cs, type)
/func


func declDump(prefix,name ptr uint8, type ptr ast:Type)
  base:out(prefix)
  base:outch(32)

  base:out(name)
  base:outch(32)

  mut cs = base:csNew(40)
  ast:typeDump(cs, type)
  mut str = base:csUnleash(cs)

  base:out(str)

  base:free(str)

  base:outch(10)

  base:out("[[ size: ")
  base:outint(type'typeSize)
  base:out(", align: ")
  base:outint(type'typeAlign)
  base:out(" ]]")

  base:outch(10)
/func
