#  Second Step - Experimental Fork Compiler
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2014, 2015
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the
#  licenses expressed under Section 1.12 of the MPL v2.


import base


mut BLACK = false
mut RED = true
mut FREE_NONE uint8 = 0
mut FREE_KEY uint8 = 1
mut FREE_VALUE uint8 = 10

func nodeNew(key data, value data, cmp base:comparer, freewhat uint8) ptr base:Mnode
  mut ret = cast<ptr base:Mnode>(base:zalloc(size(base:Mnode)))
  ret'key = key
  ret'value = value
  ret'color = RED
  ret'cmp = cmp
  ret'freewhat = freewhat
  return ret
/func


func nodeRotateLeft(node ptr base:Mnode) ptr base:Mnode
  mut ret = node'right

  if ret'color == BLACK
    base:errln("rotating left a black node")
    base:abort()
  /if

  node'right = ret'left
  ret'left = node
#  ret'color = ret'left'color
  ret'color = node'color
  node'color = RED

  return ret
/func


func nodeRotateRight(node ptr base:Mnode) ptr base:Mnode
  mut ret = node'left

  if ret'color == BLACK
    base:errln("rotating right a black node")
    base:abort()
  /if

  node'left = ret'right
  ret'right = node
#  ret'color = ret'right'color
  ret'color = node'color
#  ret'right'color = RED
  node'color = RED
  return ret
/func


func nodeColorFlip(node ptr base:Mnode)
  node'color = !node'color
  node'left'color = !node'left'color
  node'right'color = !node'right'color
/func


func nodeIsRed(node ptr base:Mnode) bool
  return (node != null) and (node'color == RED)
/func


func nodeIsBlack(node ptr base:Mnode) bool
  return (node == null) or (node'color == BLACK)
/func


func nodeFree(node ptr base:Mnode, freeKey ptr func(item data), freeVal ptr func(item data))

  if node == null
    return
  /if

  nodeFree(node'left, freeKey, freeVal)
  nodeFree(node'right, freeKey, freeVal)

  if (node'freewhat & FREE_KEY) != 0
    if node'key != null
      freeKey(node'key)
    /if
  /if

  if (node'freewhat & FREE_VALUE) != 0
    if node'value != null
      freeVal(node'value)
    /if
  /if

  base:free(node)

/func


func nodeFixUp(node ptr base:Mnode) ptr base:Mnode
  if nodeIsRed(node'right)
	  node = nodeRotateLeft(node)
  /if

  if nodeIsRed(node'left) and nodeIsRed(node'left'left)
	  node = nodeRotateRight(node)
  /if

  if nodeIsRed(node'left) and nodeIsRed(node'right)
	  nodeColorFlip(node)
  /if

  return node
/func


func nodeAdd(node ptr base:Mnode, keyV data, value data, cmp base:comparer, freewhat uint8, oldvalue ptr data) ptr base:Mnode

  if node == null
    val oldvalue = null
    return nodeNew(keyV, value, cmp, freewhat)
  /if

  mut res = node'cmp(keyV,node'key)
  if res == 1
    node'right = nodeAdd(node'right, keyV, value, node'cmp, freewhat, oldvalue)
  else
    if res == -1
      node'left = nodeAdd(node'left, keyV, value, node'cmp, freewhat, oldvalue)
	  else
      val oldvalue = node'value
	    node'value = value
	  /if
  /if

  return nodeFixUp(node)

/func


func nodeMoveRedLeft(node ptr base:Mnode) ptr base:Mnode

  nodeColorFlip(node)

  if (nodeIsRed(node'right'left))
    node'right = nodeRotateRight(node'right)
	  node = nodeRotateLeft(node)
	  nodeColorFlip(node)
  /if

  return node

/func


func nodeMoveRedRight(node ptr base:Mnode) ptr base:Mnode

  nodeColorFlip(node)

  if nodeIsRed(node'left'left)
    node = nodeRotateRight(node)
	  nodeColorFlip(node)
  /if

  return node

/func


func nodeGetnode(node ptr base:Mnode, keyV data) ptr base:Mnode
  if node == null
    return null
  /if

  mut res = node'cmp(keyV, node'key)
  if res == 0
    return node
  else
    if res == -1
      return nodeGetnode(node'left, keyV)
    else
      return nodeGetnode(node'right, keyV)
    /if
  /if
/func


func nodeGet(node ptr base:Mnode, keyV data, valueV ptr data) bool
  mut found = nodeGetnode(node, keyV)

  if found == null
    return false
  /if

  val valueV = found'value
  return true
/func


func nodeDeleteMin(node ptr base:Mnode) ptr base:Mnode
  if node'left == null
    return null
  /if

  if nodeIsBlack(node'left) and nodeIsBlack(node'left'left)
    node = nodeMoveRedLeft(node)
  /if

  node'left = nodeDeleteMin(node'left)
  return nodeFixUp(node)
/func


func nodeMkpair(node ptr base:Mnode) ptr base:Pair
  if node == null
    return null
  /if

  mut ret = cast<ptr base:Pair>(base:alloc(size(base:Pair)))
  ret'key = node'key
  ret'value = node'value
  return ret
/func


func nodeMinpair(node ptr base:Mnode) ptr base:Pair
  if node'left == null
    return nodeMkpair(node)
  else
    return nodeMinpair(node'left)
  /if
/func


func nodeMin(node ptr base:Mnode) data
  if node'left == null
    return node'key
  else
    return nodeMin(node'left)
  /if
/func


func nodeDelete(node ptr base:Mnode, keyV data, found ptr bool) ptr base:Mnode

  if node == null
    val found = false
    return null
  /if

  if node'cmp(keyV,node'key) < 0
    if node'left == null
      return null
    /if

    if nodeIsBlack(node'left) and nodeIsBlack(node'left'left)
      node = nodeMoveRedLeft(node)
    /if

    node'left = nodeDelete(node'left, keyV, found)
  else

    if nodeIsRed(node'left)
      node = nodeRotateRight(node)
    /if

    if node'cmp(keyV, node'key) == 0 and node'right == null
      val found = true
      return null
    /if

    if node'right != null and node'right'left != null and nodeIsBlack(node'right) and nodeIsBlack(node'right'left)
      node = nodeMoveRedRight(node)
    /if

    if node'cmp(keyV, node'key) == 0
      nodeGet(node'right, nodeMin(node'right), ptr node'value)
      node'key = nodeMin(node'right)
      node'right = nodeDeleteMin(node'right)
      val found = true
    else
      node'right = nodeDelete(node'right, keyV, found)
    /if

  /if

  return nodeFixUp(node)

/func


func mapInit(map ptr base:Map, cmp base:comparer) ptr base:Map
  map'cmp = cmp
  return map
/func


func mapNew(cmp base:comparer) ptr base:Map
  mut map = cast<ptr base:Map>(base:zalloc(size(base:Map)))

  return base:mapInit(map, cmp)
/func


func mapGet(map ptr base:Map, key data, value ptr data) bool
  if map'root == null
    return false
  /if

  return nodeGet(map'root,key, value)
/func


func mapPut(map ptr base:Map, key data, value data, freewhat uint8) data
  mut oldvalue data = null
  map'root = nodeAdd(map'root, key, value, map'cmp, freewhat, ptr oldvalue)
  map'root'color = BLACK

  if oldvalue == null
    map'len++
  /if

  return oldvalue
/func


func mapContains(map ptr base:Map, key data) bool
  mut value data #ignored - will be discarded but needed for mapGet to work
  return base:mapGet(map, key, ptr value)
/func


func mapRemove(map ptr base:Map, key data) bool
	mut ret = false
	mut newVal = nodeDelete(map'root, key, ptr ret)

  if ret
    map'root = newVal

    if map'root != null
  	  map'root'color = BLACK
    /if

  	if ret
  	  map'len--
    /if
  /if

	return ret
/func


func mapFirst(map ptr base:Map) ptr base:Pair
  return map'root != null => nodeMinpair(map'root) || null
/func


func mapDeinit(map ptr base:Map)
  base:mapDeinitSpec(map, null, null)
/func


func mapDeinitSpec(map ptr base:Map, freeKey ptr func(item data), freeVal ptr func(item data))
  if map == null
    return
  /if

  if freeKey == null
    freeKey = ptr base:free
  /if

  if freeVal == null
    freeVal = ptr base:free
  /if

  nodeFree(map'root, freeKey, freeVal)
/func


func mapFreeSpec(map ptr base:Map, freeKey ptr func(item data), freeVal ptr func(item data))
  base:mapDeinitSpec(map, freeKey, freeVal)
  base:free(map)
/func


func mapFree(map ptr base:Map)
  base:mapFreeSpec(map, null, null)
/func


func mapLen(map ptr base:Map) uintptr
  return map'len
/func


func strmapInit(map ptr base:Map) ptr base:Map
  return base:mapInit(map, ptr base:strcomparer)
/func


func strmapNew() ptr base:Map
  return base:mapNew(ptr base:strcomparer)
/func
