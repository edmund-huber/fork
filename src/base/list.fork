#  libfork, a base library for the Fork language
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2014, 2015
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the
#  licenses expressed under Section 1.12 of the MPL v2.


import base
import mem


func listSeekAhead(list ptr base:List, pos uintptr)

  if (list'current == null) or (pos == 0)
    list'current = list'start
    list'pos = 0
  /if

  while list'pos < pos
    list'current = list'current'next
    list'pos++
  /while

/func


func listSeekBehind(list ptr base:List, pos uintptr)

  if (list'current == null) or ((list'len - 1) == pos)
    list'current = list'end
    list'pos = list'len - 1
  /if

  while list'pos > pos
    list'current = list'current'prec
    list'pos--
  /while

/func


func listSeekZero(list ptr base:List)
  list'current = list'start
  list'pos = 0
/func


func listSeek(list ptr base:List, pos uintptr)
  if (list'current == null) and (pos == 0)
     base:listSeekZero(list)
  /if

  if pos > list'pos
    listSeekAhead(list, pos)
  else
    if pos < list'pos
      listSeekBehind(list, pos)
    /if
  /if
/func


func listPushint(list ptr base:List, value uintptr)
  mut new = cast<ptr base:Lnode>(mem:zalloc(size(base:Lnode)))

  new'next = list'start
  if list'start != null
    list'start'prec = new
  /if

  if list'end == null
    list'end = new
    list'current = new
  else
    list'pos++
  /if

  new'value = value
  list'start = new

  list'len++
/func


mut listPush = cast<ptr func(list ptr base:List, item data)>(ptr listPushint)

func listAppendint(list ptr base:List, value uintptr) intptr
  if list'start == null
    listPushint(list, value)
    return 1
  /if

  mut new = cast<ptr base:Lnode>(mem:zalloc(size(base:Lnode)))

  new'value = value
  new'prec = list'end
  list'end'next = new

  list'end = new

  return cast<intptr>(list'len++)
/func


mut listAppend = cast<ptr func(list ptr base:List, item data) intptr>(ptr listAppendint)

func listAddint(list ptr base:List, pos uintptr, value uintptr) intptr
  if pos > list'len
    return -1
  /if

  if pos == list'len
    return listAppendint(list, value)
  /if

  listSeek(list, pos)

  mut new = cast<ptr base:Lnode>(mem:zalloc(size(base:Lnode)))
  mut prec = list'current'prec

  if prec != null
    prec'next = new
  /if

  new'prec = prec
  new'value = value
  new'next = list'current
  list'current'prec = new

  list'current = cast<ptr base:Lnode>(list'pos = 0)

  list'len++

  return cast<intptr>(pos)
/func


mut listAdd = cast<ptr func(list ptr base:List, index uintptr, item data) intptr>(ptr listAddint)

func listInit(list ptr base:List) ptr base:List
  mem:memset(list, 0, size(base:List))
  return list
/func


func listNew() ptr base:List
  return base:listInit(cast<ptr base:List>(mem:alloc(size(base:List))))
/func


func listExtract(list ptr base:List, start uintptr, len intptr) ptr base:List

  mut extract = listNew()

  if start < list'len
    if len > list'len
      len = cast<intptr>(list'len - start)
    /if

    if len < 0
      len = cast<intptr>(list'len - start)
    /if
    listSeek(list, start)

    mut prec = list'current'prec
    mut link1 ptr ptr base:Lnode
    if prec != null
      link1 = ptr prec'next
    else
      link1 = ptr list'start
    /if

    extract'current = extract'start = extract'end = list'current

    listSeek(list, start + len - 1)

    mut next = list'current'next
    mut link2 ptr ptr base:Lnode
    if next != null
      link2 = ptr next'prec
    else
      link2 = ptr list'end
    /if

    extract'end = list'current

    extract'len = len

    val link1 = next
    val link2 = prec

    extract'start'prec = extract'end'next = null

    list'len = list'len - len

    list'current = list'start
    list'pos = 0
  /if

  return extract

/func


func lnodeFree(lnode ptr base:Lnode)
  while lnode != null
    mut next = lnode'next
    mem:free(lnode)
    lnode = next
  /while
/func


func listDeinit(list ptr base:List)
  lnodeFree(list'start)
/func


func listFree(list ptr base:List)
  if list != null
    base:listDeinit(list)

    mem:free(list)
  /if
/func


func lnodeFreeAll(lnode ptr base:Lnode, freefunc ptr func(item data))
  while lnode != null
    mut next = lnode'next
    freefunc(cast<data>(lnode'value))
    mem:free(lnode)
    lnode = next
  /while
/func


func listDeinitAll(list ptr base:List, freefunc ptr func(item data))
  lnodeFreeAll(list'start, freefunc)
/func


func listFreeAll(list ptr base:List, freefunc ptr func(item data))
  base:listDeinitAll(list, freefunc)
  mem:free(list)
/func


func lnodeFreeContents(lnode ptr base:Lnode, freefunc ptr func(item data))
  while lnode != null
    mut next = lnode'next
    freefunc(cast<data>(lnode'value))
    lnode = next
  /while
/func


func listFreeContents(list ptr base:List, freefunc ptr func(item data))
  lnodeFreeContents(list'start, freefunc)
/func


func listGetint(list ptr base:List, pos uintptr) ptr uintptr
  if pos >= list'len
    return null
  /if

  listSeek(list, pos)

  if list'current != null
    return ptr list'current'value
  /if

  return null
/func


mut listGet = cast<ptr func(list ptr base:List, index uintptr) ptr data>(ptr listGetint)

func listInsertint(list ptr base:List, pos uintptr, value uintptr) intptr
  if pos > list'len
    return -1
  /if

  if pos == list'len
    return listAppendint(list, value)
  /if

  listSeek(list, pos)

  list'current'value = value

  return cast<intptr>(list'pos)
/func


mut listInsert = cast<ptr func(list ptr base:List, index uintptr, item data) intptr>(ptr listInsertint)

func listLen(list ptr base:List) uintptr
  return list'len
/func


func listPopint(list ptr base:List) uintptr
  if list'start == null
    return 0
  /if

  mut next = list'start'next
  mut ret = list'start'value

  mem:free(list'start)

  if next != null
    next'prec = null
  /if

  if list'start == list'end
    mem:memset(list, 0, size(base:List))
  else
    list'start = next
    list'len--
  /if

  return ret
/func


mut listPop = cast<ptr func(list ptr base:List) data>(ptr listPopint)

func listPrune(list ptr base:List)
  lnodeFree(list'start)
  mem:memset(list, 0, size(base:List))
/func


func listShallowCopy(list ptr base:List) ptr base:List
  mut new = listNew()
  mut len = listLen(list)
  mut i uintptr = 0

  while i < len
    listAppendint(new, val listGetint(list, i))
    i++
  /while

  return new
/func


func listPrint(list ptr base:List)
  mut inside = false
  base:out("[ ")
  mut len = listLen(list)
  mut i uint8 = 0

  while i < len
    if inside
      base:out(", ")
    else
      inside = true
    /if

    base:outint(val listGetint(list, i))
    i++
  /while
  base:outln(" ]")
/func



func listRemove(list ptr base:List, item uintptr, freefunc ptr func(item data)) bool
  mut len = base:listLen(list)

  if item >= len
    return false
  /if

  listSeek(list, item)

  mut prec = list'current'prec
  mut next = list'current'next

  mut precNodeNext = ptr list'start

  if prec != null
    precNodeNext = ptr prec'next
  /if

  mut nextNodePrec = ptr list'end

  if next != null
    nextNodePrec = ptr next'prec
  /if

  val precNodeNext = next
  val nextNodePrec = prec

  if freefunc != null
    freefunc(cast<data>(list'current'value))
  /if

  mem:free(list'current)

  list'len--

  if item == 0
    list'current = next
    # position is 0 already
  else
    list'current = prec
    list'pos--
  /if

  return true
/func
