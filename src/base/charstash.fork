#  Second Step - Experimental Fork Compiler
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2014, 2015
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the
#  licenses expressed under Section 1.12 of the MPL v2.


import base


func csAppend(cs ptr base:Charstash, ch uint8)
  if cs'len == cs'cap
    cs'cap = cs'cap + 10
    mut new = cast<ptr uint8>(base:alloc(cs'cap))
    base:memmove(new, cs'base, cs'len)
    base:free(cs'base)
    cs'base = new
    cs'work = cs'base + cs'len
  /if

  val cs'work = ch
  cs'len++
  cs'work++
/func


func csAppendInt(cs ptr base:Charstash, num uintptr)
  mut buf [20] int8

  base:numtostr(num, ptr buf[0], 20)

  base:csAppendStr(cs, buf)
/func


func csAppendStr(cs ptr base:Charstash, str ptr uint8)
  while val str != 0
    csAppend(cs, val str)
    str++
  /while
/func


func csFree(cs ptr base:Charstash)
  base:free(cs'base)
  base:free(cs)
/func


func csNew(cap uintptr) ptr base:Charstash
  mut cs = cast<ptr base:Charstash>(base:zalloc(size(base:Charstash)))

  cs'work = cs'base = cast<ptr uint8>(base:alloc(cap))
  cs'cap = cap

  return cs
/func


func csUnleash(cs ptr base:Charstash) ptr uint8
  csAppend(cs, 0)

  mut ret = cs'base
  base:free(cs)

  return ret
/func


func csLen(cs ptr base:Charstash) uintptr
  return cs'len
/func
