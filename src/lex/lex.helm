#  Second Step - Experimental Helm Compiler
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2014
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the 
#  licenses expressed under Section 1.12 of the MPL v2. 

import lex
import spring
import utils

func nextChar(lex ptr lex:Lexer) uint8
  var ret = lex'peek

  spring:streamRead(lex'file, ptr lex'peek, 1)
  if (lex'error = spring:streamError(lex'file)) != null
    return 0
  /if

  if spring:streamEnded(lex'file)
    lex'peek = 4 #EOT
  /if

  if ret == 12 #carriage return
    if lex'peek != 10 #new line (Windows format case)
      lex'error = utils:errorLex(lex, "inconsistent end of line - no newline after carriage return")
      return 0
    /if
    return nextChar(lex)
  /if

  return ret
/func

func lexDiscardComment(lex ptr lex:Lexer)
  while !lex:lexerEof(lex) and lex'peek != 10
    if nextChar(lex) == 0 #discard
      return #exit on error
    /if
  /while
/func

var STX = 2 # There is no reason for using 2 and not another reserved character.

func applyEscape(ch uint8, escape bool) uint8

  if !escape
    return ch
  /if

  if ch == 97 # `a`
    return 7 # BEL
  /if

  if ch == 98 # `b` 
    return 8 # BS
  /if

  if ch == 110 # `n`
    return 10 # NL
  /if

  if ch == 114 # `r`
    return 13
  /if

  if ch == 116 # `t`
    return 9
  /if

  return ch

/func

func lexExtractString(lex ptr lex:Lexer) ptr uint8
  nextChar(lex) #discard the `"`
  var cs = spring:csNew(10) #just a magic number here
  #an STX is added at the beginning, indicating that the content is not a token but a whole string.
  spring:csAppend(cs, STX)
  var ch uint8
  var escape = false

  while !lex:lexerEof(lex) and utils:charCanBeInString(lex'peek, escape)
    ch = nextChar(lex)
    if ch == 0
      spring:csFree(cs)
      return null
    /if

    if !escape and ch == 92 # `\\`
      escape = true
    else
      spring:csAppend(cs, applyEscape(ch, escape))
    /if
  /while

  if lex:lexerEof(lex)
    spring:csFree(cs)
    lex'error = utils:errorLex(lex, "unexpected EOF in string body")
    return null
  /if

  if lex'peek != 34 # `"`
    spring:csFree(cs)
    var got [2] uint8
    got[0] = lex'peek
    got[1] = 0 # `\0` c string terminator

    lex'error = utils:errorMism(lex, "\"", got)
    return null
  /if

  return spring:csUnleash(cs)
/func

func lexExtractSym(lex ptr lex:Lexer) ptr uint8
  var cs = spring:csNew(10) #magic number
  var i uintptr = 0
  var ch uint8
  while !lex:lexerEof(lex) and utils:charIsSym(lex'peek) and i < 2
    ch = nextChar(lex)
    if ch == 0
      spring:csFree(cs)
      return null
    /if

    spring:csAppend(cs, ch)
  /while

  return spring:csUnleash(cs)
/func

func lexHandleId(lex ptr lex:Lexer) ptr uint8
  var cs = spring:csNew(10) #magic number
  var ch uint8

  while utils:charIsIdVal(lex'peek)
    ch = nextChar(lex)
    if ch == 0
      spring:csFree(cs)
      return null
    /if

    spring:csAppend(cs, ch)
  /while

  return spring:csUnleash(cs)
/func

func extractNextToken(lex ptr lex:Lexer) ptr uint8
  if lex'newline
    lex'newline = false
    return "\n"
  /if

  if spring:streamEnded(lex'file)
    return null
  /if

  var ch uint8
  while (ch = nextChar(lex)) != 0 and utils:charIsWhite(ch)
    #discard spaces, tabs and newlines
  /while
  if ch == 0
    return null
  /if

  if lex'peek == 35 # character `#` - means the beginning of a single line comment 
    lexDiscardComment(lex)
    return extractNextToken(lex)
  /if

  if lex'peek == 34 # character `"` - means the beginning of a string 
    return lexExtractString(lex)
  /if

  if utils:charIsSym(lex'peek)
    return lexExtractSym(lex)
  /if

  if utils:charIsPar(lex'peek)
    var str = cast<ptr uint8>(spring:zalloc(2 * size(uint8)))
    str[0] = nextChar(lex)
    return str
  /if

  return lexHandleId(lex)
/func

func lexerClose(lex ptr lex:Lexer)
  spring:streamClose(lex'file)
  spring:free(lex'filename)
  spring:free(lex)
/func

func lexerError(lexer ptr lex:Lexer) ptr spring:Error
  return lexer'error
/func

func lexerFromStream(stream ptr spring:Stream, name ptr uint8, err ptr ptr spring:Error) ptr lex:Lexer
  var ret = cast<ptr lex:Lexer>(spring:zalloc(size(ptr lex:Lexer)))

  ret'file = stream
  ret'line = 1
  ret'filename = spring:strclone(name)

  spring:streamRead(stream, ptr ret'peek, 1)
  if (val err = spring:streamError(stream)) != null
    return null
  /if

  return ret
/func

func lexerNew(fname ptr uint8, err ptr ptr spring:Error) ptr lex:Lexer
  var file = spring:fileOpen(fname, err)

  if val err != null
    return null
  /if

  return lexerFromStream(file, fname, err)
/func

func lexerNext(lexer ptr lex:Lexer) ptr lex:Token
  var begLine = lexer'line
  var begPos = lexer'pos

  var next = extractNextToken(lexer)
/func

func lexerEof(lexer ptr lex:Lexer) bool
  return spring:streamEnded(lexer'file)
/func

func tokenFree(tok ptr lex:Token)
  if tok != null
    spring:free(tok)
  /if
/func

func tokenNew(type uint8, value, begin, end, lineno uintptr) ptr lex:Token
  var ret = cast<ptr lex:Token>(spring:alloc(size(lex:Token)))
  ret'type = type
  ret'beginPos = begin
  ret'endPos = end
  ret'lineno = lineno
  ret'value = value
  return ret
/func

var LEX_EOF uint8 = 0

