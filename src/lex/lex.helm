#  Second Step - Experimental Helm Compiler
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2014
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the 
#  licenses expressed under Section 1.12 of the MPL v2. 

import lex
import spring
import utils

func nextChar(lex ptr lex:Lexer) uint8
  var ret = lex'peek

  spring:streamRead(lex'file, ptr lex'peek, 1)
  if (lex'error = spring:streamError(lex'file)) != null
    return 0
  /if

  lex'pos++

  if spring:streamEnded(lex'file)
    lex'peek = 4 #EOT
  /if

  if ret == 12 #carriage return
    if lex'peek != 10 #new line (Windows format case)
      lex'error = utils:errorLex(lex, "inconsistent end of line - no newline after carriage return")
      return 0
    /if
    return nextChar(lex)
  /if

  if lex'first
    lex'first = false
    lex'line++
    lex'pos = 1
  /if

  if ret == 10 # newline
    lex'first = true
  /if

  return ret
/func

func lexDiscardComment(lex ptr lex:Lexer)
  var ch uint8 = 0
  while !lex:lexerEof(lex) and ch != 10
    if (ch = nextChar(lex)) == 0 #discard
      return #exit on error
    /if
  /while
/func

var STX = 2 # There is no reason for using 2 and not another reserved character.

func applyEscape(ch uint8, escape bool) uint8

  if !escape
    return ch
  /if

  if ch == 97 # `a`
    return 7 # BEL
  /if

  if ch == 98 # `b` 
    return 8 # BS
  /if

  if ch == 110 # `n`
    return 10 # NL
  /if

  if ch == 114 # `r`
    return 13
  /if

  if ch == 116 # `t`
    return 9
  /if

  return ch

/func

func lexExtractString(lex ptr lex:Lexer) ptr uint8
  nextChar(lex) #discard the `"`
  var cs = spring:csNew(10) #just a magic number here
  #an STX is added at the beginning, indicating that the content is not a token but a whole string.
  spring:csAppend(cs, STX)
  var ch uint8
  var escape = false

  while !lex:lexerEof(lex) and utils:charCanBeInString(lex'peek, escape)
    ch = nextChar(lex)
    if ch == 0
      spring:csFree(cs)
      return null
    /if

    if !escape and ch == 92 # `\\`
      escape = true
    else
      spring:csAppend(cs, applyEscape(ch, escape))
    /if
  /while

  if lex:lexerEof(lex)
    spring:csFree(cs)
    lex'error = utils:errorLex(lex, "unexpected EOF in string body")
    return null
  /if

  if (ch = nextChar(lex)) != 34 # `"`
    spring:csFree(cs)
    var got [2] uint8
    got[0] = ch
    got[1] = 0 # `\0` c string terminator

    lex'error = utils:errorMism(lex, "\"", got)
    return null
  /if

  return spring:csUnleash(cs)
/func

func lexExtractSym(lex ptr lex:Lexer) ptr uint8
  var cs = spring:csNew(10) #magic number
  var i uintptr = 0
  var ch uint8
  while !lex:lexerEof(lex) and utils:charIsSym(lex'peek) and i < 2
    ch = nextChar(lex)
    if ch == 0
      spring:csFree(cs)
      return null
    /if

    spring:csAppend(cs, ch)
  /while

  return spring:csUnleash(cs)
/func

func lexHandleId(lex ptr lex:Lexer) ptr uint8
  var cs = spring:csNew(10) #magic number
  var ch uint8

  while utils:charIsIdVal(lex'peek)
    ch = nextChar(lex)
    if ch == 0
      spring:csFree(cs)
      return null
    /if

    spring:csAppend(cs, ch)
  /while

  return spring:csUnleash(cs)
/func

func extractNextToken(lex ptr lex:Lexer) ptr uint8

  if spring:streamEnded(lex'file)
    return null
  /if

  if utils:charIsWhite(lex'peek)
    var ch uint8
    while (ch = nextChar(lex)) != 0 and utils:charIsWhite(lex'peek)
      #discard spaces, tabs and newlines at the beginning of lines
    /while
    if ch == 0
      return null
    /if
  /if

  if lex'peek == 10 #character `\n` 
    nextChar(lex) #discard the `\n`
    lex'first = true
    return spring:strclone("\n")
  /if

  if lex'peek == 35 # character `#` - means the beginning of a single line comment 
    lexDiscardComment(lex)
    return extractNextToken(lex)
  /if

  if lex'peek == 34 # character `"` - means the beginning of a string 
    return lexExtractString(lex)
  /if

  if utils:charIsSym(lex'peek)
    return lexExtractSym(lex)
  /if

  if utils:charIsPar(lex'peek)
    var str = cast<ptr uint8>(spring:zalloc(2 * size(uint8)))
    str[0] = nextChar(lex)
    return str
  /if

  return lexHandleId(lex)
/func

func lexerClose(lex ptr lex:Lexer)
  spring:streamClose(lex'file)
  spring:free(lex'filename)
  spring:free(lex)
/func

func lexerError(lexer ptr lex:Lexer) ptr spring:Error
  return lexer'error
/func

func lexerFromStream(stream ptr spring:Stream, name ptr uint8, err ptr ptr spring:Error) ptr lex:Lexer
  var ret = cast<ptr lex:Lexer>(spring:zalloc(size(lex:Lexer)))

  ret'file = stream
  ret'line = 1
  ret'filename = spring:strclone(name)

  spring:streamRead(stream, ptr ret'peek, 1)
  if (val err = spring:streamError(stream)) != null
    return null
  /if

  return ret
/func

func lexerNew(fname ptr uint8, err ptr ptr spring:Error) ptr lex:Lexer
  var file = spring:fileOpen(fname, err)

  if val err != null
    return null
  /if

  return lexerFromStream(file, fname, err)
/func

func lexerEof(lexer ptr lex:Lexer) bool
  return spring:streamEnded(lexer'file)
/func

func tokenFree(tok ptr lex:Token)
  if tok != null
    spring:free(tok)
  /if
/func

func tokenNew(type uint16, value, begin, end, lineno uintptr) ptr lex:Token
  var ret = cast<ptr lex:Token>(spring:alloc(size(lex:Token)))
  ret'type = type
  ret'beginPos = begin
  ret'endPos = end
  ret'lineno = lineno
  ret'value = value
  return ret
/func

var EOF uint16 = 0
var NEWLINE uint16 = 10
var ALIAS uint16 = 20
var AMPER uint16 = 30
var AND uint16 = 40
var APOS uint16 = 50
var ASSIGN uint16 = 60
var BREAK uint16 = 70
var CAST uint16 = 80
var CBRAC uint16 = 90
var COLON uint16 = 100
var COMMA uint16 = 110
var CONTINUE uint16 = 120
var CPAR uint16 = 130
var DEC uint16 = 140
var DECL uint16 = 150
var DIFFERENT uint16 = 160
var DIV uint16 = 170
var ELSE uint16 = 180
var ENDENTRY uint16 = 190
var ENDFUNC uint16 = 200
var ENDIF uint16 = 210
var ENDWHILE uint16 = 220
var ENTRY uint16 = 230
var EQUAL uint16 = 240
var FUNC uint16 = 250
var ID uint16 = 260
var IF uint16 = 270
var IMPORT uint16 = 280
var INC uint16 = 290
var MAJEQ uint16 = 300
var MAJOR uint16 = 310
var MINEQ uint16 = 320
var MINOR uint16 = 330
var MINUS uint16 = 340
var MOD uint16 = 350
var MODULE uint16 = 360
var NOT uint16 = 380
var NUMBER uint16 = 390
var OBRAC uint16 = 400
var OPAR uint16 = 410
var OR uint16 = 420
var PIPE uint16 = 430
var PLUS uint16 = 440
var POW uint16 = 450
var PTR uint16 = 460
var RETURN uint16 = 470
var SIZE uint16 = 480
var STRING uint16 = 490
var STRUCT uint16 = 500
var TIMES uint16 = 510
var VAL uint16 = 520
var VAR uint16 = 530
var WHILE uint16 = 540
var XOR uint16 = 550

func lexerNext(lex ptr lex:Lexer) ptr lex:Token
  if lexerError(lex) != null
    return null
  /if

  if lexerEof(lex)
    return tokenNew(EOF, 0, lex'pos, lex'pos, lex'line)
  /if

  if lex'first
    lex'line++
    lex'pos = 0
  /if

  var strToken = lex'saved
  var begin = lex'pos

  if lex'saved == null
    strToken = extractNextToken(lex)
    if lexerError(lex) != null
      return null
    /if
  /if

  var type uint16 = 0
  var value uintptr = 0

  if spring:strequals(strToken, "\n")
    return tokenNew(NEWLINE, 0, begin, lex'pos, lex'line)
  /if

  if val strToken == STX # is a constant string
    type = STRING
    value = cast<uintptr>(spring:strclone(strToken + 1))
  /if

  if spring:strequals(strToken, "alias")
    type = ALIAS
  /if

  if spring:strequals(strToken, "and")
    type = AND
  /if

  if spring:strequals(strToken, "'")
    type = APOS
  /if

  if spring:strequals(strToken, "=")
    type = ASSIGN
  /if

  if spring:strequals(strToken, "break")
    type = BREAK
  /if

  if spring:strequals(strToken, "cast")
    type = CAST
  /if

  if spring:strequals(strToken, "]")
    type = CBRAC
  /if

  if spring:strequals(strToken, ":")
    type = COLON
  /if

  if spring:strequals(strToken, "continue")
    type = CONTINUE
  /if

  if spring:strequals(strToken, ")")
    type = CPAR
  /if

  if spring:strequals(strToken, "--")
    type = DEC
  /if

  if spring:strequals(strToken, "decl")
    type = DECL
  /if

  if spring:strequals(strToken, "!=")
    type = DIFFERENT
  /if

  if spring:strequals(strToken, "/")
    if lex'first and utils:charIsIdVal(lex'peek)
      lex'saved = extractNextToken(lex)
      if lexerError(lex) != null
        return null
      /if

      if spring:strequals(lex'saved, "equals")
        type = ENDENTRY
      /if

      if spring:strequals(lex'saved, "func")
        type = ENDFUNC
      /if

      if spring:strequals(lex'saved, "if")
        type = ENDIF
      /if

      if spring:strequals(lex'saved, "while")
        type = ENDWHILE
      /if

      if type == 0 # nothing has been matched, so it is a `/`
        type = DIV
      else
        spring:free(lex'saved)
        lex'saved = null
      /if
    /if
  /if

  if spring:strequals(strToken, "else")
    type = ELSE
  /if

  if spring:strequals(strToken, "entry")
    type = ENTRY
  /if

  if spring:strequals(strToken, "==")
    type = EQUAL
  /if

  if spring:strequals(strToken, "func")
    type = FUNC
  /if

  if spring:strequals(strToken, "if")
    type = IF
  /if

  if spring:strequals(strToken, "import")
    type = IMPORT
  /if

  if spring:strequals(strToken, "++")
    type = INC
  /if

  if spring:strequals(strToken, ">=")
    type = MAJEQ
  /if

  if spring:strequals(strToken, ">")
    type = MAJOR
  /if

  if spring:strequals(strToken, "<=")
    type = MINEQ
  /if

  if spring:strequals(strToken, "<")
    type = MINOR
  /if

  if spring:strequals(strToken, "-")
    type = MINUS
  /if

  if spring:strequals(strToken, "mod")
    type = MOD
  /if

  if spring:strequals(strToken, "module")
    type = MODULE
  /if

  if spring:strequals(strToken, "!")
    type = NOT
  /if

  if spring:strequals(strToken, "[")
    type = OBRAC
  /if

  if spring:strequals(strToken, "(")
    type = OPAR
  /if

  if spring:strequals(strToken, "or")
    type = OR
  /if

  if spring:strequals(strToken, "|")
    type = PIPE
  /if

  if spring:strequals(strToken, "+")
    type = PLUS
  /if

  if spring:strequals(strToken, "^")
    type = POW
  /if

  if spring:strequals(strToken, "ptr")
    type = PTR
  /if

  if spring:strequals(strToken, "return")
    type = RETURN
  /if

  if spring:strequals(strToken, "size")
    type = SIZE
  /if

  if spring:strequals(strToken, "struct")
    type = STRUCT
  /if

  if spring:strequals(strToken, "*")
    type = TIMES
  /if

  if spring:strequals(strToken, "val")
    type = VAL
  /if

  if spring:strequals(strToken, "var")
    type = VAR
  /if

  if spring:strequals(strToken, "while")
    type = WHILE
  /if

  if spring:strequals(strToken, "xor")
    type = XOR
  /if

  if utils:strIsUInt(strToken)
    type = NUMBER
    value = spring:strtonum(strToken)
  /if

  if type == 0 # if it's still unmodified, then it's an identifier
    type = ID
    value = cast<uintptr>(strToken)
  else
    spring:free(strToken)
  /if

  lex'first = false
  return tokenNew(type, value, begin, lex'pos, lex'line)
/func

func tokenStr(tok ptr lex:Token) ptr uint8
  if tok'type == EOF
    return "Eof"
  /if

  if tok'type == NEWLINE
    return "Newline"
  /if

  if tok'type == ALIAS
    return "alias"
  /if

  if tok'type == AMPER
    return "&"
  /if

  if tok'type == AND
    return "and"
  /if

  if tok'type == APOS
    return "'"
  /if

  if tok'type == ASSIGN
    return "="
  /if

  if tok'type == BREAK
    return "break"
  /if

  if tok'type == CAST
    return "cast"
  /if

  if tok'type == CBRAC
    return "]"
  /if

  if tok'type == COLON
    return ":"
  /if

  if tok'type == COMMA
    return ","
  /if

  if tok'type == CONTINUE
    return "continue"
  /if

  if tok'type == CPAR
    return ")"
  /if

  if tok'type == DEC
    return "--"
  /if

  if tok'type == DECL
    return "decl"
  /if

  if tok'type == DIFFERENT
    return "!="
  /if

  if tok'type == DIV
    return "/"
  /if

  if tok'type == ELSE
    return "else"
  /if

  if tok'type == ENDENTRY
    return "/entry"
  /if

  if tok'type == ENDFUNC
    return "/func"
  /if

  if tok'type == ENDIF
    return "/if"
  /if

  if tok'type == ENDWHILE
    return "/while"
  /if

  if tok'type == ENTRY
    return "entry"
  /if

  if tok'type == EQUAL
    return "=="
  /if

  if tok'type == FUNC
    return "func"
  /if

  if tok'type == ID
    return "an identifier"
  /if

  if tok'type == IF
    return "if"
  /if

  if tok'type == IMPORT
    return "import"
  /if

  if tok'type == INC
    return "++"
  /if

  if tok'type == MAJEQ
    return ">="
  /if

  if tok'type == MAJOR
    return ">"
  /if

  if tok'type == MINEQ
    return "<="
  /if

  if tok'type == MINOR
    return "<"
  /if

  if tok'type == MINUS
    return "-"
  /if

  if tok'type == MOD
    return "mod"
  /if

  if tok'type == MODULE
    return "module"
  /if

  if tok'type == NOT
    return "!"
  /if

  if tok'type == NUMBER
    return "a number"
  /if

  if tok'type == OBRAC
    return "["
  /if

  if tok'type == OPAR
    return "("
  /if

  if tok'type == OR
    return "or"
  /if

  if tok'type == PIPE
    return "|"
  /if

  if tok'type == PLUS
    return "+"
  /if

  if tok'type == POW
    return "^"
  /if

  if tok'type == PTR
    return "ptr"
  /if

  if tok'type == RETURN
    return "return"
  /if

  if tok'type == SIZE
    return "size"
  /if

  if tok'type == STRING
    return "a string"
  /if

  if tok'type == STRUCT
    return "struct"
  /if

  if tok'type == TIMES
    return "*"
  /if

  if tok'type == VAL
    return "val"
  /if

  if tok'type == VAR
    return "var"
  /if

  if tok'type == WHILE
    return "while"
  /if

  return "xor"

/func
