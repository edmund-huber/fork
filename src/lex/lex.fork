#  libfork, a base library for the Fork language
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2014, 2015
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the
#  licenses expressed under Section 1.12 of the MPL v2.


module lex


import ast
import err
import file
import io
import lex
import mem
import parser
import tokens
import txt
import utils


alias Char struct(ch uint8, pos uintptr)


func strtokNew(str ptr uint8, line,begin,end uintptr) ptr lex:StringTok
  mut strTok = cast<ptr lex:StringTok>(mem:zalloc(size(lex:StringTok)))

  strTok'str = str

  strTok'begin = begin
  strTok'end = end
  strTok'line = line

  return strTok
/func


func strtokFree(stok ptr lex:StringTok)
  if stok != null
    mem:free(stok)
  /if
/func


func nextChar(lex ptr lex:Lexer) Char
  mut ret Char
  ret'ch = lex'peek
  ret'pos = 0

  io:streamRead(lex'file, ptr lex'peek, 1)
  if (lex'error = io:streamError(lex'file)) != null
    ret'ch = 0
    return ret
  /if

  lex'lineno'pos++

  ret'pos = lex'lineno'pos

  if io:streamEnded(lex'file)
    lex'peek = 0
  /if

  if ret'ch == 12 #carriage return
    if lex'peek != 10 #new line (Windows format case)
      lex'error = lex:errorLex(lex, "inconsistent end of line - no newline after carriage return")
      ret'ch = 0
      return ret
    /if
    return nextChar(lex)
  /if

  if lex'firstLineLetter
    lex'firstLineLetter = false
    lex'lineno'lineno++
    lex'lineno'pos = 1
  /if

  if ret'ch == 10 # newline
    lex'firstLineLetter = true
  /if

  return ret
/func


func lexDiscardComment(lex ptr lex:Lexer)
  mut ch Char
  ch'ch = 0
  while !lex:lexerEof(lex) and ch'ch != 10
    if (ch = nextChar(lex))'ch == 0 #discard
      return #exit on error
    /if
  /while

/func


mut STX = 2 # There is no reason for using 2 and not another reserved character.


func applyEscape(ch uint8, escape bool) uint8

  if !escape
    return ch
  /if

  if ch == 97 # `a`
    return 7 # BEL
  /if

  if ch == 98 # `b`
    return 8 # BS
  /if

  if ch == 110 # `n`
    return 10 # NL
  /if

  if ch == 114 # `r`
    return 13
  /if

  if ch == 116 # `t`
    return 9
  /if

  return ch
/func


func lexExtractString(lex ptr lex:Lexer) ptr lex:StringTok
  mut ch = nextChar(lex) #discard the `"`
  mut begin = ch'pos

  mut cs = txt:csNew(10) #just a magic number here
  #an STX is added at the beginning, indicating that the content is not a token but a whole string.
  txt:csAppend(cs, STX)

  mut escape = false

  while !lex:lexerEof(lex) and utils:charCanBeInString(lex'peek, escape)
    ch = nextChar(lex)
    if ch'ch == 0
      txt:csFree(cs)
      return null
    /if

    if !escape and ch'ch == 92 # `\\`
      escape = true
    else
      txt:csAppend(cs, applyEscape(ch'ch, escape))
      escape = false
    /if
  /while

  if lex:lexerEof(lex)
    txt:csFree(cs)
    lex'error = lex:errorLex(lex, "unexpected EOF in string body")
    return null
  /if

  if (ch = nextChar(lex))'ch != 34 # `"`
    txt:csFree(cs)
    mut got [2] uint8
    got[0] = ch'ch
    got[1] = 0 # `\0` c string terminator

    lex'error = parser:issueToError(lex:errorMism(lex'lineno, "\"", ptr got[0]))
    return null
  /if

  return strtokNew(txt:csUnwrap(cs), lex'lineno'lineno, begin, ch'pos)
/func


func lexExtractSym(lex ptr lex:Lexer) ptr lex:StringTok
  mut cs = txt:csNew(10) #magic number
  mut i uintptr = 0
  mut ch Char
  mut first = true
  mut begin uintptr = 0

  while !lex:lexerEof(lex) and utils:charIsSym(lex'peek) and i < 2
    ch = nextChar(lex)
    if ch'ch == 0
      txt:csFree(cs)
      return null
    /if

    if first
      begin = ch'pos
      first = false
    /if

    txt:csAppend(cs, ch'ch)
  /while

  return strtokNew(txt:csUnwrap(cs), lex'lineno'lineno, begin, ch'pos)
/func


func lexHandleId(lex ptr lex:Lexer) ptr lex:StringTok
  mut cs = txt:csNew(10) #magic number
  mut ch Char
  mut begin uintptr
  mut first = true

  while utils:charIsIdVal(lex'peek)
    ch = nextChar(lex)
    if ch'ch == 0
      txt:csFree(cs)
      return null
    /if

    if first
      begin = ch'pos
      first = false
    /if

    txt:csAppend(cs, ch'ch)
  /while

  return strtokNew(txt:csUnwrap(cs), lex'lineno'lineno, begin, ch'pos)
/func


func extractNextToken(lex ptr lex:Lexer) ptr lex:StringTok

  if io:streamEnded(lex'file)
    return null
  /if

  while utils:charIsWhite(lex'peek)
    mut ch = nextChar(lex)
    if ch'ch == 10 and !lex'firstLineTok #character `\n`
      lex'firstLineTok = true
      lex'newline = true
    /if
  /while
  if lex'peek == 0
    return null
  /if

  if lex'peek == 35 # character `#` - means the beginning of a single line comment
    lexDiscardComment(lex)
    if !lex:lexerEof(lex) and !lex'firstLineTok
      lex'newline = true
      lex'firstLineTok = true
    /if

    return extractNextToken(lex)
  /if

  if lex'peek == 34 # character `"` - means the beginning of a string
    return lexExtractString(lex)
  /if

  if utils:charIsSym(lex'peek)
    return lexExtractSym(lex)
  /if

  if utils:charIsPar(lex'peek)
    mut str = cast<ptr uint8>(mem:zalloc(2 * size(uint8)))
    mut par = nextChar(lex)
    str[0] = par'ch
    return strtokNew(str, lex'lineno'lineno, par'pos, par'pos)
  /if

  lex'firstLineTok = false

  return lexHandleId(lex)
/func


func lexerClose(lex ptr lex:Lexer)
  io:streamClose(lex'file)
  lex:linenoFree(lex'lineno)
  mem:free(lex)
/func


func lexerError(lexer ptr lex:Lexer) ptr err:Error
  return lexer'error
/func


func lexerFromStream(stream ptr io:Stream, name ptr uint8, err ptr ptr err:Error) ptr lex:Lexer
  mut ret = cast<ptr lex:Lexer>(mem:zalloc(size(lex:Lexer)))

  ret'file = stream
  ret'lineno = lex:linenoNew(txt:strclone(name),0,0)
  ret'firstLineTok = true
  ret'firstLineLetter = true

  io:streamRead(stream, ptr ret'peek, 1)
  if (val err = io:streamError(stream)) != null
    return null
  /if

  return ret
/func

func lexerNew(fname ptr uint8, err ptr ptr err:Error) ptr lex:Lexer
  mut file = file:fileOpen(fname, err)

  if val err != null
    return null
  /if

  return lexerFromStream(file, fname, err)
/func

func lexerEof(lexer ptr lex:Lexer) bool
  return io:streamEnded(lexer'file)
/func

func tokenNew(type uint16, value uintptr, lineno ptr lex:Lineno, end uintptr) ptr lex:Token
  mut ret = cast<ptr lex:Token>(mem:alloc(size(lex:Token)))
  ret'type = type
  ret'endPos = end
  ret'lineno = lineno
  ret'value = value
  return ret
/func

func tokenFree(tok ptr lex:Token)
  if tok != null
    if (tok'type == tokens:ID or tok'type == tokens:STRING) and tok'value != 0
      mem:free(cast<data>(tok'value))
    /if
    lex:linenoFree(tok'lineno)
    mem:free(tok)
  /if
/func


func errorLex(lex ptr lex:Lexer, msg ptr uint8) ptr err:Error
  mut toglue [4] ptr uint8

  toglue[0] = lex'lineno'filename
  toglue[1] = ": "
  toglue[2] = msg
  toglue[3] = null

  return err:errorGlue(ptr toglue[0])
/func


func lexerNext(lex ptr lex:Lexer) ptr lex:Token
  if lexerEof(lex)
    return null
  /if

  if lexerError(lex) != null
    return null
  /if

  mut stringToken = lex'saved

  if lex'saved == null
    stringToken = extractNextToken(lex)
    if lexerError(lex) != null
      return null
    /if
  else
    lex'saved = null

    # this is needed because this field is set to false only by extractNextToken.
    # if the saved one is the firstLineTok, then the next extractNextToken will still think
    # we're at the beginning of the line. This fixes it.
    if lex'firstLineTok
      lex'firstLineTok = false
    /if
  /if

  if stringToken == null
    return null
  /if

  mut begin = lex:linenoClone(lex'lineno)
  begin'pos = stringToken'begin
  mut endPos = stringToken'end

  mut type uint16 = 0
  mut value uintptr = 0

  if lex'newline
    lex'saved = stringToken
    lex'newline = false

    begin'lineno--
    begin'pos = 0

    return tokenNew(tokens:NEWLINE, 0, begin, 0)
  /if

  mut strToken = stringToken'str

  if val strToken == STX # is a constant string
    type = tokens:STRING
    value = cast<uintptr>(txt:strclone(strToken + 1))
  /if

  if txt:strequals(strToken, "alias")
    type = tokens:ALIAS
  /if

  if txt:strequals(strToken, "&")
    type = tokens:AMPER
  /if

  if txt:strequals(strToken, "and")
    type = tokens:AND
  /if

  if txt:strequals(strToken, "'")
    type = tokens:APOS
  /if

  if txt:strequals(strToken, "=")
    type = tokens:ASSIGN
  /if

  if txt:strequals(strToken, "break")
    type = tokens:BREAK
  /if

  if txt:strequals(strToken, "cast")
    type = tokens:CAST
  /if

  if txt:strequals(strToken, "]")
    type = tokens:CBRAC
  /if

  if txt:strequals(strToken, ":")
    type = tokens:COLON
  /if

  if txt:strequals(strToken, ",")
    type = tokens:COMMA
  /if

  if txt:strequals(strToken, "continue")
    type = tokens:CONTINUE
  /if

  if txt:strequals(strToken, ")")
    type = tokens:CPAR
  /if

  if txt:strequals(strToken, "--")
    type = tokens:DEC
  /if

  if txt:strequals(strToken, "decl")
    type = tokens:DECL
  /if

  if txt:strequals(strToken, "!=")
    type = tokens:DIFFERENT
  /if

  if txt:strequals(strToken, ".")
    type = tokens:DOT
  /if

  if txt:strequals(strToken, "??")
    type = tokens:DQUEST
  /if

  if txt:strequals(strToken, "mod")
    type = tokens:MOD
  /if

  if txt:strequals(strToken, "/")
    if utils:charIsIdVal(lex'peek)
      lex'saved = extractNextToken(lex)
      if lexerError(lex) != null
        return null
      /if

      mut savedTok = lex'saved'str

      if txt:strequals(savedTok, "entry")
        type = tokens:ENDENTRY
      /if

      if txt:strequals(savedTok, "func")
        type = tokens:ENDFUNC
      /if

      if txt:strequals(savedTok, "if")
        type = tokens:ENDIF
      /if

      if txt:strequals(savedTok, "method")
        type = tokens:ENDMETHOD
      /if

      if txt:strequals(savedTok, "while")
        type = tokens:ENDWHILE
      /if

      if type != 0
        endPos = lex'saved'end
        mem:free(savedTok)
        strtokFree(lex'saved)
        lex'saved = null
      /if
    /if
    if type == 0 # nothing has been matched, so it is a `/`
        type = tokens:DIV
    /if
  /if

  if txt:strequals(strToken, "else")
    type = tokens:ELSE
  /if

  if txt:strequals(strToken, "entry")
    type = tokens:ENTRY
  /if

  if txt:strequals(strToken, "==")
    type = tokens:EQUAL
  /if

  if txt:strequals(strToken, "false")
    type = tokens:FALSE
  /if

  if txt:strequals(strToken, "=>")
    type = tokens:FATARROW
  /if

  if txt:strequals(strToken, "func")
    type = tokens:FUNC
  /if

  if txt:strequals(strToken, "if")
    type = tokens:IF
  /if

  if txt:strequals(strToken, "import")
    type = tokens:IMPORT
  /if

  if txt:strequals(strToken, "++")
    type = tokens:INC
  /if

  if txt:strequals(strToken, ">=")
    type = tokens:MAJEQ
  /if

  if txt:strequals(strToken, ">")
    type = tokens:MAJOR
  /if

  if txt:strequals(strToken, "me")
    type = tokens:ME
  /if

  if txt:strequals(strToken, "method")
    type = tokens:METHOD
  /if

  if txt:strequals(strToken, "<=")
    type = tokens:MINEQ
  /if

  if txt:strequals(strToken, "<")
    type = tokens:MINOR
  /if

  if txt:strequals(strToken, "-")
    type = tokens:MINUS
  /if

  if txt:strequals(strToken, "module")
    type = tokens:MODULE
  /if

  if txt:strequals(strToken, "mut")
    type = tokens:MUT
  /if

  if txt:strequals(strToken, "!")
    type = tokens:NOT
  /if

  if txt:strequals(strToken, "null")
    type = tokens:NULL
  /if

  if txt:strequals(strToken, "[")
    type = tokens:OBRAC
  /if

  if txt:strequals(strToken, "(")
    type = tokens:OPAR
  /if

  if txt:strequals(strToken, "or")
    type = tokens:OR
  /if

  if txt:strequals(strToken, "|")
    type = tokens:PIPE
  /if

  if txt:strequals(strToken, "+")
    type = tokens:PLUS
  /if

  if txt:strequals(strToken, "**")
    type = tokens:POW
  /if

  if txt:strequals(strToken, "ptr")
    type = tokens:PTR
  /if

  if txt:strequals(strToken, "?")
    type = tokens:QUEST
  /if

  if txt:strequals(strToken, "return")
    type = tokens:RETURN
  /if

  if txt:strequals(strToken, "||")
    type = tokens:SEPARATOR
  /if

  if txt:strequals(strToken, "size")
    type = tokens:SIZE
  /if

  if txt:strequals(strToken, "struct")
    type = tokens:STRUCT
  /if

  if txt:strequals(strToken, "*")
    type = tokens:TIMES
  /if

  if txt:strequals(strToken, "true")
    type = tokens:TRUE
  /if

  if txt:strequals(strToken, "::")
    type = tokens:TWOCOLONS
  /if

  if txt:strequals(strToken, "val")
    type = tokens:VAL
  /if

  if txt:strequals(strToken, "while")
    type = tokens:WHILE
  /if

  if txt:strequals(strToken, "^")
    type = tokens:XOR
  /if

  if utils:strIsUInt(strToken)
    type = tokens:NUMBER
    value = txt:strtonum(strToken)
  /if

  if type == 0 # if it's still unmodified, then it's an identifier
    type = tokens:ID
    value = cast<uintptr>(strToken)
  else
    mem:free(strToken)
  /if

  strtokFree(stringToken)

  return tokenNew(type, value, begin, endPos)
/func


func ttypeStr(tt uint16) ptr uint8
  if tt == tokens:EOF
    return "Eof"
  /if

  if tt == tokens:NEWLINE
    return "a newline"
  /if

  if tt == tokens:ALIAS
    return "alias"
  /if

  if tt == tokens:AMPER
    return "&"
  /if

  if tt == tokens:AND
    return "and"
  /if

  if tt == tokens:APOS
    return "'"
  /if

  if tt == tokens:ASSIGN
    return "="
  /if

  if tt == tokens:BREAK
    return "break"
  /if

  if tt == tokens:CAST
    return "cast"
  /if

  if tt == tokens:CBRAC
    return "]"
  /if

  if tt == tokens:COLON
    return ":"
  /if

  if tt == tokens:COMMA
    return ","
  /if

  if tt == tokens:CONTINUE
    return "continue"
  /if

  if tt == tokens:CPAR
    return ")"
  /if

  if tt == tokens:DEC
    return "--"
  /if

  if tt == tokens:DECL
    return "decl"
  /if

  if tt == tokens:DIFFERENT
    return "!="
  /if

  if tt == tokens:DIV
    return "/"
  /if

  if tt == tokens:DOT
    return "."
  /if

  if tt == tokens:DQUEST
    return "??"
  /if

  if tt == tokens:ELSE
    return "else"
  /if

  if tt == tokens:ENDENTRY
    return "/entry"
  /if

  if tt == tokens:ENDFUNC
    return "/func"
  /if

  if tt == tokens:ENDIF
    return "/if"
  /if

  if tt == tokens:ENDMETHOD
    return "/method"
  /if

  if tt == tokens:ENDWHILE
    return "/while"
  /if

  if tt == tokens:ENTRY
    return "entry"
  /if

  if tt == tokens:EQUAL
    return "=="
  /if

  if tt == tokens:FALSE
    return "false"
  /if

  if tt == tokens:FATARROW
    return "=>"
  /if

  if tt == tokens:FUNC
    return "func"
  /if

  if tt == tokens:ID
    return "an identifier"
  /if

  if tt == tokens:IF
    return "if"
  /if

  if tt == tokens:IMPORT
    return "import"
  /if

  if tt == tokens:INC
    return "++"
  /if

  if tt == tokens:MAJEQ
    return ">="
  /if

  if tt == tokens:MAJOR
    return ">"
  /if

  if tt == tokens:ME
    return "me"
  /if

  if tt == tokens:METHOD
    return "method"
  /if

  if tt == tokens:MINEQ
    return "<="
  /if

  if tt == tokens:MINOR
    return "<"
  /if

  if tt == tokens:MINUS
    return "-"
  /if

  if tt == tokens:MOD
    return "mod"
  /if

  if tt == tokens:MODULE
    return "module"
  /if

  if tt == tokens:MUT
    return "mut"
  /if

  if tt == tokens:NOT
    return "!"
  /if

  if tt == tokens:NULL
    return "null"
  /if

  if tt == tokens:NUMBER
    return "a number"
  /if

  if tt == tokens:OBRAC
    return "["
  /if

  if tt == tokens:OPAR
    return "("
  /if

  if tt == tokens:OR
    return "or"
  /if

  if tt == tokens:PIPE
    return "|"
  /if

  if tt == tokens:PLUS
    return "+"
  /if

  if tt == tokens:POW
    return "**"
  /if

  if tt == tokens:PTR
    return "ptr"
  /if

  if tt == tokens:QUEST
    return "?"
  /if

  if tt == tokens:RETURN
    return "return"
  /if

  if tt == tokens:SEPARATOR
    return "||"
  /if

  if tt == tokens:SIZE
    return "size"
  /if

  if tt == tokens:STRING
    return "a string"
  /if

  if tt == tokens:STRUCT
    return "struct"
  /if

  if tt == tokens:TIMES
    return "*"
  /if

  if tt == tokens:TRUE
    return "true"
  /if

  if tt == tokens:UMINUS
    return "- (Unary)"
  /if

  if tt == tokens:VAL
    return "val"
  /if

  if tt == tokens:WHILE
    return "while"
  /if

  if tt == tokens:XOR
    return "^"
  /if

  return "<unknown, please, report!>"
/func


func tokenStr(tok ptr lex:Token) ptr uint8
  return lex:ttypeStr(tok == null => tokens:EOF || tok'type)
/func


func linenoClone(lineno ptr lex:Lineno) ptr lex:Lineno
  return lex:linenoNew(txt:strclone(lineno'filename), lineno'lineno, lineno'pos)
/func


func linenoFree(lineno ptr lex:Lineno)
  if lineno != null
    mem:free(lineno'filename)
    mem:free(lineno)
  /if
/func


func linenoNew(filename ptr uint8, lineno, pos uintptr) ptr lex:Lineno
  mut ret = cast<ptr lex:Lineno>(mem:alloc(size(lex:Lineno)))

  ret'filename = filename
  ret'lineno = lineno
  ret'pos = pos

  return ret
/func


func issueFromLexError(err ptr err:Error, lineno ptr lex:Lineno) ptr parser:Issue
  if err == null
    return null
  /if

  mut where ast:Line
  where'line = lineno'lineno
  where'pos = lineno'pos

  mut ret = parser:issueNew(parser:ISSUE_ERR, where, lineno'filename, err'msg)

  err:errorFree(err)

  return ret
/func


func lineMake(llin ptr lex:Lineno) ast:Line
  mut ret ast:Line

  ret'line = llin'lineno
  ret'pos =  llin'pos

  return ret
/func


func tokExtractBegin(tok ptr lex:Token) ast:Line
  mut ret ast:Line
  ret'line = tok'lineno'lineno
  ret'pos = tok'lineno'pos

  return ret
/func


func tokExtractEnd(tok ptr lex:Token) ast:Line
  mut ret ast:Line
  ret'line = tok'lineno'lineno
  ret'pos = tok'endPos

  return ret
/func


func tokDiscardBegin(tok ptr lex:Token) ast:Line
  mut ret = tokExtractBegin(tok)

  lex:tokenFree(tok)

  return ret
/func


func tokDiscardEnd(tok ptr lex:Token) ast:Line
  mut ret = tokExtractEnd(tok)

  lex:tokenFree(tok)

  return ret
/func


func error(lineno ptr lex:Lineno, msg ptr uint8) ptr parser:Issue
  mut line ast:Line
  line'line = lineno'lineno
  line'pos = lineno'pos

  return parser:issueNew(parser:ISSUE_ERR, line, lineno'filename, msg)
/func


func errorMism(lineno ptr lex:Lineno, exp ptr uint8, got ptr uint8) ptr parser:Issue

  mut toglue [5] ptr uint8
  toglue[0] = "expected "
  toglue[1] = exp
  toglue[2] = ", got "
  toglue[3] = got
  toglue[4] = null

  mut glued = txt:strglue(ptr toglue[0])
  mut ret =  lex:error(lineno, glued)

  mem:free(glued)

  return ret
/func
