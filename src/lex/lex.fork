#  Second Step - Experimental Fork Compiler
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2014
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the
#  licenses expressed under Section 1.12 of the MPL v2.

import lex
import spring
import utils

func nextChar(lex ptr lex:Lexer) uint8
  mut ret = lex'peek

  spring:streamRead(lex'file, ptr lex'peek, 1)
  if (lex'error = spring:streamError(lex'file)) != null
    return 0
  /if

  lex'lineno'pos++

  if spring:streamEnded(lex'file)
    lex'peek = 0
  /if

  if ret == 12 #carriage return
    if lex'peek != 10 #new line (Windows format case)
      lex'error = utils:errorLex(lex, "inconsistent end of line - no newline after carriage return")
      return 0
    /if
    return nextChar(lex)
  /if

  if lex'firstLineLetter
    lex'firstLineLetter = false
    lex'lineno'lineno++
    lex'lineno'pos = 1
  /if

  if ret == 10 # newline
    lex'firstLineLetter = true
  /if

  return ret
/func

func linenoClone(lineno ptr lex:Lineno) ptr lex:Lineno
  return lex:linenoNew(spring:strclone(lineno'filename), lineno'lineno, lineno'pos)
/func

func linenoFree(lineno ptr lex:Lineno)
  if lineno != null
    spring:free(lineno'filename)
    spring:free(lineno)
  /if
/func

func linenoNew(filename ptr uint8, lineno, pos uint16) ptr lex:Lineno
  mut ret = cast<ptr lex:Lineno>(spring:alloc(size(lex:Lineno)))

  ret'filename = filename
  ret'lineno = lineno
  ret'pos = pos

  return ret
/func

func lexDiscardComment(lex ptr lex:Lexer)
  mut ch uint8 = 0
  while !lex:lexerEof(lex) and ch != 10
    if (ch = nextChar(lex)) == 0 #discard
      return #exit on error
    /if
  /while

/func

mut STX = 2 # There is no reason for using 2 and not another reserved character.

func applyEscape(ch uint8, escape bool) uint8

  if !escape
    return ch
  /if

  if ch == 97 # `a`
    return 7 # BEL
  /if

  if ch == 98 # `b`
    return 8 # BS
  /if

  if ch == 110 # `n`
    return 10 # NL
  /if

  if ch == 114 # `r`
    return 13
  /if

  if ch == 116 # `t`
    return 9
  /if

  return ch
/func

func lexExtractString(lex ptr lex:Lexer) ptr uint8
  nextChar(lex) #discard the `"`
  mut cs = spring:csNew(10) #just a magic number here
  #an STX is added at the beginning, indicating that the content is not a token but a whole string.
  spring:csAppend(cs, STX)
  mut ch uint8
  mut escape = false

  while !lex:lexerEof(lex) and utils:charCanBeInString(lex'peek, escape)
    ch = nextChar(lex)
    if ch == 0
      spring:csFree(cs)
      return null
    /if

    if !escape and ch == 92 # `\\`
      escape = true
    else
      spring:csAppend(cs, applyEscape(ch, escape))
      escape = false
    /if
  /while

  if lex:lexerEof(lex)
    spring:csFree(cs)
    lex'error = utils:errorLex(lex, "unexpected EOF in string body")
    return null
  /if

  if (ch = nextChar(lex)) != 34 # `"`
    spring:csFree(cs)
    mut got [2] uint8
    got[0] = ch
    got[1] = 0 # `\0` c string terminator

    lex'error = utils:errorMism(lex'lineno, "\"", got)
    return null
  /if

  return spring:csUnleash(cs)
/func

func lexExtractSym(lex ptr lex:Lexer) ptr uint8
  mut cs = spring:csNew(10) #magic number
  mut i uintptr = 0
  mut ch uint8
  while !lex:lexerEof(lex) and utils:charIsSym(lex'peek) and i < 2
    ch = nextChar(lex)
    if ch == 0
      spring:csFree(cs)
      return null
    /if

    spring:csAppend(cs, ch)
  /while

  return spring:csUnleash(cs)
/func

func lexHandleId(lex ptr lex:Lexer) ptr uint8
  mut cs = spring:csNew(10) #magic number
  mut ch uint8

  while utils:charIsIdVal(lex'peek)
    ch = nextChar(lex)
    if ch == 0
      spring:csFree(cs)
      return null
    /if

    spring:csAppend(cs, ch)
  /while

  return spring:csUnleash(cs)
/func

func extractNextToken(lex ptr lex:Lexer) ptr uint8

  if spring:streamEnded(lex'file)
    return null
  /if

  mut ch uint8
  while utils:charIsWhite(lex'peek)
    ch = nextChar(lex)
    if ch == 10 and !lex'firstLineTok #character `\n`
      lex'firstLineTok = true
      lex'newline = true
    /if
  /while
  if lex'peek == 0
    return null
  /if

  if lex'peek == 35 # character `#` - means the beginning of a single line comment
    lexDiscardComment(lex)
    if !lex:lexerEof(lex) and !lex'firstLineTok
      lex'newline = true
      lex'firstLineTok = true
    /if

    return extractNextToken(lex)
  /if

  if lex'peek == 34 # character `"` - means the beginning of a string
    return lexExtractString(lex)
  /if

  if utils:charIsSym(lex'peek)
    return lexExtractSym(lex)
  /if

  if utils:charIsPar(lex'peek)
    mut str = cast<ptr uint8>(spring:zalloc(2 * size(uint8)))
    str[0] = nextChar(lex)
    return str
  /if

  lex'firstLineTok = false

  return lexHandleId(lex)
/func

func lexerClose(lex ptr lex:Lexer)
  spring:streamClose(lex'file)
  lex:linenoFree(lex'lineno)
  spring:free(lex)
/func

func lexerError(lexer ptr lex:Lexer) ptr spring:Error
  return lexer'error
/func

func lexerFromStream(stream ptr spring:Stream, name ptr uint8, err ptr ptr spring:Error) ptr lex:Lexer
  mut ret = cast<ptr lex:Lexer>(spring:zalloc(size(lex:Lexer)))

  ret'file = stream
  ret'lineno = lex:linenoNew(spring:strclone(name),0,0)
  ret'firstLineTok = true

  spring:streamRead(stream, ptr ret'peek, 1)
  if (val err = spring:streamError(stream)) != null
    return null
  /if

  return ret
/func

func lexerNew(fname ptr uint8, err ptr ptr spring:Error) ptr lex:Lexer
  mut file = spring:fileOpen(fname, err)

  if val err != null
    return null
  /if

  return lexerFromStream(file, fname, err)
/func

func lexerEof(lexer ptr lex:Lexer) bool
  return spring:streamEnded(lexer'file)
/func

func tokenNew(type uint16, value uintptr, lineno ptr lex:Lineno, end uintptr) ptr lex:Token
  mut ret = cast<ptr lex:Token>(spring:alloc(size(lex:Token)))
  ret'type = type
  ret'endPos = end
  ret'lineno = lineno
  ret'value = value
  return ret
/func

func tokenFree(tok ptr lex:Token)
  if tok != null
    if (tok'type == lex:ID or tok'type == lex:STRING) and tok'value != 0
      spring:free(cast<data>(tok'value))
    /if
    lex:linenoFree(tok'lineno)
    spring:free(tok)
  /if
/func

func lexerNext(lex ptr lex:Lexer) ptr lex:Token
  if lexerEof(lex)
    return tokenNew(lex:EOF, 0, lex:linenoClone(lex'lineno), lex'lineno'pos)
  /if

  if lexerError(lex) != null
    return null
  /if

  mut strToken = lex'saved
  mut begin = val lex'lineno

  if lex'saved == null
    strToken = extractNextToken(lex)
    if lexerError(lex) != null
      return null
    /if
  else
    lex'saved = null

    # this is needed because this field is set to false only by extractNextToken.
    # if the saved one is the firstLineTok, then the next extractNextToken will still think
    # we're at the beginning of the line. This fixes it.
    if lex'firstLineTok
      lex'firstLineTok = false
    /if
  /if

  if strToken == null
    return null
  /if

  mut type uint16 = 0
  mut value uintptr = 0

  if lex'newline
    lex'saved = strToken
    lex'newline = false
    return tokenNew(lex:NEWLINE, 0, lex:linenoClone(ptr begin), lex'lineno'pos)
  /if

  if val strToken == STX # is a constant string
    type = lex:STRING
    value = cast<uintptr>(spring:strclone(strToken + 1))
  /if

  if spring:strequals(strToken, "alias")
    type = lex:ALIAS
  /if

  if spring:strequals(strToken, "and")
    type = lex:AND
  /if

  if spring:strequals(strToken, "'")
    type = lex:APOS
  /if

  if spring:strequals(strToken, "=")
    type = lex:ASSIGN
  /if

  if spring:strequals(strToken, "break")
    type = lex:BREAK
  /if

  if spring:strequals(strToken, "cast")
    type = lex:CAST
  /if

  if spring:strequals(strToken, "]")
    type = lex:CBRAC
  /if

  if spring:strequals(strToken, ":")
    type = lex:COLON
  /if

  if spring:strequals(strToken, ",")
    type = lex:COMMA
  /if

  if spring:strequals(strToken, "continue")
    type = lex:CONTINUE
  /if

  if spring:strequals(strToken, ")")
    type = lex:CPAR
  /if

  if spring:strequals(strToken, "--")
    type = lex:DEC
  /if

  if spring:strequals(strToken, "decl")
    type = lex:DECL
  /if

  if spring:strequals(strToken, "!=")
    type = lex:DIFFERENT
  /if

  if spring:strequals(strToken, "/")
    if utils:charIsIdVal(lex'peek)
      lex'saved = extractNextToken(lex)
      if lexerError(lex) != null
        return null
      /if

      if spring:strequals(lex'saved, "entry")
        type = lex:ENDENTRY
      /if

      if spring:strequals(lex'saved, "func")
        type = lex:ENDFUNC
      /if

      if spring:strequals(lex'saved, "if")
        type = lex:ENDIF
      /if

      if spring:strequals(lex'saved, "while")
        type = lex:ENDWHILE
      /if

      if type != 0
        spring:free(lex'saved)
        lex'saved = null
      /if
    /if
    if type == 0 # nothing has been matched, so it is a `/`
        type = lex:DIV
    /if
  /if

  if spring:strequals(strToken, "else")
    type = lex:ELSE
  /if

  if spring:strequals(strToken, "entry")
    type = lex:ENTRY
  /if

  if spring:strequals(strToken, "==")
    type = lex:EQUAL
  /if

  if spring:strequals(strToken, "false")
    type = lex:FALSE
  /if

  if spring:strequals(strToken, "func")
    type = lex:FUNC
  /if

  if spring:strequals(strToken, "if")
    type = lex:IF
  /if

  if spring:strequals(strToken, "import")
    type = lex:IMPORT
  /if

  if spring:strequals(strToken, "++")
    type = lex:INC
  /if

  if spring:strequals(strToken, ">=")
    type = lex:MAJEQ
  /if

  if spring:strequals(strToken, ">")
    type = lex:MAJOR
  /if

  if spring:strequals(strToken, "<=")
    type = lex:MINEQ
  /if

  if spring:strequals(strToken, "<")
    type = lex:MINOR
  /if

  if spring:strequals(strToken, "-")
    type = lex:MINUS
  /if

  if spring:strequals(strToken, "mod")
    type = lex:MOD
  /if

  if spring:strequals(strToken, "module")
    type = lex:MODULE
  /if

  if spring:strequals(strToken, "mut")
    type = lex:MUT
  /if

  if spring:strequals(strToken, "!")
    type = lex:NOT
  /if

  if spring:strequals(strToken, "[")
    type = lex:OBRAC
  /if

  if spring:strequals(strToken, "(")
    type = lex:OPAR
  /if

  if spring:strequals(strToken, "or")
    type = lex:OR
  /if

  if spring:strequals(strToken, "|")
    type = lex:PIPE
  /if

  if spring:strequals(strToken, "+")
    type = lex:PLUS
  /if

  if spring:strequals(strToken, "**")
    type = lex:POW
  /if

  if spring:strequals(strToken, "ptr")
    type = lex:PTR
  /if

  if spring:strequals(strToken, "return")
    type = lex:RETURN
  /if

  if spring:strequals(strToken, "size")
    type = lex:SIZE
  /if

  if spring:strequals(strToken, "struct")
    type = lex:STRUCT
  /if

  if spring:strequals(strToken, "*")
    type = lex:TIMES
  /if

  if spring:strequals(strToken, "true")
    type = lex:TRUE
  /if

  if spring:strequals(strToken, "::")
    type = lex:TWOCOLONS
  /if

  if spring:strequals(strToken, "val")
    type = lex:VAL
  /if

  if spring:strequals(strToken, "while")
    type = lex:WHILE
  /if

  if spring:strequals(strToken, "^")
    type = lex:XOR
  /if

  if utils:strIsUInt(strToken)
    type = lex:NUMBER
    value = spring:strtonum(strToken)
  /if

  if type == 0 # if it's still unmodified, then it's an identifier
    type = lex:ID
    value = cast<uintptr>(strToken)
  else
    spring:free(strToken)
  /if

  return tokenNew(type, value, lex:linenoClone(ptr begin), lex'lineno'pos)
/func

func tokenStr(tok ptr lex:Token) ptr uint8
  if tok == null or tok'type == lex:EOF
    return "Eof"
  /if

  if tok'type == lex:NEWLINE
    return "a newline"
  /if

  if tok'type == lex:ALIAS
    return "alias"
  /if

  if tok'type == lex:AMPER
    return "&"
  /if

  if tok'type == lex:AND
    return "and"
  /if

  if tok'type == lex:APOS
    return "'"
  /if

  if tok'type == lex:ASSIGN
    return "="
  /if

  if tok'type == lex:BREAK
    return "break"
  /if

  if tok'type == lex:CAST
    return "cast"
  /if

  if tok'type == lex:CBRAC
    return "]"
  /if

  if tok'type == lex:COLON
    return ":"
  /if

  if tok'type == lex:COMMA
    return ","
  /if

  if tok'type == lex:CONTINUE
    return "continue"
  /if

  if tok'type == lex:CPAR
    return ")"
  /if

  if tok'type == lex:DEC
    return "--"
  /if

  if tok'type == lex:DECL
    return "decl"
  /if

  if tok'type == lex:DIFFERENT
    return "!="
  /if

  if tok'type == lex:DIV
    return "/"
  /if

  if tok'type == lex:ELSE
    return "else"
  /if

  if tok'type == lex:ENDENTRY
    return "/entry"
  /if

  if tok'type == lex:ENDFUNC
    return "/func"
  /if

  if tok'type == lex:ENDIF
    return "/if"
  /if

  if tok'type == lex:ENDWHILE
    return "/while"
  /if

  if tok'type == lex:ENTRY
    return "entry"
  /if

  if tok'type == lex:EQUAL
    return "=="
  /if

  if tok'type == lex:FALSE
    return "false"
  /if

  if tok'type == lex:FUNC
    return "func"
  /if

  if tok'type == lex:ID
    return "an identifier"
  /if

  if tok'type == lex:IF
    return "if"
  /if

  if tok'type == lex:IMPORT
    return "import"
  /if

  if tok'type == lex:INC
    return "++"
  /if

  if tok'type == lex:MAJEQ
    return ">="
  /if

  if tok'type == lex:MAJOR
    return ">"
  /if

  if tok'type == lex:MINEQ
    return "<="
  /if

  if tok'type == lex:MINOR
    return "<"
  /if

  if tok'type == lex:MINUS
    return "-"
  /if

  if tok'type == lex:MOD
    return "mod"
  /if

  if tok'type == lex:MODULE
    return "module"
  /if

  if tok'type == lex:MUT
    return "mut"
  /if

  if tok'type == lex:NOT
    return "!"
  /if

  if tok'type == lex:NUMBER
    return "a number"
  /if

  if tok'type == lex:OBRAC
    return "["
  /if

  if tok'type == lex:OPAR
    return "("
  /if

  if tok'type == lex:OR
    return "or"
  /if

  if tok'type == lex:PIPE
    return "|"
  /if

  if tok'type == lex:PLUS
    return "+"
  /if

  if tok'type == lex:POW
    return "**"
  /if

  if tok'type == lex:PTR
    return "ptr"
  /if

  if tok'type == lex:RETURN
    return "return"
  /if

  if tok'type == lex:SIZE
    return "size"
  /if

  if tok'type == lex:STRING
    return "a string"
  /if

  if tok'type == lex:STRUCT
    return "struct"
  /if

  if tok'type == lex:TIMES
    return "*"
  /if

  if tok'type == lex:TRUE
    return "true"
  /if

  if tok'type == lex:VAL
    return "val"
  /if

  if tok'type == lex:WHILE
    return "while"
  /if

  if tok'type == lex:XOR
    return "^"
  /if

  return "<unknown, please, report!>"
/func
