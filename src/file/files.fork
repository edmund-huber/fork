#  libfork, a base library for the Fork language
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2014, 2015
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the
#  licenses expressed under Section 1.12 of the MPL v2.


import err
import io


func filereadInternal(camoFd data, bytes ptr uint8, len intptr, err ptr ptr err:Error, eof ptr bool) uintptr
  mut fd = cast<int64>(camoFd)
  decl stream_readfileInternal func(fd int64, buf data, len intptr, error ptr uint8, errLen uintptr) intptr
  mut buf [512] uint8
  mut rd = stream_readfileInternal(fd, bytes, len, buf, 512)

  if rd < 0
    val err = err:errorNew(buf)
    return 0
  /if

  if rd == 0
    val eof = true
  /if

  return rd
/func


func filewriteInternal(camoFd data, bytes ptr uint8, len intptr, err ptr ptr err:Error) uintptr
  mut fd = cast<int64>(camoFd)
  decl stream_writefileInternal func(fd int64, buf data, len intptr, error ptr uint8, errLen uintptr) intptr
  mut buf [512] uint8
  mut wt intptr
  mut wttot intptr = 0

  while wttot < len
    wt = stream_writefileInternal(fd, bytes + wttot, len - wttot, buf, 512)

    if wt < 0
      val err = err:errorNew(buf)
      return 0
    /if

    wttot = wttot + wt
  /while

  return wttot
/func


func filecloseInternal(camoFd data, err ptr ptr err:Error) bool
  decl stream_closefileInternal func(fd int64, error ptr uint8, errLen uintptr) uint8
  mut buf [512] uint8

  if stream_closefileInternal(cast<int64>(camoFd), buf, 512) != 0
    return true
  /if

  return false
/func


func fileOpen(filename ptr uint8, err ptr ptr err:Error) ptr io:Stream
  decl open_readfile func(name ptr uint8, error ptr uint8, errlen uintptr) int64
  mut buf [512] uint8

  val err = null

  mut fd = open_readfile(filename, buf, 512)
  if fd < 0
    val err = err:errorNew(buf)
    return null
  /if

  return io:streamNew(cast<data>(fd), ptr filereadInternal, null, ptr filecloseInternal)
/func


func fileCreate(filename ptr uint8, err ptr ptr err:Error) ptr io:Stream
  decl open_writefile func(name ptr uint8, error ptr uint8, errlen uintptr) int64
  mut buf [512] uint8

  mut fd = open_writefile(filename, buf, 512)
  if fd < 0
    val err = err:errorNew(buf)
    return null
  /if

  return io:streamNew(cast<data>(fd), null, ptr filewriteInternal, ptr filecloseInternal)
/func
