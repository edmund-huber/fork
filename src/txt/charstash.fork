#  libfork, a base library for the Fork language
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2014, 2015
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the
#  licenses expressed under Section 1.12 of the MPL v2.


module txt


import mem
import txt


func csEnlarge(cs ptr txt:Charstash, offset,inc uintptr)
  cs'cap = cs'cap + inc
  mut new = cast<ptr uint8>(mem:alloc(cs'cap))
  mem:move(new + offset, cs'base, cs'len)
  mem:free(cs'base)
  cs'base = new
  cs'work = cs'base + cs'len + offset
/func


func csAppend(cs ptr txt:Charstash, ch uint8) ptr txt:Charstash
  if cs'len == cs'cap
    csEnlarge(cs, 0, 10)
  /if

  val cs'work = ch
  cs'len++
  cs'work++

  return cs
/func


func csAppendInt(cs ptr txt:Charstash, num uintptr) ptr txt:Charstash
  mut buf [20] int8

  txt:numtostr(num, ptr buf[0], 20)

  txt:csAppendStr(cs, ptr buf[0])

  return cs
/func


func csAppendLine(cs ptr txt:Charstash, str ptr uint8) ptr txt:Charstash
  txt:csAppendStr(cs, str)
  txt:csAppendStr(cs, "\n")
  return cs
/func


func csAppendStr(cs ptr txt:Charstash, str ptr uint8) ptr txt:Charstash
  while val str != 0
    csAppend(cs, val str)
    str++
  /while

  return cs
/func


func csAppendWord(cs ptr txt:Charstash, str ptr uint8) ptr txt:Charstash
  txt:csAppendStr(cs, str)
  txt:csAppend(cs, 32)

  return cs
/func


func csPrependStr(cs ptr txt:Charstash, str ptr uint8) ptr txt:Charstash
  mut slen = txt:strlen(str)

  if cs'len + slen >= cs'cap
    csEnlarge(cs, slen, slen > 10 => slen || 10)
    cs'len = cs'len + slen
  else
    mem:move(cs'base + slen, cs'base, cs'len)
    cs'len = cs'len + slen
    cs'work = cs'base + cs'len
  /if

  mem:copy(cs'base, str, slen)

  return cs
/func


func csPrepend(cs ptr txt:Charstash, ch uint8) ptr txt:Charstash
  mut buf [2] uint8
  buf[0] = ch
  buf[1] = 0

  txt:csPrependStr(cs, ptr buf[0])

  return cs
/func


func csPrependInt(cs ptr txt:Charstash, num uintptr) ptr txt:Charstash
  mut buf [20] int8

  txt:numtostr(num, ptr buf[0], 20)

  txt:csPrependStr(cs, ptr buf[0])

  return cs
/func


func csPrependLine(cs ptr txt:Charstash, str ptr uint8) ptr txt:Charstash
  txt:csPrependStr(cs, str)
  txt:csPrependStr(cs, "\n")
  return cs
/func


func csPrependWord(cs ptr txt:Charstash, str ptr uint8) ptr txt:Charstash
  txt:csPrependStr(cs, str)
  txt:csPrepend(cs, 32)

  return cs
/func


func csFree(cs ptr txt:Charstash)
  mem:free(cs'base)
  mem:free(cs)
/func


func csNew(cap uintptr) ptr txt:Charstash
  mut cs = cast<ptr txt:Charstash>(mem:zalloc(size(txt:Charstash)))

  cs'work = cs'base = cast<ptr uint8>(mem:alloc(cap))
  cs'cap = cap

  return cs
/func


func csUnwrap(cs ptr txt:Charstash) ptr uint8
  csAppend(cs, 0)

  mut ret = cs'base
  mem:free(cs)

  return ret
/func


func csLen(cs ptr txt:Charstash) uintptr
  return cs'len
/func
