#  libfork, a base library for the Fork language
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2015
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the
#  licenses expressed under Section 1.12 of the MPL v2.


module fords


import ast
import err
import fs
import hash
import io
import kv
import libfork
import mem
import pair
import set
import txt


# dumps len (32bit) and then the string into the Stream.
method io:Stream.dumpString(str ptr uint8) ptr err:Error
  mut len uint16 = <uint16>(str? => txt:strlen(str) || 0)

  if me.write(ptr len, size(uint16)) == 0
    return me.error()
  /if

  if len > 0
    if me.write(str, len) == 0
      return me.error()
    /if
  /if

  return null
/method


method io:Stream.dumpTypeList(kv ptr kv:KVList) ptr err:Error
  # first, write a boolean, indicating if this kv is null or not.
  mut ok = kv?
  if me.write(ptr ok, size(bool)) == 0
    return me.error()
  /if

  if not ok
    return null
  /if

  # then the length of the list,
  mut len = <uint32>(kv.len())

  if me.write(ptr len, size(uint32)) == 0
    return me.error()
  /if

  mut i uintptr = 0

  # then the types, one by one.
  while i < len
    mut {key,value} = val kv.getAt(i)

    mut err = me.dumpString(<ptr uint8>(key))
    if err?
      return err
    /if

    err = me.dumpType(<ptr ast:Type>(value), false)
    if err?
      return err
    /if

    i++
  /while

  return null
/method


method io:Stream.dumpType(type ptr ast:Type, force bool) ptr err:Error
  # first, write a boolean, indicating if this type is null or not.
  mut ok = type?
  if me.write(ptr ok, size(bool)) == 0
    return me.error()
  /if

  if not ok
    return null
  /if

  # then write the type of this type (uint16)

  if me.write(ptr type'type, size(uint16)) == 0
    return me.error()
  /if

  mut err = me.dumpString(type'name)
  if err?
    return me.error()
  /if

  if type'name?
    mut err = me.dumpString(type'moduleName)
    if err?
      return me.error()
    /if
  /if

  # if the type has no name, than it has to be wholly dumped

  mut fullDump = force or not type'name?

  if me.write(ptr fullDump, size(bool)) == 0
    return me.error()
  /if

  if fullDump
    # isSigned, align, size.. Are all inferrable.

    mut itemCount uint64 = type'itemCount
    if me.write(ptr itemCount, size(uint64)) == 0
      return me.error()
    /if

    err = me.dumpType(type'retType, false)
    if err?
      return me.error()
    /if

    err = me.dumpTypeList(type'members)
    if err?
      return me.error()
    /if

    if me.write(ptr type'builtin, size(bool)) == 0
      return me.error()
    /if
  /if

  # do not write begin and end, because they have no sense without their
  # files.

  return null
/method


func collectAliases(pmod ptr ast:PModule) ptr hash:Hash
  mut ret = hash:strnew(10)

  mut i uintptr = 0
  mut len = pmod'roots.len()

  while i < len
    mut aliases = <ptr ast:PRoot>(val pmod'roots.get(i))'aliases'syms

    mut aLen = aliases.len()
    mut j uintptr = 0

    while j < aLen
      mut {key,value} = val aliases.getAt(j)

      ret.put(key, value)

      j++
    /while

    i++
  /while

  return ret
/func


method io:Stream.dumpAliases(pmod ptr ast:PModule) ptr err:Error
  mut aliases = collectAliases(pmod)

  # dump the length of the decls list, then the single decls.
  mut len = <uint32>(aliases.len())
  if me.write(ptr len, size(uint32)) == 0
    return me.error()
  /if

  mut iter = aliases.iter()
  mut pair ptr pair:Pair = null

  while (pair = iter.next())?
    mut name = <ptr uint8>(pair'key)
    mut dinfo = <ptr ast:DeclInfo>(pair'value)

    mut err = me.dumpString(name)
    if err?
      return err
    /if

    err = me.dumpType(dinfo'type, true)
    if err?
      return err
    /if

    pair:free(pair)
  /while

  hash:iterFree(iter)
  hash:free(aliases)

  return null
/method


method io:Stream.dumpDeclInfo(dinfo ptr ast:DeclInfo) ptr err:Error
  if me.write(ptr dinfo'declType, size(uint16)) == 0
    return me.error()
  /if

  # declOnly declarations are skipped
  # funcParam is only meaningful inside functions, not in the global scopeName

  return me.dumpType(dinfo'type, false)
/method


func collectDecls(pmod ptr ast:PModule) ptr hash:Hash
  mut ret = hash:strnew(10)

  mut i uintptr = 0
  mut len = pmod'roots.len()

  while i < len
    mut decls = <ptr ast:PBlock>(val pmod'roots.get(i))'syms'syms

    mut dLen = decls.len()
    mut j uintptr = 0

    while j < dLen
      mut {key,value} = val decls.getAt(j)
      mut dinfo = <ptr ast:DeclInfo>(value)

      # Ignore "decl"s - they are not meaningful in a ford
      if not dinfo'declOnly
        # dump the name, then the declaration info
        ret.put(key, dinfo)
      /if

      j++
    /while

    i++
  /while

  return ret
/func


method io:Stream.dumpDecls(pmod ptr ast:PModule) ptr err:Error
  mut decls = collectDecls(pmod)

  # dump the length of the decls list, then the single decls.
  mut len = <uint32>(decls.len())
  if me.write(ptr len, size(uint32)) == 0
    return me.error()
  /if

  mut iter = decls.iter()
  mut pair ptr pair:Pair = null

  while (pair = iter.next())?
    mut key = <ptr uint8>(pair'key)
    mut dinfo = <ptr ast:DeclInfo>(pair'value)

    mut err = me.dumpString(key)
    if err?
      return err
    /if

    err = me.dumpDeclInfo(dinfo)
    if err?
      return err
    /if

    pair:free(pair)
  /while

  hash:iterFree(iter)
  hash:free(decls)

  return null
/method


func collectImports(pmod ptr ast:PModule) ptr set:Set
  mut ret = set:strnew(10)

  mut i uintptr = 0
  mut len = pmod'roots.len()

  while i < len
    mut imports = <ptr ast:PRoot>(val pmod'roots.get(i))'imports

    mut j uintptr = 0
    mut impLen = imports.len()

    while j < impLen
      mut importName = <ptr ast:StringDef>(val imports.get(j))

      ret.put(importName'name)

      j++
    /while

    i++
  /while

  return ret
/func


method io:Stream.dumpImports(pmod ptr ast:PModule) ptr err:Error
  mut imports = collectImports(pmod)

  # dump the length of the import list, then the single imports.
  mut len = <uint16>(imports.len())
  if me.write(ptr len, size(uint16)) == 0
    return me.error()
  /if

  mut iter = imports.iter()
  mut elem data = null

  while (elem = iter.next())?
    mut err = me.dumpString(<ptr uint8>(elem))
    if err?
      return err
    /if
  /while

  set:iterFree(iter)
  set:free(imports)

  return null
/method


method io:Stream.dumpFord(pmod ptr ast:PModule) ptr err:Error
  # init: first thing should be libfork version.

  mut rel = libfork:RELEASE
  if me.write(ptr rel, size(uint16)) == 0
    return me.error()
  /if

  # then, dump the module name.

  mut err = me.dumpString(pmod'name)
  if err?
    return err
  /if

  err = me.dumpImports(pmod)
  if err?
    return err
  /if

  err = me.dumpAliases(pmod)
  if err?
    return err
  /if

  err = me.dumpDecls(pmod)
  if err?
    return err
  /if

  return null
/method


func generate(pmod ptr ast:PModule, path ptr uint8) ptr err:Error
  if not pmod'name?
    return err:new("can't generate ford for <main> module")
  /if

  mut fName = txt:strappend(pmod'name, ".ford")
  mut filePath = fs:pathJoin(path, fName)

  mut {outstr,err} = fs:fileCreate(filePath)
  if err?
    return err
  /if

  err = outstr.dumpFord(pmod)

  mem:free(fName)
  mem:free(filePath)
  io:streamClose(outstr)

  return err
/func
