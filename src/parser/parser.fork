#  libfork, a base library for the Fork language
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2015
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the
#  licenses expressed under Section 1.12 of the MPL v2.


module parser


import ast
import cs
import err
import fs
import list
import map
import mem
import parser
import proc
import txt
import utils


# Parser init/deinit funcs

func free(prs ptr parser:Parser)
  if prs?
    if prs'imports?
      map:free(prs'imports)
    /if

    if prs'fordPaths?
      list:freeAll(prs'fordPaths, ptr mem:free)
    /if

    map:free(prs'builtins)

    mem:free(prs'currentFile)
    mem:free(prs)
  /if
/func


func new() ptr parser:Parser
  mut prs = <ptr parser:Parser>(mem:zalloc(size(parser:Parser)))
  prs'imports = map:strnew()

  prs'imports.setFreeFuncs(ptr mem:free, <ptr func(item data)>(ptr ast:pnodeFree))

  prs'fordPaths = envExtractFordPaths()
  prs'builtins = ast:builtinSetNew()
  return prs
/func


# Parser methods

method parser:Parser.getImport(name ptr uint8) ptr parser:Ford
  return <ptr parser:Ford>(me'imports.get(name))
/method


method parser:Parser.findFord(name ptr uint8) {ford ptr parser:Ford,
                                                err ptr err:Error}

  mut ford = <ptr parser:Ford>(me'imports.get(name))

  if ford?
    return {ford,null}
  /if

  mut fordName = txt:strappend(name, ".ford")

  mut len = me'fordPaths.len()

  mut i uintptr = 0

  while i < len
    mut path = <ptr uint8>(val me'fordPaths.get(i))
    mut joinedPath = fs:pathJoin(path, fordName)

    if fs:pathExists(joinedPath)

      mut {ford,err} = me.loadFord(joinedPath)

      mem:free(joinedPath)
      mem:free(fordName)

      if err?
        mut cs = cs:new(20)
        cs.add("can't load ")
        cs.add(joinedPath)
        cs.add(": ")
        cs.add(err.msg())

        mut msg = cs:unwrap(cs)

        err:free(err)

        mut newErr = err:new(msg)

        mem:free(msg)

        return {null,newErr}
      /if

      me'imports.put(txt:strclone(name), ford)
      return {ford,null}
    /if

    mem:free(joinedPath)

    i++
  /while


  mut toGlue [4] ptr uint8

  toGlue[0] = "Can't find "
  toGlue[1] = name
  toGlue[2] = " in the given FORDPATHS"
  toGlue[3] = null

  mut glued = txt:strglue(ptr toGlue[0])

  mut err = err:new(glued)

  mem:free(fordName)
  mem:free(glued)

  return {null, err}
/method


method parser:Parser.importMod(importName ptr ast:StringDef) ptr ast:Issue
  mut {ford,err} = me.findFord(importName'name)
  if err?
    mut issue = ast:issueNew(ast:ISSUE_ERR, importName'begin, me'currentFile, \
    err.msg())

    err:free(err)

    return issue
  /if

  return null
/method


method parser:Parser.importAll(imports ptr list:List) ptr ast:Issues
  mut ret = ast:issuesNew()

  mut len = imports.len()
  mut i uintptr = 0

  while i < len
    mut importName = <ptr ast:StringDef>(val imports.get(i))
    mut issue = me.importMod(importName)

    if issue?
      ret.add(issue)
    /if

    i++
  /while

  return ret
/method


method parser:Parser.matchBuiltin(name ptr uint8) ptr ast:Type
  return <ptr ast:Type>(me'builtins.get(name))
/method


method parser:Parser.parseDirectory(dirName ptr uint8) {pmod ptr ast:PModule,
                                                         issues ptr ast:Issues}

  mut {pmod,issues} = parser:parseModule(dirName)

  if issues.errLen() > 0
    return {null, issues}
  /if

  return {pmod, parser:validateModuleAst(me, pmod)}

/method


method parser:Parser.parseFile(fileName ptr uint8) {root ptr ast:PNode,
                                                     issues ptr ast:Issues}

  mut {proot,err} = parser:parse(fileName)

  if err?
    mut issues = ast:issuesNew()
    issues.add(err)

    return {null, issues}
  /if

  return {proot, parser:validateAst(me, proot)}
/method


method parser:Parser.setCurrentFile(filename ptr uint8)
  mem:free(me'currentFile)

  me'currentFile = txt:strclone(filename)
/method


func envExtractFordPaths() ptr list:List
  mut list = list:new()

  mut paths = proc:getenv("FORDPATHS")
  if paths?
    mut tkz = txt:tokenizerNew(paths, 58) #`:`
    mut path ptr uint8

    while (path = txt:tokenizerNext(tkz))?
      list.append(path)
    /while

  /if

  return list
/func
