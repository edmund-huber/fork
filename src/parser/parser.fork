#  libfork, a base library for the Fork language
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2015
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the
#  licenses expressed under Section 1.12 of the MPL v2.


module parser


import ast
import astfn
import fs
import list
import map
import mem
import parser
import proc
import sema
import synt
import txt
import utils


# Parser init/deinit funcs

func free(ctx ptr parser:Parser)
  if ctx?
    if ctx'imports?
      map:free(ctx'imports)
    /if

    if ctx'fordPaths?
      list:freeAll(ctx'fordPaths, ptr mem:free)
    /if

    map:free(ctx'builtins)

    mem:free(ctx'currentFile)
    mem:free(ctx)
  /if
/func


func new() ptr parser:Parser
  mut ctx = <ptr parser:Parser>(mem:zalloc(size(parser:Parser)))
  ctx'imports = map:strnew()

  ctx'imports.setFreeFuncs(ptr mem:free, <ptr func(item data)>(ptr ast:pnodeFree))

  ctx'fordPaths = envExtractFordPaths()
  ctx'builtins = astfn:builtinSetNew()
  return ctx
/func


# Parser methods

method parser:Parser.findImport(importName ptr ast:StringDef, importAst ptr ptr ast:PNode) ptr list:List
  mut fordName = txt:strappend(importName'name, ".ford")

  mut len = me'fordPaths.len()

  mut i uintptr = 0

  while i < len
    mut path = <ptr uint8>(val me'fordPaths.get(i))
    mut joinedPath = fs:pathJoin(path, fordName)

    if fs:pathExists(joinedPath)

      mut ret = me.parseFile(joinedPath, importAst)

      mem:free(joinedPath)
      mem:free(fordName)
      return ret
    /if

    mem:free(joinedPath)

    i++
  /while

  mut errors = list:new()

  mut toGlue [4] ptr uint8

  toGlue[0] = "Can't find "
  toGlue[1] = importName'name
  toGlue[2] = " in the given FORDPATHS"
  toGlue[3] = null

  mut glued = txt:strglue(ptr toGlue[0])

  errors.append(parser:issueNew(parser:ISSUE_ERR, importName'begin, me'currentFile, glued))

  mem:free(fordName)
  mem:free(glued)

  return errors
/method


method parser:Parser.getImport(name ptr uint8) ptr ast:PRoot
  return <ptr ast:PRoot>(me'imports.get(name))
/method


method parser:Parser.importMod(importName ptr ast:StringDef, value ptr ptr ast:PNode) ptr list:List

  val value = <ptr ast:PNode>(me'imports.get(importName))

  if not (val value)?
    mut errors = me.findImport(importName, value)
    if errors.len() == 0
      me'imports.put(txt:strclone(importName'name), val value)
    /if

    return errors
  else
    return list:new()
  /if

/method


method parser:Parser.importAll(imports ptr list:List) ptr list:List
  mut len = imports.len()
  mut i uintptr = 0

  while i < len
    mut value ptr ast:PNode
    mut importName = <ptr ast:StringDef>(val imports.get(i))
    mut errs = me.importMod(importName, ptr value)

    if errs.len() != 0
      return errs
    /if

    i++
  /while

  return list:new()
/method


method parser:Parser.matchBuiltin(name ptr uint8) ptr ast:Type
  return <ptr ast:Type>(me'builtins.get(name))
/method


method parser:Parser.parseDirectory(dirName ptr uint8,
                                    newModule ptr ptr ast:PNode) ptr list:List

  # TODO: Complete after improving files and directories

/method


method parser:Parser.parseFile(fileName ptr uint8, newRoot ptr ptr ast:PNode) ptr list:List
  mut result = synt:parse(fileName)

  if result'err?
    mut list = list:new()
    list.append(result'err)

    return list
  /if

  val newRoot = result'file

  return sema:semaValidateAst(me, val newRoot)
/method


method parser:Parser.setCurrentFile(filename ptr uint8)
  mem:free(me'currentFile)

  me'currentFile = txt:strclone(filename)
/method


func envExtractFordPaths() ptr list:List
  mut list = list:new()

  mut paths = proc:getenv("FORDPATHS")
  if paths?
    mut tkz = txt:tokenizerNew(paths, 58) #`:`
    mut path ptr uint8

    while (path = txt:tokenizerNext(tkz))?
      list.append(path)
    /while

  /if

  return list
/func
