#  libfork, a base library for the Fork language
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2015
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the
#  licenses expressed under Section 1.12 of the MPL v2.


module parser


import ast
import astfn
import file
import list
import map
import mem
import parser
import proc
import sema
import synt
import txt
import utils


func findImport(ctx ptr parser:Context, importName ptr ast:StringDef, importAst ptr ptr ast:PNode) ptr list:List
  mut fordName = txt:strappend(importName'name, ".ford")

  mut len = ctx'fordPaths.len()

  mut i uintptr = 0

  while i < len
    mut path = cast<ptr uint8>(val ctx'fordPaths.get(i))
    mut joinedPath = file:pathJoin(path, fordName)

    if file:pathExists(joinedPath)

      mut ret = parser:ctxParseFile(ctx, joinedPath, importAst)

      mem:free(joinedPath)
      mem:free(fordName)
      return ret
    /if

    mem:free(joinedPath)

    i++
  /while

  mut errors = list:new()

  mut toGlue [4] ptr uint8

  toGlue[0] = "Can't find "
  toGlue[1] = importName'name
  toGlue[2] = " in the given FORDPATHS"
  toGlue[3] = null

  mut glued = txt:strglue(ptr toGlue[0])

  errors.append(parser:issueNew(parser:ISSUE_ERR, importName'begin, ctx'currentFile, glued))

  mem:free(fordName)
  mem:free(glued)

  return errors
/func


func ctxImport(ctx ptr parser:Context, importName ptr ast:StringDef, value ptr ptr ast:PNode) ptr list:List

  if not map:mapGet(ctx'imports, importName, value)
    mut errors = findImport(ctx, importName, value)
    if errors.len() == 0
      map:mapPut(ctx'imports, txt:strclone(importName'name), val value, map:FREE_KEY | map:FREE_VALUE)
    /if

    return errors
  else
    return list:new()
  /if

/func


func ctxImportAll(ctx ptr parser:Context, imports ptr list:List) ptr list:List
  mut len = imports.len()
  mut i uintptr = 0

  while i < len
    mut value ptr ast:PNode
    mut importName = cast<ptr ast:StringDef>(val imports.get(i))
    mut errs = ctxImport(ctx, importName, ptr value)

    if errs.len() != 0
      return errs
    /if

    i++
  /while

  return list:new()
/func


func envExtractFordPaths() ptr list:List
  mut list = list:new()

  mut paths = proc:getenv("FORDPATHS")
  if paths != null
    mut tkz = txt:tokenizerNew(paths, 58) #`:`
    mut path ptr uint8

    while (path = txt:tokenizerNext(tkz)) != null
      list.append(path)
    /while

  /if

  return list
/func


func ctxGetImport(ctx ptr parser:Context, name ptr uint8) ptr ast:PRoot
  mut ret ptr ast:PRoot = null

  map:mapGet(ctx'imports, name, ptr ret)

  return ret
/func


func ctxFree(ctx ptr parser:Context)
  if ctx != null
    if ctx'imports != null
      map:mapFreeSpec(ctx'imports, ptr mem:free, cast<ptr func(item data)>(ptr ast:pnodeFree))
    /if

    if ctx'fordPaths != null
      list:freeAll(ctx'fordPaths, ptr mem:free)
    /if

    map:mapFreeSpec(ctx'builtins, null, cast<ptr func(item data)>(ptr ast:typeFree))

    mem:free(ctx'currentFile)
    mem:free(ctx)
  /if
/func


func ctxSetCurrentFile(ctx ptr parser:Context, filename ptr uint8)
  mem:free(ctx'currentFile)

  ctx'currentFile = txt:strclone(filename)
/func


func ctxNew() ptr parser:Context
  mut ctx = cast<ptr parser:Context>(mem:zalloc(size(parser:Context)))
  ctx'imports = map:strmapNew()

  ctx'fordPaths = envExtractFordPaths()
  ctx'builtins = astfn:builtinSetNew()
  return ctx
/func


func ctxMatchBuiltin(ctx ptr parser:Context, name ptr uint8) ptr ast:Type
  mut value ptr ast:Type = null

  map:mapGet(ctx'builtins, name, ptr value)
  return value
/func


func ctxParseFile(ctx ptr parser:Context, fileName ptr uint8, newRoot ptr ptr ast:PNode) ptr list:List
  mut parser = synt:parserNew(fileName)

  val newRoot = synt:parserParse(parser)

  mut error = parser'err

  synt:parserFree(parser)

  if val newRoot == null
    mut list = list:new()
    list.append(error)

    return list
  /if

  return sema:semaValidateAst(ctx, val newRoot)
/func
