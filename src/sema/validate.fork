#  libfork, a base library for the Fork language
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2015
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the
#  licenses expressed under Section 1.12 of the MPL v2.


module sema


import ast
import kv
import list
import parser
import proc
import sema
import tty
import utils


# This function validates a single declaration.
# The resolver is used to resolve symbols and aliases; if they are in the global
# scope, they may be unresolved yet, and are then verified.
func validatePDecl(rsv sema:Resolver, pdecl ptr ast:PDecl, errors ptr list:List) bool
  mut ntype = pdecl'node'type

  if ntype == ast:PMUT or ntype == ast:PFUNCTION or ntype == ast:PENTRY or ntype == ast:PMETHOD
    return sema:registerTopDecl(rsv, pdecl, errors) != null
  else
    if ntype == ast:PALIAS
      return sema:registerAlias(rsv, pdecl, errors) != null
    else
      tty:errln("Unreachable: invalid pdecl value")
      proc:abort()
    /if
  /if

  # unreachable
  return false
/func


# This function validates an AST.
# Being supposed to be called by semaValidateAst, we may assume that all the
# imports have been already evaluated.
#
# This function initializes a resolver and then parses the children of the given
# AST root, using the resolver to resolve eventual symbols and aliases.
#
# If not found, a symbol is looked after and verified out of order, allowing
# complete visibility of the global scope without any issue with the declaration
# order of variables, aliases and functions.
func semaValidateAstRoot(ctx ptr parser:Context, root ptr ast:PRoot, errors ptr list:List) bool
  if root'node'node'validated
    return true
  /if

  root'node'syms = ast:stabNew()

  mut rsv sema:Resolver

  mut decls = sema:resolverCollect(ptr rsv, ctx, root, errors)
  if decls == null
    return false
  /if

  mut len = decls.len()
  mut i uintptr = 0
  mut result = true

  while i < len
    # PDecl because root can only have pdecl children
    mut pdecl = cast<ptr ast:PDecl>(decls.getAt(i)'value)

    if not pdecl'node'validated
      if not validatePDecl(rsv, pdecl, errors)
        result = false

        break
      /if
    /if

    i++
  /while

  kv:free(decls)
  sema:resolverDeinit(ptr rsv)

  return result
/func
