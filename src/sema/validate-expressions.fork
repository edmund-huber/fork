#  libfork, a base library for the Fork language
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2015
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the
#  licenses expressed under Section 1.12 of the MPL v2.


module sema


import ast
import astfn
import kv
import lex
import list
import math
import mem
import parser
import sema
import synt
import tokens
import txt
import utils


func ttypeOpCanDoPtrArith(tt uint16) bool
  return tt == tokens:PLUS or tt == tokens:MINUS or tt == tokens:INC or tt == tokens:DEC
/func


func ttypeIsTernary(tt uint16) bool
  return tt == tokens:FATARROW
/func


func ttypeIsBinary(tt uint16) bool
  mut tok lex:Token

  tok'type = tt

  return synt:isBinary(ptr tok) or tt == tokens:MINUS
/func


func ttypeIsUnary(tt uint16) bool
  return ttypeIsBinary(tt)
/func


func ttypeIsComparison(tt uint16) bool
  return tt == tokens:MAJOR or tt == tokens:MINOR or tt == tokens:MAJEQ or tt == tokens:MINEQ or tt == tokens:EQUAL or tt == tokens:DIFFERENT
/func


func ttypeIsConst(tt uint16) bool
  return tt == tokens:STRING or tt == tokens:NUMBER or tt == tokens:NULLPTR or tt == tokens:TRUE or tt == tokens:FALSE
/func


func ttypeIsEqDiff(tt uint16) bool
  return tt == tokens:EQUAL or tt == tokens:DIFFERENT
/func


func ttypeIsArith(tt uint16) bool
  return tt == tokens:PLUS or tt == tokens:MINUS or tt == tokens:MINOR or tt == tokens:MAJOR or tt == tokens:MAJEQ or tt == tokens:MINEQ or tt == tokens:MOD or tt == tokens:DIV or tt == tokens:INC or tt == tokens:DEC or tt == tokens:POW or tt == tokens:TIMES or tt == tokens:UMINUS or tt == tokens:AMPER or tt == tokens:PIPE or tt == tokens:XOR
/func


func ttypeIsBool(tt uint16) bool
  return tt == tokens:AND or tt == tokens:OR or tt == tokens:NOT
/func


func ttypeCanBeAssignTarget(tt uint16, type ptr ast:Type) bool
  return (tt == tokens:VAL or tt == tokens:OBRAC or tt == tokens:APOS or tt == tokens:COLON or tt == tokens:ID) and (ast:typeIsPtr(type) or ast:typeIsInt(type) or ast:typeIsStruct(type) or ast:typeIsBool(type))
/func


func assignLhsDump(cs ptr txt:Charstash, pexpr ptr ast:PExpr)
  mut op = pexpr'opType

  if op == tokens:ID
    txt:csAppendStr(cs, cast<ptr uint8>(pexpr'node'value))
    return
  /if

  mut left = cast<ptr ast:PExpr>(val list:listGet(pexpr'node'leaves, 0))

  if op == tokens:VAL
    txt:csAppendStr(cs, "'val ")

    assignLhsDump(cs, left)

    txt:csAppendStr(cs, "' ")

    return
  /if

  if op == tokens:OBRAC
    txt:csAppendStr(cs, " member of '")
    assignLhsDump(cs, left)
    txt:csAppendStr(cs, "' ")

    return
  /if

  mut right = cast<ptr ast:PExpr>(val list:listGet(pexpr'node'leaves, 1))

  if op == tokens:APOS or op == tokens:COMMA
    txt:csAppendStr(cs, "'")

    assignLhsDump(cs, left)

    txt:csAppendStr(cs, op == tokens:APOS => "'" || ":")

    assignLhsDump(cs, right)

    txt:csAppendStr(cs, "' ")

    return
  /if

  txt:csAppendStr(cs, "expr ")
/func


func intForVal(ctx ptr parser:Context, value intptr) ptr ast:Type
  mut aval = math:abs(value)

  if aval < 2**7
    return parser:ctxMatchBuiltin(ctx, "int8")
  else
    if aval < 2**15
      return parser:ctxMatchBuiltin(ctx, "int16")
    else
      if aval < 2 ** 31
        return parser:ctxMatchBuiltin(ctx, "int32")
      /if
    /if
  /if

  return parser:ctxMatchBuiltin(ctx, "int64")
/func


func intTypesFindLargestCompatible(ctx ptr parser:Context, type1, type2 ptr ast:Type) ptr ast:Type

  mut bothSigned = type1'isSigned and type2'isSigned
  mut bothUnsigned = !type1'isSigned and !type2'isSigned


  if bothUnsigned or bothSigned
    return type1'typeSize > type2'typeSize => type1 || type2
  /if

  # return intptr, must improve in the future
  return parser:ctxMatchBuiltin(ctx, "intptr")
/func


func typeIsAssignable(ctx ptr parser:Context, scope ptr ast:PNode, dest,src ptr ast:Type) bool
  if dest == null or src == null
    return dest == src
  /if

  if dest'type == ast:TYPE_EMPTY or src'type == ast:TYPE_EMPTY
    return false
  /if

  if dest'name != null and src'name != null and !dest'builtin and !src'builtin
    mut ret = txt:strequals(dest'name, src'name)

    if ret and dest'moduleName != null and src'moduleName != null
      ret = txt:strequals(dest'moduleName, src'moduleName)
    /if

    return ret
  /if

  mut isFunc = dest'type == ast:TYPE_FUNC
  mut isStruct = dest'type == ast:TYPE_STRUCT
  mut isLoc = dest'type == ast:TYPE_LOC
  mut isPtr = dest'type == ast:TYPE_PTR

  if dest'type != src'type
    if dest'type == ast:TYPE_RECALIAS or src'type == ast:TYPE_RECALIAS
      dest = sema:findRecAlias(ctx, scope, dest)
      src = sema:findRecAlias(ctx, scope, src)

      return typeIsAssignable(ctx, scope, dest, src)
    /if

    if isPtr and src'type == ast:TYPE_NULL
      return true
    /if

    if ast:typeIsData(dest) and (ast:typeIsPtr(src) or ast:typeIsNull(src))
      return true
    /if

    return false
  /if

  if isFunc or isStruct
    mut i uintptr = 0
    mut len = kv:kvLen(dest'members)

    if len != kv:kvLen(src'members)
      return false
    /if

    while i < len
      mut pair1 = kv:kvGetAt(src'members, i)
      mut pair2 = kv:kvGetAt(dest'members, i)

      mut type1 = cast<ptr ast:Type>(pair1'value)
      mut type2 = cast<ptr ast:Type>(pair2'value)

      if !typeIsAssignable(ctx, scope, type2, type1)
        return false
      /if

      i++
    /while
  /if

  if isPtr or isLoc or isFunc
    if !typeIsAssignable(ctx, scope, dest'retType, src'retType)
      return false
    /if
  /if

  if isLoc
    if dest'itemCount != src'itemCount
      return false
    /if
  /if

  if dest'type == ast:TYPE_INT
    if dest'typeSize < src'typeSize
      return false
    /if
  /if

  return true
/func


func typeIsCastable(ctx ptr parser:Context, scope ptr ast:PNode, dest,src ptr ast:Type) bool
  if dest'type == ast:TYPE_EMPTY or src'type == ast:TYPE_EMPTY
    return false
  /if

  mut isData = dest'type == ast:TYPE_DATA
  mut isPtr = dest'type == ast:TYPE_PTR
  mut isInt = dest'type == ast:TYPE_INT

  if isPtr or isInt or isData
    return src'type == ast:TYPE_INT or src'type == ast:TYPE_PTR or src'type == ast:TYPE_NULL or src'type == ast:TYPE_DATA
  /if

  return sema:typeIsAssignable(ctx, scope, dest, src)
/func


func validateExprConst(rsv sema:Resolver,
                       pexpr ptr ast:PExpr) ptr ast:Type

  mut op = pexpr'opType

  if op == tokens:STRING
    return parser:ctxMatchBuiltin(rsv'ctx, "ptr uint8")
  /if

  if op == tokens:NUMBER
    return intForVal(rsv'ctx, cast<intptr>(pexpr'node'value))
  /if

  if op == tokens:TRUE or op == tokens:FALSE
    return parser:ctxMatchBuiltin(rsv'ctx, "bool")
  /if

  if op == tokens:NULLPTR
    return parser:ctxMatchBuiltin(rsv'ctx, "null")
  /if

  return null
/func


func validateExprCast(rsv sema:Resolver,
                      pexpr ptr ast:PExpr,
                      recList,errors ptr list:List) ptr ast:Type

  mut ptype = cast<ptr ast:PType>(pexpr'node'value)
  pexpr'type = sema:resolveType(rsv, ptype, errors)

  if pexpr'type == null
    return null
  /if

  mut childExpr = cast<ptr ast:PExpr>(val list:listGet(pexpr'node'leaves, 0))
  mut chType = sema:validateExprRecl(rsv, childExpr, recList, errors)

  if chType == null or !sema:typeIsCastable(rsv'ctx, cast<ptr ast:PNode>(pexpr), chType, pexpr'type)
    mut cs = txt:csNew(20)

    txt:csAppendStr(cs, "can't cast ")
    ast:typeSummarize(cs, chType)
    txt:csAppendStr(cs, " to ")
    ast:typeSummarize(cs, pexpr'type)

    mut str = txt:csUnwrap(cs)

    list:listAppend(errors, parser:issueNew(parser:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, str))

    mem:free(str)
    return null
  /if

  return pexpr'type
/func


func validateSizeExpr(rsv sema:Resolver,
                      pexpr ptr ast:PExpr,
                      errors ptr list:List) ptr ast:Type

  mut ptype = cast<ptr ast:PType>(pexpr'node'value)

  mut sizeType = sema:resolveType(rsv, ptype, errors)
  if sizeType == null
    return null
  /if

  if sizeType'type == ast:TYPE_FUNC

    list:listAppend(errors, parser:issueNew(parser:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, "invalid application of 'size' to a function type"))
    return null
  /if

  return parser:ctxMatchBuiltin(rsv'ctx, "uintptr")
/func


decl resolveDeclType func(rsv sema:Resolver,
                          name ptr uint8,
                          node ptr ast:PNode,
                          recList,errors ptr list:List) ptr ast:Type


func validateExprId(rsv sema:Resolver,
                    pexpr ptr ast:PExpr,
                    recList,errors ptr list:List) ptr ast:Type

  mut name = cast<ptr uint8>(pexpr'node'value)
  mut type = sema:findSym(cast<ptr ast:PNode>(pexpr), name)

  if recList != null and utils:listContains(recList, name)
    mut cs = txt:csNew(20)

    txt:csAppendStr(cs, "type ")
    txt:csAppendStr(cs, name)
    txt:csAppendStr(cs, " causes an init loop ")
    utils:listDumpHierarchyIntoCS(recList, cs)

    mut str = txt:csUnwrap(cs)

    list:listAppend(errors, parser:issueNew(parser:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, str))

    mem:free(str)

    return null
  /if

  # try searching for a top declaration
  if type == null and (type = resolveDeclType(rsv, name, cast<ptr ast:PNode>(pexpr), recList, errors)) == null
    return null
  /if

  return type
/func


func validateBoolExpr(rsv sema:Resolver,
                      pexpr ptr ast:PExpr,
                      ltype,rtype ptr ast:Type,
                      recList,errors ptr list:List) ptr ast:Type

  mut op = pexpr'opType

  if !ast:typeIsBool(ltype) or !ast:typeIsBool(rtype)
    mut cs = txt:csNew(20)

    txt:csAppendStr(cs, "cannot apply ")
    txt:csAppendStr(cs, lex:ttypeStr(op))
    txt:csAppendStr(cs, " to types ")
    ast:typeSummarize(cs, ltype)
    txt:csAppendStr(cs, " and ")
    ast:typeSummarize(cs, rtype)

    mut str = txt:csUnwrap(cs)

    list:listAppend(errors, parser:issueNew(parser:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, str))

    mem:free(str)

    return null
  /if

  return parser:ctxMatchBuiltin(rsv'ctx, "bool")
/func


func validateArithPtrExpr(rsv sema:Resolver,
                          pexpr ptr ast:PExpr,
                          ltype,rtype ptr ast:Type,
                          recList,errors ptr list:List) ptr ast:Type

  if !ttypeOpCanDoPtrArith(pexpr'opType)
    mut cs = txt:csNew(20)

    txt:csAppendStr(cs, "operator ")
    txt:csAppendStr(cs, lex:ttypeStr(pexpr'opType))
    txt:csAppendStr(cs, " is not appliable to pointers")

    mut str = txt:csUnwrap(cs)

    list:listAppend(errors, parser:issueNew(parser:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, str))

    mem:free(str)

    return null
  /if

  if ast:typeIsPtr(ltype) and ast:typeIsPtr(rtype)
    if pexpr'opType == tokens:MINUS
      if !sema:typeIsAssignable(rsv'ctx, cast<ptr ast:PNode>(pexpr), ltype, rtype)
        mut cs = txt:csNew(20)

        txt:csAppendStr(cs, "types ")
        ast:typeSummarize(cs, ltype)
        txt:csAppendStr(cs, " and ")
        ast:typeSummarize(cs, rtype)
        txt:csAppendStr(cs, " are not compatible")

        mut str = txt:csUnwrap(cs)

        list:listAppend(errors, parser:issueNew(parser:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, str))

        mem:free(str)

        return null
      /if

      return parser:ctxMatchBuiltin(rsv'ctx, "intptr")
    else
      list:listAppend(errors, parser:issueNew(parser:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, "only difference between two pointers can be allowed"))
      return null
    /if
  /if

  # If we reached this point, then we have an int and a pointer.
  # Let's choose the pointer and then return the type of it.

  return ast:typeIsPtr(ltype) => ltype || rtype
/func


func validateArithExpr(rsv sema:Resolver,
                       pexpr ptr ast:PExpr,
                       ltype,rtype ptr ast:Type,
                       recList,errors ptr list:List) ptr ast:Type

  mut op = pexpr'opType

  if !(ast:typeIsInt(ltype) or ast:typeIsPtr(ltype)) or !(ast:typeIsPtr(rtype) or ast:typeIsInt(rtype))
    list:listAppend(errors, parser:issueNew(parser:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, "arithmetic operations can only involve pointers and integers"))

    return null
  /if

  if ast:typeIsPtr(ltype) or ast:typeIsPtr(rtype)
    return validateArithPtrExpr(rsv, pexpr, ltype, rtype, recList, errors)
  /if

  # In this case, we only have integers, so we just need to evaluate the larger
  # type or resolve to boolean in case of a major/minor comparison.

  return ttypeIsComparison(op) => parser:ctxMatchBuiltin(rsv'ctx, "bool") || (ltype'typeSize > rtype'typeSize => ltype || rtype)
/func


func validateEqDiffExpr(rsv sema:Resolver,
                        pexpr ptr ast:PExpr,
                        ltype,rtype ptr ast:Type,
                        errors ptr list:List) ptr ast:Type

  mut success = true

  if ltype'type != rtype'type
    # the only case in which we can accept a comparison between different types
    # is when we are comparing a pointer with null.
    if !((ast:typeIsNull(ltype) and ast:typeIsPtr(rtype)) or (ast:typeIsPtr(ltype) and ast:typeIsNull(rtype)))
      success = false
    /if
  else
    if !(ast:typeIsPtr(ltype) or ast:typeIsInt(ltype) or ast:typeIsBool(ltype))
      success = false
    /if
  /if

  if !success
    list:listAppend(errors, parser:issueNew(parser:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, "cannot evaluate the equivalence of two incompatible types"))
  /if

  return success => parser:ctxMatchBuiltin(rsv'ctx, "bool") || null
/func


func validateModuleAccessExpr(rsv sema:Resolver,
                              pexpr ptr ast:PExpr,
                              errors ptr list:List) ptr ast:Type

  mut modName = cast<ptr uint8>(cast<ptr ast:PNode>(val list:listGet(pexpr'node'leaves, 0))'value)
  if !ast:prootHasImported(rsv'root, modName)
    mut msg = txt:strappend(modName, " has never been imported")
    list:listAppend(errors, parser:issueNew(parser:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, msg))
    mem:free(msg)

    return null
  /if

  mut symName = cast<ptr uint8>(cast<ptr ast:PNode>(val list:listGet(pexpr'node'leaves, 1))'value)
  mut type = sema:findSymModule(rsv'ctx, modName, symName)

  if type == null
    mut cs = txt:csNew(20)
    txt:csAppendStr(cs, "'")
    txt:csAppendStr(cs, symName)
    txt:csAppendStr(cs, "' is not defined in module '")
    txt:csAppendStr(cs, modName)
    txt:csAppendStr(cs, "'")

    mut msg = txt:csUnwrap(cs)

    list:listAppend(errors, parser:issueNew(parser:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, msg))

    mem:free(msg)

    return null
  /if

  return type
/func


func resolveRecType(rsv sema:Resolver,
                    type ptr ast:Type) ptr ast:Type

  if type'type != ast:TYPE_RECALIAS
    return type
  /if

  if type'moduleName != null
    return sema:findAliasImport(rsv'ctx, type'moduleName, type'name)
  /if

  return sema:findAliasLocal(cast<ptr ast:PNode>(rsv'root), type'name)
/func


func validateStructureAccessExpr(rsv sema:Resolver,
                                 pexpr ptr ast:PExpr,
                                 ltype ptr ast:Type,
                                 errors ptr list:List) ptr ast:Type

  mut accType = ltype

  if ltype'type == ast:TYPE_PTR
    accType = resolveRecType(rsv, ltype'retType)
  /if

  if !ast:typeIsStruct(accType)
    mut cs = txt:csNew(20)
    txt:csAppendStr(cs, "'")
    ast:typeSummarize(cs, accType)
    txt:csAppendStr(cs, "' is neither a structure nor a pointer to a structure")

    mut msg = txt:csUnwrap(cs)

    list:listAppend(errors, parser:issueNew(parser:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, msg))

    mem:free(msg)

    return null
  /if

  mut field = cast<ptr uint8>(cast<ptr ast:PNode>(val list:listGet(pexpr'node'leaves, 1))'value)

  mut type ptr ast:Type = null

  if !kv:kvGet(accType'members, field, ptr type)
    mut cs = txt:csNew(20)
    txt:csAppendStr(cs, "no field called '")
    txt:csAppendStr(cs, field)
    txt:csAppendStr(cs, "' in type ")
    ast:typeSummarize(cs, accType)

    mut msg = txt:csUnwrap(cs)

    list:listAppend(errors, parser:issueNew(parser:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, msg))

    mem:free(msg)

    return null
  /if

  return type
/func


func validateArrayAccess(rsv sema:Resolver,
                         pexpr ptr ast:PExpr,
                         ltype,rtype ptr ast:Type,
                         errors ptr list:List) ptr ast:Type

  if ltype'type != ast:TYPE_PTR and !ast:typeIsLoc(ltype)
    list:listAppend(errors, parser:issueNew(parser:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, "array access is allowed only for pointers and locations"))
  /if

  if !ast:typeIsInt(rtype)
    list:listAppend(errors, parser:issueNew(parser:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, "an expression of integer type is required for array access"))
  /if

  # because of first-step bug with recursive types
  return cast<ptr ast:Type>(ltype'retType)
/func


func normalizeEmptyType(ctx ptr parser:Context, type ptr ast:Type) ptr ast:Type
  return type != null => type || parser:ctxMatchBuiltin(ctx, "\0")
/func


func validateFunctionCallExpr(rsv sema:Resolver,
                              pexpr ptr ast:PExpr,
                              ltype ptr ast:Type,
                              recList,errors ptr list:List) ptr ast:Type

  mut accType = ltype

  if ltype'type == ast:TYPE_PTR
    accType = ltype'retType
  /if

  if !ast:typeIsFunc(accType)
    list:listAppend(errors, parser:issueNew(parser:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, "expression is neither a function nor a pointer to a function"))

    return null
  /if

  mut expParams = accType'members
  mut expLen = kv:kvLen(expParams)

  mut argsLen = list:listLen(pexpr'node'leaves)

  if argsLen != expLen + 1
    mut cs = txt:csNew(20)
    txt:csAppendStr(cs, "can't call function ")

    if ltype'name != null
      txt:csAppendStr(cs, "'")

      if ltype'moduleName != null
        txt:csAppendStr(cs, accType'moduleName)
        txt:csAppendStr(cs, ":")
      /if

      txt:csAppendStr(cs, accType'name)
      txt:csAppendStr(cs, "' ")
    else
      ast:typeSummarize(cs, accType)
    /if

    txt:csAppendStr(cs, ": expected ")
    txt:csAppendInt(cs, expLen)
    txt:csAppendStr(cs, " parameters, got ")
    txt:csAppendInt(cs, argsLen - 1)

    mut msg = txt:csUnwrap(cs)

    list:listAppend(errors, parser:issueNew(parser:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, msg))

    mem:free(msg)

    return null
  /if

  mut scope = cast<ptr ast:PNode>(pexpr)
  mut i uintptr = 0

  while i < expLen
    mut gotParam = cast<ptr ast:PExpr>(val list:listGet(scope'leaves, i + 1))
    mut expPair = kv:kvGetAt(expParams, i)

    mut expType = cast<ptr ast:Type>(expPair'value)

    mut gotType = sema:validateExprRecl(rsv, gotParam, recList, errors)
    if gotType == null
      return null
    /if

    if !sema:typeIsAssignable(rsv'ctx, scope, expType, gotType)
      mut cs = txt:csNew(20)
      txt:csAppendStr(cs, "passing '")

      ast:typeSummarize(cs, gotType)

      txt:csAppendStr(cs, "' to parameter '")
      txt:csAppendStr(cs, cast<ptr uint8>(expPair'key))
      txt:csAppendStr(cs, "' of type '")

      ast:typeSummarize(cs, expType)

      txt:csAppendStr(cs, "'")

      mut msg = txt:csUnwrap(cs)

      list:listAppend(errors, parser:issueNew(parser:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, msg))

      mem:free(msg)

      return null
    /if

    i++
  /while

  return normalizeEmptyType(rsv'ctx, cast<ptr ast:Type>(accType'retType))
/func


func validateAssignExpr(rsv sema:Resolver,
                        pexpr,left ptr ast:PExpr,
                        ltype,rtype ptr ast:Type,
                        errors ptr list:List) ptr ast:Type

  if !ttypeCanBeAssignTarget(left'opType, ltype)
    list:listAppend(errors, parser:issueNew(parser:ISSUE_ERR, left'node'begin, rsv'root'fileName, "expression cannot be target of assignment"))
    return null
  /if

  if !sema:typeIsAssignable(rsv'ctx, cast<ptr ast:PNode>(pexpr), ltype, rtype)
    mut cs = txt:csNew(20)

    txt:csAppendStr(cs, "cannot assign expression of type '")
    ast:typeSummarize(cs, rtype)
    txt:csAppendStr(cs, "' to a lvalue of type '")
    ast:typeSummarize(cs, ltype)
    txt:csAppendStr(cs, "'")

    mut str = txt:csUnwrap(cs)

    list:listAppend(errors, parser:issueNew(parser:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, str))

    mem:free(str)

    return null
  /if

  return ltype
/func


func validateBinaryExpr(rsv sema:Resolver,
                        pexpr ptr ast:PExpr,
                        recList,errors ptr list:List) ptr ast:Type

  mut op = pexpr'opType

  # handle apos, colon and call operators before because they are special
  # (i.e. no expressions or expressions only on lhs)

  if op == tokens:COLON
    return validateModuleAccessExpr(rsv, pexpr, errors)
  /if

  mut left = cast<ptr ast:PExpr>(val list:listGet(pexpr'node'leaves, 0))
  mut ltype = sema:validateExprRecl(rsv, left, recList, errors)

  if ltype == null
    return null
  /if

  # structure field access
  if op == tokens:APOS
    return validateStructureAccessExpr(rsv, pexpr, ltype,  errors)
  /if

  # function call
  if op == tokens:OPAR
    return validateFunctionCallExpr(rsv, pexpr, ltype, recList, errors)
  /if

  mut right = cast<ptr ast:PExpr>(val list:listGet(pexpr'node'leaves, 1))
  mut rtype = sema:validateExprRecl(rsv, right, recList, errors)

  if rtype == null
    return null
  /if

  # array access
  if op == tokens:OBRAC
    return validateArrayAccess(rsv, pexpr, ltype, rtype, errors)
  /if

  if ttypeIsBool(op)
    return validateBoolExpr(rsv, pexpr, ltype, rtype, recList, errors)
  /if

  if ttypeIsArith(op)
    return validateArithExpr(rsv, pexpr, ltype, rtype, recList, errors)
  /if

  if ttypeIsEqDiff(op)
    return validateEqDiffExpr(rsv, pexpr, ltype, rtype, errors)
  /if

  return validateAssignExpr(rsv, pexpr, left, ltype, rtype, errors)
/func


func validateNotExpr(rsv sema:Resolver,
                     pexpr ptr ast:PExpr,
                     atype ptr ast:Type,
                     errors ptr list:List) ptr ast:Type

  if !ast:typeIsBool(atype)
    list:listAppend(errors, parser:issueNew(parser:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, "expression must be boolean"))

    return null
  /if

  # always boolean
  return atype
/func


func validateValExpr(rsv sema:Resolver,
                     pexpr ptr ast:PExpr,
                     atype ptr ast:Type,
                     errors ptr list:List) ptr ast:Type

  if atype'type != ast:TYPE_PTR
    mut cs = txt:csNew(20)
    txt:csAppendStr(cs, "type '")
    ast:typeSummarize(cs, atype)
    txt:csAppendStr(cs, "' is not dereferenceable")

    mut msg = txt:csUnwrap(cs)

    list:listAppend(errors, parser:issueNew(parser:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, msg))

    mem:free(msg)

    return null
  /if

  return cast<ptr ast:Type>(atype'retType)
/func


func validatePtrExpr(rsv sema:Resolver,
                     pexpr ptr ast:PExpr,
                     atype ptr ast:Type,
                     errors ptr list:List) ptr ast:Type

  if ast:typeIsNull(atype)
    list:listAppend(errors, parser:issueNew(parser:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, "can't extract the address of null"))

    return null
  /if

  return astfn:typeNewPtr(rsv'root'typePool, null, null, atype)
/func


func validateUMinusExpr(rsv sema:Resolver,
                        pexpr ptr ast:PExpr,
                        atype ptr ast:Type,
                        errors ptr list:List) ptr ast:Type

  if !ast:typeIsInt(atype)
    mut cs = txt:csNew(20)
    txt:csAppendStr(cs, "cannot apply unary '-' to type '")
    ast:typeSummarize(cs, atype)
    txt:csAppendStr(cs, "'")

    mut msg = txt:csUnwrap(cs)

    list:listAppend(errors, parser:issueNew(parser:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, msg))

    mem:free(msg)

    return null
  /if

  if !atype'isSigned
    mut cs = txt:csNew(20)
    txt:csAppendStr(cs, "cannot apply unary '-' to unsigned type '")
    ast:typeSummarize(cs, atype)
    txt:csAppendStr(cs, "'")

    mut msg = txt:csUnwrap(cs)

    list:listAppend(errors, parser:issueNew(parser:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, msg))

    mem:free(msg)

    return null
  /if

  return atype
/func


func validateIncDecExpr(rsv sema:Resolver,
                        pexpr,atarget ptr ast:PExpr,
                        atype ptr ast:Type,
                        errors ptr list:List) ptr ast:Type

  if !ast:typeIsInt(atype) and !ast:typeIsPtr(atype)
    mut cs = txt:csNew(20)
    txt:csAppendStr(cs, "type '")
    ast:typeSummarize(cs, atype)
    txt:csAppendStr(cs, "' is not an integer or pointer type")

    mut msg = txt:csUnwrap(cs)

    list:listAppend(errors, parser:issueNew(parser:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, msg))

    mem:free(msg)

    return null
  /if

  if !ttypeCanBeAssignTarget(atarget'opType, atype)
    list:listAppend(errors, parser:issueNew(parser:ISSUE_ERR, atarget'node'begin, rsv'root'fileName, "expression is not assignable"))

    return null
  /if

  return atype
/func


func validateUnaryExpr(rsv sema:Resolver,
                       pexpr ptr ast:PExpr,
                       recList, errors ptr list:List) ptr ast:Type

  mut op = pexpr'opType

  mut arg = cast<ptr ast:PExpr>(val list:listGet(pexpr'node'leaves, 0))
  mut atype = sema:validateExprRecl(rsv, arg, recList, errors)

  if op == tokens:NOT
    return validateNotExpr(rsv, pexpr, atype, errors)
  /if

  if op == tokens:VAL
    return validateValExpr(rsv, pexpr, atype, errors)
  /if

  if op == tokens:PTR
    return validatePtrExpr(rsv, pexpr, atype, errors)
  /if

  if op == tokens:UMINUS
    return validateUMinusExpr(rsv, pexpr, atype, errors)
  /if

  # if we've reached this point then it's '++' or '--'

  return validateIncDecExpr(rsv, pexpr, arg, atype, errors)
/func


func validateTernaryExpr(rsv sema:Resolver,
                         pexpr ptr ast:PExpr,
                         recList, errors ptr list:List) ptr ast:Type

  mut condition = cast<ptr ast:PExpr>(val list:listGet(pexpr'node'leaves, 0))
  mut condType = sema:validateExprRecl(rsv, condition, recList, errors)

  mut left = cast<ptr ast:PExpr>(val list:listGet(pexpr'node'leaves, 1))
  mut leftType = sema:validateExprRecl(rsv, left, recList, errors)

  mut right = cast<ptr ast:PExpr>(val list:listGet(pexpr'node'leaves, 1))
  mut rightType = sema:validateExprRecl(rsv, right, recList, errors)

  if condType == null or leftType == null or rightType == null
    return null
  /if

  if !ast:typeIsBool(condType)
    list:listAppend(errors, parser:issueNew(parser:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, "non boolean ternary condition"))

    return null
  /if

  # This is done on purpose, because "typeIsAssignable" is not commutative:
  # it evalutates that the second argument is assignable to the first, but in a
  # ternary operator the position of the two conditional choices is irrelevant
  # for sake of type determination, so we must run it twice with reversed
  # arguments
  if !sema:typeIsAssignable(rsv'ctx, cast<ptr ast:PNode>(pexpr), leftType, rightType) and !sema:typeIsAssignable(rsv'ctx, cast<ptr ast:PNode>(pexpr), rightType, leftType)
    mut cs = txt:csNew(20)
    txt:csAppendStr(cs, "ternary expression arguments have incompatible types '")
    ast:typeSummarize(cs, leftType)
    txt:csAppendStr(cs, "' and '")
    ast:typeSummarize(cs, rightType)
    txt:csAppendStr(cs, "'")

    mut msg = txt:csUnwrap(cs)

    list:listAppend(errors, parser:issueNew(parser:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, msg))

    mem:free(msg)

    return null
  /if

  if ast:typeIsData(leftType) or ast:typeIsData(rightType)
    return parser:ctxMatchBuiltin(rsv'ctx, "data")
  /if

  if ast:typeIsNull(leftType)
    return rightType
  /if

  if ast:typeIsNull(rightType)
    return leftType
  /if

  if ast:typeIsInt(leftType)
    return intTypesFindLargestCompatible(rsv'ctx, leftType, rightType)
  /if

  # left and right type should pretty much the same now
  return leftType
/func


func validateExprRecl(rsv sema:Resolver,
                      pexpr ptr ast:PExpr,
                      recList,errors ptr list:List) ptr ast:Type


  if pexpr'node'validated
    return pexpr'type
  /if

  pexpr'type = null

  mut op = pexpr'opType
  if ttypeIsConst(op)
    return validateExprConst(rsv, pexpr)
  else
    if op == tokens:ID
      pexpr'type = validateExprId(rsv, pexpr, recList, errors)
    else
      if op == tokens:CAST
        pexpr'type = validateExprCast(rsv, pexpr, recList, errors)
      else
        if op == tokens:SIZE
          pexpr'type = validateSizeExpr(rsv, pexpr, errors)
        else
          if ttypeIsTernary(op)
            pexpr'type = validateTernaryExpr(rsv, pexpr, recList, errors)
          else
            if ttypeIsBinary(op)
              pexpr'type = validateBinaryExpr(rsv, pexpr, recList, errors)
            else
              pexpr'type = validateUnaryExpr(rsv, pexpr, recList, errors)
            /if
          /if
        /if
      /if
    /if
  /if

  if pexpr'type != null
    pexpr'node'validated = true
  /if

  return pexpr'type
/func


func validateExpr(rsv sema:Resolver,
                  pexpr ptr ast:PExpr,
                  errors ptr list:List) ptr ast:Type

  return validateExprRecl(rsv, pexpr, null, errors)
/func
