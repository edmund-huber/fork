#  libfork, a base library for the Fork language
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2015
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the
#  licenses expressed under Section 1.12 of the MPL v2.


module sema


import ast
import astfn
import cs
import kv
import lex
import list
import math
import mem
import parser
import sema
import synt
import tokens
import txt
import utils


func exprIsCompileConst(expr ptr ast:PExpr) bool
  if   expr'opType == tokens:NUMBER \
    or expr'opType == tokens:STRING \
    or expr'opType == tokens:TRUE \
    or expr'opType == tokens:FALSE \
    or expr'opType == tokens:NULL \
    or expr'opType == tokens:SIZE

    return true
  /if

  if expr'opType == tokens:PTR
    mut elem = <ptr ast:PExpr>(val expr'node'leaves.get(0))

    return elem'opType == tokens:ID or elem'opType == tokens:COLON
  /if

  if ttypeIsUnary(expr'opType)
    mut elem = <ptr ast:PExpr>(val expr'node'leaves.get(0))

    return exprIsCompileConst(elem)
  /if

  if ttypeIsBinary(expr'opType)
    mut left = <ptr ast:PExpr>(val expr'node'leaves.get(0))
    mut right = <ptr ast:PExpr>(val expr'node'leaves.get(1))

    return exprIsCompileConst(left) and exprIsCompileConst(right)
  /if

  return false
/func


func ttypeOpCanDoPtrArith(tt uint16) bool
  return tt == tokens:PLUS or tt == tokens:MINUS or tt == tokens:INC or tt == tokens:DEC
/func


func ttypeIsTernary(tt uint16) bool
  return tt == tokens:FATARROW
/func


func ttypeIsBinary(tt uint16) bool
  mut tok lex:Token

  tok'type = tt

  return synt:isBinary(ptr tok) or tt == tokens:MINUS
/func


func ttypeIsUnary(tt uint16) bool
  return ttypeIsBinary(tt)
/func


func ttypeIsComparison(tt uint16) bool
  return tt == tokens:MAJOR or tt == tokens:MINOR or tt == tokens:MAJEQ or tt == tokens:MINEQ or tt == tokens:EQUAL or tt == tokens:DIFFERENT
/func


func ttypeIsConst(tt uint16) bool
  return tt == tokens:STRING or tt == tokens:NUMBER or tt == tokens:NULL or tt == tokens:TRUE or tt == tokens:FALSE
/func


func ttypeIsEqDiff(tt uint16) bool
  return tt == tokens:EQUAL or tt == tokens:DIFFERENT
/func


func ttypeIsArith(tt uint16) bool
  return tt == tokens:PLUS or tt == tokens:MINUS or tt == tokens:MINOR or tt == tokens:MAJOR or tt == tokens:MAJEQ or tt == tokens:MINEQ or tt == tokens:MOD or tt == tokens:DIV or tt == tokens:INC or tt == tokens:DEC or tt == tokens:POW or tt == tokens:TIMES or tt == tokens:UMINUS or tt == tokens:AMPER or tt == tokens:PIPE or tt == tokens:XOR
/func


func ttypeIsBool(tt uint16) bool
  return tt == tokens:AND or tt == tokens:OR or tt == tokens:NOT
/func


func ttypeCanBeAssignTarget(tt uint16, type ptr ast:Type) bool
  return (tt == tokens:VAL or tt == tokens:OBRAC or tt == tokens:APOS or tt == tokens:COLON or tt == tokens:ID) and (type.isPtr() or type.isInt() or type.isStruct() or type.isBool())
/func


func assignLhsDump(cs ptr cs:Charstash, pexpr ptr ast:PExpr)
  mut op = pexpr'opType

  if op == tokens:ID
    cs.add(<ptr uint8>(pexpr'node'value))
    return
  /if

  mut left = <ptr ast:PExpr>(val pexpr'node'leaves.get(0))

  if op == tokens:VAL
    cs.add("'val ")

    assignLhsDump(cs, left)

    cs.add("' ")

    return
  /if

  if op == tokens:OBRAC
    cs.add(" member of '")
    assignLhsDump(cs, left)
    cs.add("' ")

    return
  /if

  mut right = <ptr ast:PExpr>(val pexpr'node'leaves.get(1))

  if op == tokens:APOS or op == tokens:COMMA
    cs.add("'")

    assignLhsDump(cs, left)

    cs.add(op == tokens:APOS => "'" || ":")

    assignLhsDump(cs, right)

    cs.add("' ")

    return
  /if

  cs.add("expr ")
/func


func intForVal(ctx ptr parser:Parser, value intptr) ptr ast:Type
  mut aval = math:abs(value)

  if aval < 2**7
    return ctx.matchBuiltin("int8")
  else
    if aval < 2**15
      return ctx.matchBuiltin("int16")
    else
      if aval < 2 ** 31
        return ctx.matchBuiltin("int32")
      /if
    /if
  /if

  return ctx.matchBuiltin("int64")
/func


func intTypesFindLargestCompatible(ctx ptr parser:Parser, type1, type2 ptr ast:Type) ptr ast:Type

  mut bothSigned = type1'isSigned and type2'isSigned
  mut bothUnsigned = not type1'isSigned and not type2'isSigned


  if bothUnsigned or bothSigned
    return type1'typeSize > type2'typeSize => type1 || type2
  /if

  # return intptr, must improve in the future
  return ctx.matchBuiltin("intptr")
/func


func typeIsAssignable(ctx ptr parser:Parser, scope ptr ast:PNode, dest,src ptr ast:Type) bool
  if not dest? or not src?
    return dest == src
  /if

  if dest'type == ast:TYPE_EMPTY or src'type == ast:TYPE_EMPTY
    return false
  /if

  if dest'name? and src'name? and not dest'builtin and not src'builtin
    mut ret = txt:strequals(dest'name, src'name)

    if ret and dest'moduleName? and src'moduleName?
      ret = txt:strequals(dest'moduleName, src'moduleName)
    /if

    return ret
  /if

  mut isFunc = dest'type == ast:TYPE_FUNC
  mut isStruct = dest'type == ast:TYPE_STRUCT
  mut isLoc = dest'type == ast:TYPE_LOC
  mut isPtr = dest'type == ast:TYPE_PTR

  if dest'type != src'type
    if dest'type == ast:TYPE_RECALIAS or src'type == ast:TYPE_RECALIAS
      dest = sema:findRecAlias(ctx, scope, dest)
      src = sema:findRecAlias(ctx, scope, src)

      return typeIsAssignable(ctx, scope, dest, src)
    /if

    if isPtr and src'type == ast:TYPE_NULL
      return true
    /if

    if dest.isData() and (src.isPtr() or src.isNull())
      return true
    /if

    return false
  /if

  if isFunc or isStruct
    mut i uintptr = 0
    mut len = dest'members.len()

    if len != src'members.len()
      return false
    /if

    while i < len
      mut pair1 = src'members.getAt(i)
      mut pair2 = dest'members.getAt(i)

      mut type1 = <ptr ast:Type>(pair1'value)
      mut type2 = <ptr ast:Type>(pair2'value)

      if not typeIsAssignable(ctx, scope, type2, type1)
        return false
      /if

      i++
    /while
  /if

  if isPtr or isLoc or isFunc
    if not typeIsAssignable(ctx, scope, dest'retType, src'retType)
      return false
    /if
  /if

  if isLoc
    if dest'itemCount != src'itemCount
      return false
    /if
  /if

  if dest'type == ast:TYPE_INT
    if dest'typeSize < src'typeSize
      return false
    /if
  /if

  return true
/func


func typeIsCastable(ctx ptr parser:Parser, scope ptr ast:PNode, dest,src ptr ast:Type) bool
  if dest'type == ast:TYPE_EMPTY or src'type == ast:TYPE_EMPTY
    return false
  /if

  mut isData = dest'type == ast:TYPE_DATA
  mut isPtr = dest'type == ast:TYPE_PTR
  mut isInt = dest'type == ast:TYPE_INT

  if isPtr or isInt or isData
    return src'type == ast:TYPE_INT or src'type == ast:TYPE_PTR or src'type == ast:TYPE_NULL or src'type == ast:TYPE_DATA
  /if

  return sema:typeIsAssignable(ctx, scope, dest, src)
/func


func validateExprConst(rsv sema:Resolver,
                       pexpr ptr ast:PExpr) ptr ast:Type

  mut op = pexpr'opType

  if op == tokens:STRING
    return rsv'ctx.matchBuiltin("ptr uint8")
  /if

  if op == tokens:NUMBER
    return intForVal(rsv'ctx, <intptr>(pexpr'node'value))
  /if

  if op == tokens:TRUE or op == tokens:FALSE
    return rsv'ctx.matchBuiltin("bool")
  /if

  if op == tokens:NULL
    return rsv'ctx.matchBuiltin("null")
  /if

  return null
/func


func validateExprCast(rsv sema:Resolver,
                      pexpr ptr ast:PExpr,
                      recList,errors ptr list:List) ptr ast:Type

  mut ptype = <ptr ast:PType>(pexpr'node'value)
  pexpr'type = sema:resolveType(rsv, ptype, errors)

  if pexpr'type == null
    return null
  /if

  mut childExpr = <ptr ast:PExpr>(val pexpr'node'leaves.get(0))
  mut chType = sema:validateExprRecl(rsv, childExpr, recList, errors)

  if chType == null or not sema:typeIsCastable(rsv'ctx, <ptr ast:PNode>(pexpr), pexpr'type, chType)
    mut cs = cs:new(20)

    cs.add("can't cast ")
    chType.summarize(cs)
    cs.add(" to ")
    pexpr'type.summarize(cs)

    mut str = cs:unwrap(cs)

    errors.append(parser:issueNew(parser:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, str))

    mem:free(str)
    return null
  /if

  return pexpr'type
/func


func validateSizeExpr(rsv sema:Resolver,
                      pexpr ptr ast:PExpr,
                      errors ptr list:List) ptr ast:Type

  mut ptype = <ptr ast:PType>(pexpr'node'value)

  mut sizeType = sema:resolveType(rsv, ptype, errors)
  if sizeType == null
    return null
  /if

  if sizeType'type == ast:TYPE_FUNC

    errors.append(parser:issueNew(parser:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, "invalid application of 'size' to a function type"))
    return null
  /if

  pexpr'sizeType = sizeType

  return rsv'ctx.matchBuiltin("uintptr")
/func


func validateExprId(rsv sema:Resolver,
                    pexpr ptr ast:PExpr,
                    recList,errors ptr list:List) ptr ast:Type

  mut name = <ptr uint8>(pexpr'node'value)
  mut type = ast:findSym(<ptr ast:PNode>(pexpr), name)

  if recList? and utils:listContains(recList, name)
    mut cs = cs:new(20)

    cs.add("type ")
    cs.add(name)
    cs.add(" causes an init loop ")
    utils:listDumpHierarchyIntoCS(recList, cs)

    mut str = cs:unwrap(cs)

    errors.append(parser:issueNew(parser:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, str))

    mem:free(str)

    return null
  /if

  # try searching for a top declaration
  if not type?
    return sema:resolveDeclType(rsv, name, <ptr ast:PNode>(pexpr), recList, errors)
  /if

  return type
/func


func validateBoolExpr(rsv sema:Resolver,
                      pexpr ptr ast:PExpr,
                      ltype,rtype ptr ast:Type,
                      recList,errors ptr list:List) ptr ast:Type

  mut op = pexpr'opType

  if not ltype.isBool() or not rtype.isBool()
    mut cs = cs:new(20)

    cs.add("cannot apply ")
    cs.add(lex:ttypeStr(op))
    cs.add(" to types ")
    ltype.summarize(cs)
    cs.add(" and ")
    rtype.summarize(cs)

    mut str = cs:unwrap(cs)

    errors.append(parser:issueNew(parser:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, str))

    mem:free(str)

    return null
  /if

  return rsv'ctx.matchBuiltin("bool")
/func


func validateArithPtrExpr(rsv sema:Resolver,
                          pexpr ptr ast:PExpr,
                          ltype,rtype ptr ast:Type,
                          recList,errors ptr list:List) ptr ast:Type

  if not ttypeOpCanDoPtrArith(pexpr'opType)
    mut cs = cs:new(20)

    cs.add("operator ")
    cs.add(lex:ttypeStr(pexpr'opType))
    cs.add(" is not appliable to pointers")

    mut str = cs:unwrap(cs)

    errors.append(parser:issueNew(parser:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, str))

    mem:free(str)

    return null
  /if

  if ltype.isPtr() and rtype.isPtr()
    if pexpr'opType == tokens:MINUS
      if not sema:typeIsAssignable(rsv'ctx, <ptr ast:PNode>(pexpr), ltype, rtype)
        mut cs = cs:new(20)

        cs.add("types ")
        ltype.summarize(cs)
        cs.add(" and ")
        rtype.summarize(cs)
        cs.add(" are not compatible")

        mut str = cs:unwrap(cs)

        errors.append(parser:issueNew(parser:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, str))

        mem:free(str)

        return null
      /if

      return rsv'ctx.matchBuiltin("intptr")
    else
      errors.append(parser:issueNew(parser:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, "only difference between two pointers can be allowed"))
      return null
    /if
  /if

  # If we reached this point, then we have an int and a pointer.
  # Let's choose the pointer and then return the type of it.

  return ltype.isPtr() => ltype || rtype
/func


func validateArithExpr(rsv sema:Resolver,
                       pexpr ptr ast:PExpr,
                       ltype,rtype ptr ast:Type,
                       recList,errors ptr list:List) ptr ast:Type

  mut op = pexpr'opType

  if not (ltype.isInt() or ltype.isPtr()) or not (rtype.isPtr() or rtype.isInt())
    errors.append(parser:issueNew(parser:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, "arithmetic operations can only involve pointers and integers"))

    return null
  /if

  if ltype.isPtr() or rtype.isPtr()
    return validateArithPtrExpr(rsv, pexpr, ltype, rtype, recList, errors)
  /if

  if op == tokens:POW
    return rsv'ctx.matchBuiltin("uintptr")
  /if

  # In this case, we only have integers, so we just need to evaluate the larger
  # type or resolve to boolean in case of a major/minor comparison.

  return ttypeIsComparison(op) => rsv'ctx.matchBuiltin("bool") || (ltype'typeSize > rtype'typeSize => ltype || rtype)
/func


func validateEqDiffExpr(rsv sema:Resolver,
                        pexpr ptr ast:PExpr,
                        ltype,rtype ptr ast:Type,
                        errors ptr list:List) ptr ast:Type

  mut success = true

  if ltype'type != rtype'type
    # the only case in which we can accept a comparison between different types
    # is when we are comparing a pointer with null.
    if not ((ltype.isNull() and rtype.isPtr()) or (ltype.isPtr() and rtype.isNull()))
      success = false
    /if
  else
    if not (ltype.isPtr() or ltype.isInt() or ltype.isBool())
      success = false
    /if
  /if

  if not success
    errors.append(parser:issueNew(parser:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, "cannot evaluate the equivalence of two incompatible types"))
  /if

  return success => rsv'ctx.matchBuiltin("bool") || null
/func


func validateModuleAccessExpr(rsv sema:Resolver,
                              pexpr ptr ast:PExpr,
                              errors ptr list:List) ptr ast:Type

  mut modName = <ptr uint8>(<ptr ast:PNode>(val pexpr'node'leaves.get(0))'value)
  if not ast:prootHasImported(rsv'root, modName)
    mut msg = txt:strappend(modName, " has never been imported")
    errors.append(parser:issueNew(parser:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, msg))
    mem:free(msg)

    return null
  /if

  mut symName = <ptr uint8>(<ptr ast:PNode>(val pexpr'node'leaves.get(1))'value)
  mut type = sema:findSymModule(rsv'ctx, modName, symName)

  if type == null
    mut cs = cs:new(20)
    cs.add("'")
    cs.add(symName)
    cs.add("' is not defined in module '")
    cs.add(modName)
    cs.add("'")

    mut msg = cs:unwrap(cs)

    errors.append(parser:issueNew(parser:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, msg))

    mem:free(msg)

    return null
  /if

  return type
/func


func resolveRecType(rsv sema:Resolver,
                    type ptr ast:Type) ptr ast:Type

  if type'type != ast:TYPE_RECALIAS
    return type
  /if

  if type'moduleName != null
    return sema:findAliasImport(rsv'ctx, type'moduleName, type'name)
  /if

  return sema:findAliasLocal(<ptr ast:PNode>(rsv'root), type'name)
/func


func validateStructureAccessExpr(rsv sema:Resolver,
                                 pexpr ptr ast:PExpr,
                                 ltype ptr ast:Type,
                                 errors ptr list:List) ptr ast:Type

  mut accType = ltype

  if ltype'type == ast:TYPE_PTR
    accType = resolveRecType(rsv, ltype'retType)
  /if

  if not accType.isStruct()
    mut cs = cs:new(20)
    cs.add("'")
    accType.summarize(cs)
    cs.add("' is neither a structure nor a pointer to a structure")

    mut msg = cs:unwrap(cs)

    errors.append(parser:issueNew(parser:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, msg))

    mem:free(msg)

    return null
  /if

  mut field = <ptr uint8>(<ptr ast:PNode>(val pexpr'node'leaves.get(1))'value)

  mut type = <ptr ast:Type>(accType'members.get(field))

  if not type?
    mut cs = cs:new(20)
    cs.add("no field called '")
    cs.add(field)
    cs.add("' in type ")
    accType.summarize(cs)

    mut msg = cs:unwrap(cs)

    errors.append(parser:issueNew(parser:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, msg))

    mem:free(msg)

    return null
  /if

  return type
/func


func validateArrayAccess(rsv sema:Resolver,
                         pexpr ptr ast:PExpr,
                         ltype,rtype ptr ast:Type,
                         errors ptr list:List) ptr ast:Type

  if ltype'type != ast:TYPE_PTR and not ltype.isLoc()
    errors.append(parser:issueNew(parser:ISSUE_ERR, pexpr'node'begin, \
                    rsv'root'fileName, \
                    "array access is allowed only for pointers and locations"))
  /if

  if not rtype.isInt()
    errors.append(parser:issueNew(parser:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, "an expression of integer type is required for array access"))
  /if

  return ltype'retType
/func


func normalizeEmptyType(ctx ptr parser:Parser, type ptr ast:Type) ptr ast:Type
  return type ?? ctx.matchBuiltin("\0")
/func


func validateFunctionCallExpr(rsv sema:Resolver,
                              pexpr ptr ast:PExpr,
                              ltype ptr ast:Type,
                              recList,errors ptr list:List) ptr ast:Type

  mut accType = ltype

  if ltype'type == ast:TYPE_PTR
    accType = ltype'retType
  /if

  if not accType.isFunc()
    errors.append(parser:issueNew(parser:ISSUE_ERR, pexpr'node'begin, \
                    rsv'root'fileName, \
                    "expression is neither a function nor a pointer to a function"))

    return null
  /if

  mut expParams = accType'members
  mut expLen = expParams.len()

  mut argsLen = pexpr'node'leaves.len()

  if argsLen != expLen + 1
    mut cs = cs:new(20)
    cs.add("can't call function ")

    if ltype'name?
      cs.add("'")

      if ltype'moduleName?
        cs.add(accType'moduleName)
        cs.add(":")
      /if

      cs.add(accType'name)
      cs.add("' ")
    else
      accType.summarize(cs)
    /if

    cs.add(": expected ")
    cs.addInt(expLen)
    cs.add(" parameters, got ")
    cs.addInt(argsLen - 1)

    mut msg = cs:unwrap(cs)

    errors.append(parser:issueNew(parser:ISSUE_ERR, pexpr'node'begin, \
                                              rsv'root'fileName, msg))

    mem:free(msg)

    return null
  /if

  mut scope = <ptr ast:PNode>(pexpr)
  mut i uintptr = 0

  while i < expLen
    mut gotParam = <ptr ast:PExpr>(val scope'leaves.get(i + 1))
    mut expPair = expParams.getAt(i)

    mut expType = <ptr ast:Type>(expPair'value)

    mut gotType = sema:validateExprRecl(rsv, gotParam, recList, errors)
    if not gotType?
      return null
    /if

    if not sema:typeIsAssignable(rsv'ctx, scope, expType, gotType)
      mut cs = cs:new(20)
      cs.add("passing '")

      gotType.summarize(cs)

      cs.add("' to parameter '")
      cs.add(<ptr uint8>(expPair'key))
      cs.add("' of type '")

      expType.summarize(cs)

      cs.add("'")

      mut msg = cs:unwrap(cs)

      errors.append(parser:issueNew(parser:ISSUE_ERR, \
                            pexpr'node'begin, rsv'root'fileName, msg))

      mem:free(msg)

      return null
    /if

    i++
  /while

  return normalizeEmptyType(rsv'ctx, <ptr ast:Type>(accType'retType))
/func


func validateAssignExpr(rsv sema:Resolver,
                        pexpr,left ptr ast:PExpr,
                        ltype,rtype ptr ast:Type,
                        errors ptr list:List) ptr ast:Type

  if not ttypeCanBeAssignTarget(left'opType, ltype)
    mut msg = "expression cannot be target of assignment"

    if left'opType == tokens:ME
      msg = "can't reassign 'me'"
    /if

    errors.append(parser:issueNew(parser:ISSUE_ERR, left'node'begin, \
                                              rsv'root'fileName, msg))
    return null
  /if

  if not sema:typeIsAssignable(rsv'ctx, <ptr ast:PNode>(pexpr), ltype, rtype)
    mut cs = cs:new(20)

    cs.add("cannot assign expression of type '")
    rtype.summarize(cs)
    cs.add("' to a lvalue of type '")
    ltype.summarize(cs)
    cs.add("'")

    mut str = cs:unwrap(cs)

    errors.append(parser:issueNew(parser:ISSUE_ERR, pexpr'node'begin, \
                                              rsv'root'fileName, str))

    mem:free(str)

    return null
  /if

  return ltype
/func


func validateNullCoalescingExpr(rsv sema:Resolver,
                                pexpr ptr ast:PExpr,
                                ltype,rtype ptr ast:Type,
                                errors ptr list:List) ptr ast:Type

  if not ltype.isPtr()
    mut cs = cs:new(20)

    cs.add("cannot coalesce non pointer type '")
    ltype.summarize(cs)
    cs.add("'")

    mut str = cs:unwrap(cs)

    errors.append(parser:issueNew(parser:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, str))

    mem:free(str)

    return null
  /if

  if not sema:typeIsAssignable(rsv'ctx, <ptr ast:PNode>(pexpr), ltype, rtype)
    mut cs = cs:new(20)

    cs.add("cannot coalesce type '")
    ltype.summarize(cs)
    cs.add("' with type '")
    rtype.summarize(cs)
    cs.add("'")

    mut str = cs:unwrap(cs)

    errors.append(parser:issueNew(parser:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, str))

    mem:free(str)

    return null
  /if

  return ltype
/func


# a.b syntax is allowed ONLY if it's a method call.
# Otherwise method access is semantically nonsense (until closures, of course).
func pnodeAllowedToUseDot(node ptr ast:PNode) bool
  return node'type == ast:PEXPR and <ptr ast:PExpr>(node)'opType == tokens:OPAR
/func


func resolveMethod(rsv sema:Resolver,
                   pexpr ptr ast:PExpr,
                   typeModule,typeName,methodName ptr uint8,
                   recList,errors ptr list:List) ptr ast:Type

  mut type = sema:findMethod(rsv, <ptr ast:PNode>(pexpr), typeModule, typeName, methodName)

  if type != null
    return type
  /if

  mut name = ast:methodKey(typeModule, typeName, methodName)

  # try searching for a top declaration
  type = sema:resolveDeclType(rsv, name, <ptr ast:PNode>(pexpr), recList, errors)

  mem:free(name)

  return type
/func


func validateMethodExpr(rsv sema:Resolver,
                        pexpr ptr ast:PExpr,
                        ltype ptr ast:Type,
                        recList,errors ptr list:List) ptr ast:Type

  if not pnodeAllowedToUseDot(pexpr'node'parent)
    mut msg = "methods can be accessed only when invoked"
    errors.append(parser:issueNew(parser:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, msg))

    return null
  /if

  mut accType = ltype

  if ltype'type == ast:TYPE_PTR
    accType = resolveRecType(rsv, ltype'retType)
  /if

  if accType'name == null
    mut cs = cs:new(20)
    cs.add("'")
    accType.summarize(cs)
    cs.add("' is not a named type. Raw struct, pointer or function types can't have methods")

    mut msg = cs:unwrap(cs)

    errors.append(parser:issueNew(parser:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, msg))

    mem:free(msg)

    return null
  /if

  mut methodName = <ptr uint8>(<ptr ast:PNode>(val pexpr'node'leaves.get(1))'value)

  return resolveMethod(rsv, pexpr, accType'moduleName, accType'name, methodName, recList, errors)
/func


func validateBinaryExpr(rsv sema:Resolver,
                        pexpr ptr ast:PExpr,
                        recList,errors ptr list:List) ptr ast:Type

  mut op = pexpr'opType

  # handle apos, dot, colon and call operators before because they are special
  # (i.e. no expressions or expressions only on lhs)

  if op == tokens:COLON
    return validateModuleAccessExpr(rsv, pexpr, errors)
  /if

  mut left = <ptr ast:PExpr>(val pexpr'node'leaves.get(0))
  mut ltype = sema:validateExprRecl(rsv, left, recList, errors)

  if ltype == null
    return null
  /if

  # method access
  if op == tokens:DOT
    return validateMethodExpr(rsv, pexpr, ltype, recList, errors)
  /if

  # structure field access
  if op == tokens:APOS
    return validateStructureAccessExpr(rsv, pexpr, ltype,  errors)
  /if

  # function call
  if op == tokens:OPAR
    return validateFunctionCallExpr(rsv, pexpr, ltype, recList, errors)
  /if

  mut right = <ptr ast:PExpr>(val pexpr'node'leaves.get(1))
  mut rtype = sema:validateExprRecl(rsv, right, recList, errors)

  if rtype == null
    return null
  /if

  # array access
  if op == tokens:OBRAC
    return validateArrayAccess(rsv, pexpr, ltype, rtype, errors)
  /if

  if op == tokens:DQUEST
    return validateNullCoalescingExpr(rsv, pexpr, ltype, rtype, errors)
  /if

  if ttypeIsBool(op)
    return validateBoolExpr(rsv, pexpr, ltype, rtype, recList, errors)
  /if

  if ttypeIsArith(op)
    return validateArithExpr(rsv, pexpr, ltype, rtype, recList, errors)
  /if

  if ttypeIsEqDiff(op)
    return validateEqDiffExpr(rsv, pexpr, ltype, rtype, errors)
  /if

  return validateAssignExpr(rsv, pexpr, left, ltype, rtype, errors)
/func


func validateNotExpr(rsv sema:Resolver,
                     pexpr ptr ast:PExpr,
                     atype ptr ast:Type,
                     errors ptr list:List) ptr ast:Type

  if not atype.isBool()
    errors.append(parser:issueNew(parser:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, "expression must be boolean"))

    return null
  /if

  # always boolean
  return atype
/func


func validateValExpr(rsv sema:Resolver,
                     pexpr ptr ast:PExpr,
                     atype ptr ast:Type,
                     errors ptr list:List) ptr ast:Type

  if atype'type != ast:TYPE_PTR
    mut cs = cs:new(20)
    cs.add("type '")
    atype.summarize(cs)
    cs.add("' is not dereferenceable")

    mut msg = cs:unwrap(cs)

    errors.append(parser:issueNew(parser:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, msg))

    mem:free(msg)

    return null
  /if

  return <ptr ast:Type>(atype'retType)
/func


func validatePtrExpr(rsv sema:Resolver,
                     pexpr ptr ast:PExpr,
                     atype ptr ast:Type,
                     errors ptr list:List) ptr ast:Type

  if atype.isNull()
    errors.append(parser:issueNew(parser:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, "can't extract the address of null"))

    return null
  /if

  return astfn:typeNewPtr(rsv'root'typePool, null, null, atype)
/func


func validateUMinusExpr(rsv sema:Resolver,
                        pexpr ptr ast:PExpr,
                        atype ptr ast:Type,
                        errors ptr list:List) ptr ast:Type

  if not atype.isInt()
    mut cs = cs:new(20)
    cs.add("cannot apply unary '-' to type '")
    atype.summarize(cs)
    cs.add("'")

    mut msg = cs:unwrap(cs)

    errors.append(parser:issueNew(parser:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, msg))

    mem:free(msg)

    return null
  /if

  if not atype'isSigned
    mut cs = cs:new(20)
    cs.add("cannot apply unary '-' to unsigned type '")
    atype.summarize(cs)
    cs.add("'")

    mut msg = cs:unwrap(cs)

    errors.append(parser:issueNew(parser:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, msg))

    mem:free(msg)

    return null
  /if

  return atype
/func


func validateIncDecExpr(rsv sema:Resolver,
                        pexpr,atarget ptr ast:PExpr,
                        atype ptr ast:Type,
                        errors ptr list:List) ptr ast:Type

  if not atype.isInt() and not atype.isPtr()
    mut cs = cs:new(20)
    cs.add("type '")
    atype.summarize(cs)
    cs.add("' is not an integer or pointer type")

    mut msg = cs:unwrap(cs)

    errors.append(parser:issueNew(parser:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, msg))

    mem:free(msg)

    return null
  /if

  if not ttypeCanBeAssignTarget(atarget'opType, atype)
    errors.append(parser:issueNew(parser:ISSUE_ERR, atarget'node'begin, rsv'root'fileName, "expression is not assignable"))

    return null
  /if

  return atype
/func


func validateQuestExpr(rsv sema:Resolver,
                       pexpr ptr ast:PExpr,
                       atype ptr ast:Type,
                       errors ptr list:List) ptr ast:Type

  if not atype.isPtr()
    mut cs = cs:new(20)
    cs.add("cannot apply '?' to type '")
    atype.summarize(cs)
    cs.add("'")

    mut msg = cs:unwrap(cs)

    errors.append(parser:issueNew(parser:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, msg))

    mem:free(msg)

    return null
  /if

  return rsv'ctx.matchBuiltin("bool")
/func


func validateUnaryExpr(rsv sema:Resolver,
                       pexpr ptr ast:PExpr,
                       recList, errors ptr list:List) ptr ast:Type

  mut op = pexpr'opType

  mut arg = <ptr ast:PExpr>(val pexpr'node'leaves.get(0))
  mut atype = sema:validateExprRecl(rsv, arg, recList, errors)

  if atype == null
    return null
  /if

  if op == tokens:NOT
    return validateNotExpr(rsv, pexpr, atype, errors)
  /if

  if op == tokens:VAL
    return validateValExpr(rsv, pexpr, atype, errors)
  /if

  if op == tokens:PTR
    return validatePtrExpr(rsv, pexpr, atype, errors)
  /if

  if op == tokens:UMINUS
    return validateUMinusExpr(rsv, pexpr, atype, errors)
  /if

  if op == tokens:QUEST
    return validateQuestExpr(rsv, pexpr, atype, errors)
  /if

  # if we've reached this point then it's '++' or '--'

  return validateIncDecExpr(rsv, pexpr, arg, atype, errors)
/func


func validateTernaryExpr(rsv sema:Resolver,
                         pexpr ptr ast:PExpr,
                         recList, errors ptr list:List) ptr ast:Type

  mut condition = <ptr ast:PExpr>(val pexpr'node'leaves.get(0))
  mut condType = sema:validateExprRecl(rsv, condition, recList, errors)

  mut left = <ptr ast:PExpr>(val pexpr'node'leaves.get(1))
  mut leftType = sema:validateExprRecl(rsv, left, recList, errors)

  mut right = <ptr ast:PExpr>(val pexpr'node'leaves.get(2))
  mut rightType = sema:validateExprRecl(rsv, right, recList, errors)

  if condType == null or leftType == null or rightType == null
    return null
  /if

  if not condType.isBool()
    errors.append(parser:issueNew(parser:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, "non boolean ternary condition"))

    return null
  /if

  # This is done on purpose, because "typeIsAssignable" is not commutative:
  # it evalutates that the second argument is assignable to the first, but in a
  # ternary operator the position of the two conditional choices is irrelevant
  # for sake of type determination, so we must run it twice with reversed
  # arguments
  if not sema:typeIsAssignable(rsv'ctx, <ptr ast:PNode>(pexpr), leftType, rightType) and not sema:typeIsAssignable(rsv'ctx, <ptr ast:PNode>(pexpr), rightType, leftType)
    mut cs = cs:new(20)
    cs.add("ternary expression arguments have incompatible types '")
    leftType.summarize(cs)
    cs.add("' and '")
    rightType.summarize(cs)
    cs.add("'")

    mut msg = cs:unwrap(cs)

    errors.append(parser:issueNew(parser:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, msg))

    mem:free(msg)

    return null
  /if

  if leftType.isData() or rightType.isData()
    return rsv'ctx.matchBuiltin("data")
  /if

  if leftType.isNull()
    return rightType
  /if

  if rightType.isNull()
    return leftType
  /if

  if leftType.isInt()
    return intTypesFindLargestCompatible(rsv'ctx, leftType, rightType)
  /if

  # left and right type should pretty much the same now
  return leftType
/func


func validateMeExpr(rsv sema:Resolver,
                    pexpr ptr ast:PExpr,
                    errors ptr list:List) ptr ast:Type

  mut meType = ast:findSym(<ptr ast:PNode>(pexpr), "me")
  if meType == null
    mut msg = "'me' outside of method body"
    errors.append(parser:issueNew(parser:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, msg))
  /if

  return meType
/func


func validateStructLiteralExpr(rsv sema:Resolver,
                               pexpr ptr ast:PExpr,
                               recList,errors ptr list:List) ptr ast:Type

  mut scope = <ptr ast:PNode>(pexpr)
  mut leavesLen = scope'leaves.len()
  mut i int32 = 0

  mut members = kv:strnew(leavesLen)
  members.setFreeFuncs(ptr mem:free, null)

  while i < leavesLen
    mut param = <ptr ast:PExpr>(val scope'leaves.get(i))
    mut type = sema:validateExprRecl(rsv, param, recList, errors)

    if not type?
      kv:free(members)

      return null
    /if

    members.put(txt:representNum(i), type)

    i++
  /while

  return astfn:typeNewStruct(rsv'root'typePool, null, null, members)

/func


func validateExprRecl(rsv sema:Resolver,
                      pexpr ptr ast:PExpr,
                      recList,errors ptr list:List) ptr ast:Type


  if pexpr'node'validated
    return pexpr'type
  /if

  pexpr'type = null

  mut op = pexpr'opType
  if ttypeIsConst(op)
    return (pexpr'type = validateExprConst(rsv, pexpr))
  else
    if op == tokens:ME
      pexpr'type = validateMeExpr(rsv, pexpr, errors)
    else
      if op == tokens:ID
        pexpr'type = validateExprId(rsv, pexpr, recList, errors)
      else
        if op == tokens:CAST
          pexpr'type = validateExprCast(rsv, pexpr, recList, errors)
        else
          if op == tokens:SIZE
            pexpr'type = validateSizeExpr(rsv, pexpr, errors)
          else
            if op == tokens:OCURLY
              pexpr'type = validateStructLiteralExpr(rsv, pexpr, recList, errors)
            else
              if ttypeIsTernary(op)
                pexpr'type = validateTernaryExpr(rsv, pexpr, recList, errors)
              else
                if ttypeIsBinary(op)
                  pexpr'type = validateBinaryExpr(rsv, pexpr, recList, errors)
                else
                  pexpr'type = validateUnaryExpr(rsv, pexpr, recList, errors)
                /if
              /if
            /if
          /if
        /if
      /if
    /if
  /if

  if pexpr'type?
    pexpr'node'validated = true
  /if

  return pexpr'type
/func


func validateExpr(rsv sema:Resolver,
                  pexpr ptr ast:PExpr,
                  errors ptr list:List) ptr ast:Type

  return validateExprRecl(rsv, pexpr, null, errors)
/func
