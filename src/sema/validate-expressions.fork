#  libfork, a base library for the Fork language
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2015
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the
#  licenses expressed under Section 1.12 of the MPL v2.


import ast
import base
import ctx
import lex
import sema
import synt
import utils


func ttypeOpCanDoPtrArith(tt uint16) bool
  return tt == lex:PLUS or tt == lex:MINUS or tt == lex:INC or tt == lex:DEC
/func


func ttypeIsTernary(tt uint16) bool
  return tt == lex:FATARROW
/func


func ttypeIsBinary(tt uint16) bool
  mut tok lex:Token

  tok'type = tt

  return synt:isBinary(ptr tok) or tt == lex:MINUS
/func


func ttypeIsUnary(tt uint16) bool
  return ttypeIsBinary(tt)
/func


func ttypeIsComparison(tt uint16) bool
  return tt == lex:MAJOR or tt == lex:MINOR or tt == lex:MAJEQ or tt == lex:MINEQ or tt == lex:EQUAL or tt == lex:DIFFERENT
/func


func ttypeIsConst(tt uint16) bool
  return tt == lex:STRING or tt == lex:NUMBER or tt == lex:NULLPTR or tt == lex:TRUE or tt == lex:FALSE
/func


func ttypeIsEqDiff(tt uint16) bool
  return tt == lex:EQUAL or tt == lex:DIFFERENT
/func


func ttypeIsArith(tt uint16) bool
  return tt == lex:PLUS or tt == lex:MINUS or tt == lex:MINOR or tt == lex:MAJOR or tt == lex:MAJEQ or tt == lex:MINEQ or tt == lex:MOD or tt == lex:DIV or tt == lex:INC or tt == lex:DEC or tt == lex:POW or tt == lex:TIMES or tt == lex:UMINUS or tt == lex:AMPER or tt == lex:PIPE or tt == lex:XOR
/func


func ttypeIsBool(tt uint16) bool
  return tt == lex:AND or tt == lex:OR or tt == lex:NOT
/func


func ttypeCanBeAssignTarget(tt uint16, type ptr ast:Type) bool
  return (tt == lex:VAL or tt == lex:OBRAC or tt == lex:APOS or tt == lex:COLON or tt == lex:ID) and (ast:typeIsPtr(type) or ast:typeIsInt(type) or ast:typeIsStruct(type) or ast:typeIsBool(type))
/func


func assignLhsDump(cs ptr base:Charstash, pexpr ptr ast:PExpr)
  mut op = pexpr'opType

  if op == lex:ID
    base:csAppendStr(cs, cast<ptr uint8>(pexpr'node'value))
    return
  /if

  mut left = cast<ptr ast:PExpr>(val base:listGet(pexpr'node'leaves, 0))

  if op == lex:VAL
    base:csAppendStr(cs, "'val ")

    assignLhsDump(cs, left)

    base:csAppendStr(cs, "' ")

    return
  /if

  if op == lex:OBRAC
    base:csAppendStr(cs, " member of '")
    assignLhsDump(cs, left)
    base:csAppendStr(cs, "' ")

    return
  /if

  mut right = cast<ptr ast:PExpr>(val base:listGet(pexpr'node'leaves, 1))

  if op == lex:APOS or op == lex:COMMA
    base:csAppendStr(cs, "'")

    assignLhsDump(cs, left)

    base:csAppendStr(cs, op == lex:APOS => "'" || ":")

    assignLhsDump(cs, right)

    base:csAppendStr(cs, "' ")

    return
  /if

  base:csAppendStr(cs, "expr ")
/func


func intForVal(ctx ptr ctx:Context, value intptr) ptr ast:Type
  mut aval = base:abs(value)

  if aval < 2**7
    return ctx:contextMatchBuiltin(ctx, "int8")
  else
    if aval < 2**15
      return ctx:contextMatchBuiltin(ctx, "int16")
    else
      if aval < 2 ** 31
        return ctx:contextMatchBuiltin(ctx, "int32")
      /if
    /if
  /if

  return ctx:contextMatchBuiltin(ctx, "int64")
/func


func intTypesFindLargestCompatible(ctx ptr ctx:Context, type1, type2 ptr ast:Type) ptr ast:Type

  mut bothSigned = type1'isSigned and type2'isSigned
  mut bothUnsigned = !type1'isSigned and !type2'isSigned


  if bothUnsigned or bothSigned
    return type1'typeSize > type2'typeSize => type1 || type2
  /if

  # return intptr, must improve in the future
  return ctx:contextMatchBuiltin(ctx, "intptr")
/func


func typeIsAssignable(ctx ptr ctx:Context, scope ptr ast:PNode, dest,src ptr ast:Type) bool
  if dest == null or src == null
    return dest == src
  /if

  if dest'type == ast:TYPE_EMPTY or src'type == ast:TYPE_EMPTY
    return false
  /if

  if dest'name != null and src'name != null and !dest'builtin and !src'builtin
    mut ret = base:strequals(dest'name, src'name)

    if ret and dest'moduleName != null and src'moduleName != null
      ret = base:strequals(dest'moduleName, src'moduleName)
    /if

    return ret
  /if

  mut isFunc = dest'type == ast:TYPE_FUNC
  mut isStruct = dest'type == ast:TYPE_STRUCT
  mut isLoc = dest'type == ast:TYPE_LOC
  mut isPtr = dest'type == ast:TYPE_PTR

  if dest'type != src'type
    if dest'type == ast:TYPE_RECALIAS or src'type == ast:TYPE_RECALIAS
      dest = sema:findRecAlias(ctx, scope, dest)
      src = sema:findRecAlias(ctx, scope, src)

      return typeIsAssignable(ctx, scope, dest, src)
    /if

    if isPtr and src'type == ast:TYPE_NULL
      return true
    /if

    if ast:typeIsData(dest) and (ast:typeIsPtr(src) or ast:typeIsNull(src))
      return true
    /if

    return false
  /if

  if isFunc or isStruct
    mut i uintptr = 0
    mut len = utils:kvLen(dest'members)

    if len != utils:kvLen(src'members)
      return false
    /if

    while i < len
      mut pair1 = utils:kvGetAt(src'members, i)
      mut pair2 = utils:kvGetAt(dest'members, i)

      mut type1 = cast<ptr ast:Type>(pair1'value)
      mut type2 = cast<ptr ast:Type>(pair2'value)

      if !typeIsAssignable(ctx, scope, type2, type1)
        return false
      /if

      i++
    /while
  /if

  if isPtr or isLoc or isFunc
    if !typeIsAssignable(ctx, scope, dest'retType, src'retType)
      return false
    /if
  /if

  if isLoc
    if dest'itemCount != src'itemCount
      return false
    /if
  /if

  if dest'type == ast:TYPE_INT
    if dest'typeSize < src'typeSize
      return false
    /if
  /if

  return true
/func


func typeIsCastable(ctx ptr ctx:Context, scope ptr ast:PNode, dest,src ptr ast:Type) bool
  if dest'type == ast:TYPE_EMPTY or src'type == ast:TYPE_EMPTY
    return false
  /if

  mut isData = dest'type == ast:TYPE_DATA
  mut isPtr = dest'type == ast:TYPE_PTR
  mut isInt = dest'type == ast:TYPE_INT

  if isPtr or isInt or isData
    return src'type == ast:TYPE_INT or src'type == ast:TYPE_PTR or src'type == ast:TYPE_NULL or src'type == ast:TYPE_DATA
  /if

  return sema:typeIsAssignable(ctx, scope, dest, src)
/func


func validateExprConst(rsv sema:Resolver,
                       pexpr ptr ast:PExpr) ptr ast:Type

  mut op = pexpr'opType

  if op == lex:STRING
    return ctx:contextMatchBuiltin(rsv'ctx, "ptr uint8")
  /if

  if op == lex:NUMBER
    return intForVal(rsv'ctx, cast<intptr>(pexpr'node'value))
  /if

  if op == lex:TRUE or op == lex:FALSE
    return ctx:contextMatchBuiltin(rsv'ctx, "bool")
  /if

  if op == lex:NULLPTR
    return ctx:contextMatchBuiltin(rsv'ctx, "null")
  /if

  return null
/func


func validateExprCast(rsv sema:Resolver,
                      pexpr ptr ast:PExpr,
                      recList,errors ptr base:List) ptr ast:Type

  mut ptype = cast<ptr ast:PType>(pexpr'node'value)
  pexpr'type = sema:resolveType(rsv, ptype, errors)

  if pexpr'type == null
    return null
  /if

  mut childExpr = cast<ptr ast:PExpr>(val base:listGet(pexpr'node'leaves, 0))
  mut chType = sema:validateExprRecl(rsv, childExpr, recList, errors)

  if chType == null or !sema:typeIsCastable(rsv'ctx, cast<ptr ast:PNode>(pexpr), chType, pexpr'type)
    mut cs = base:csNew(20)

    base:csAppendStr(cs, "can't cast ")
    ast:typeSummarize(cs, chType)
    base:csAppendStr(cs, " to ")
    ast:typeSummarize(cs, pexpr'type)

    mut str = base:csUnleash(cs)

    base:listAppend(errors, utils:issueNew(utils:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, str))

    base:free(str)
    return null
  /if

  return pexpr'type
/func


func validateSizeExpr(rsv sema:Resolver,
                      pexpr ptr ast:PExpr,
                      errors ptr base:List) ptr ast:Type

  mut ptype = cast<ptr ast:PType>(pexpr'node'value)

  mut sizeType = sema:resolveType(rsv, ptype, errors)
  if sizeType == null
    return null
  /if

  if sizeType'type == ast:TYPE_FUNC

    base:listAppend(errors, utils:issueNew(utils:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, "invalid application of 'size' to a function type"))
    return null
  /if

  return ctx:contextMatchBuiltin(rsv'ctx, "uintptr")
/func


decl resolveDeclType func(rsv sema:Resolver,
                          name ptr uint8,
                          node ptr ast:PNode,
                          recList,errors ptr base:List) ptr ast:Type


func validateExprId(rsv sema:Resolver,
                    pexpr ptr ast:PExpr,
                    recList,errors ptr base:List) ptr ast:Type

  mut name = cast<ptr uint8>(pexpr'node'value)
  mut type = sema:findSym(cast<ptr ast:PNode>(pexpr), name)

  if recList != null and utils:listContains(recList, name)
    mut cs = base:csNew(20)

    base:csAppendStr(cs, "type ")
    base:csAppendStr(cs, name)
    base:csAppendStr(cs, " causes an init loop ")
    utils:listDumpHierarchyIntoCS(recList, cs)

    mut str = base:csUnleash(cs)

    base:listAppend(errors, utils:issueNew(utils:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, str))

    base:free(str)

    return null
  /if

  # try searching for a top declaration
  if type == null and (type = resolveDeclType(rsv, name, cast<ptr ast:PNode>(pexpr), recList, errors)) == null
    return null
  /if

  return type
/func


func validateBoolExpr(rsv sema:Resolver,
                      pexpr ptr ast:PExpr,
                      ltype,rtype ptr ast:Type,
                      recList,errors ptr base:List) ptr ast:Type

  mut op = pexpr'opType

  if !ast:typeIsBool(ltype) or !ast:typeIsBool(rtype)
    mut cs = base:csNew(20)

    base:csAppendStr(cs, "cannot apply ")
    base:csAppendStr(cs, lex:ttypeStr(op))
    base:csAppendStr(cs, " to types ")
    ast:typeSummarize(cs, ltype)
    base:csAppendStr(cs, " and ")
    ast:typeSummarize(cs, rtype)

    mut str = base:csUnleash(cs)

    base:listAppend(errors, utils:issueNew(utils:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, str))

    base:free(str)

    return null
  /if

  return ctx:contextMatchBuiltin(rsv'ctx, "bool")
/func


func validateArithPtrExpr(rsv sema:Resolver,
                          pexpr ptr ast:PExpr,
                          ltype,rtype ptr ast:Type,
                          recList,errors ptr base:List) ptr ast:Type

  if !ttypeOpCanDoPtrArith(pexpr'opType)
    mut cs = base:csNew(20)

    base:csAppendStr(cs, "operator ")
    base:csAppendStr(cs, lex:ttypeStr(pexpr'opType))
    base:csAppendStr(cs, " is not appliable to pointers")

    mut str = base:csUnleash(cs)

    base:listAppend(errors, utils:issueNew(utils:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, str))

    base:free(str)

    return null
  /if

  if ast:typeIsPtr(ltype) and ast:typeIsPtr(rtype)
    if pexpr'opType == lex:MINUS
      if !sema:typeIsAssignable(rsv'ctx, cast<ptr ast:PNode>(pexpr), ltype, rtype)
        mut cs = base:csNew(20)

        base:csAppendStr(cs, "types ")
        ast:typeSummarize(cs, ltype)
        base:csAppendStr(cs, " and ")
        ast:typeSummarize(cs, rtype)
        base:csAppendStr(cs, " are not compatible")

        mut str = base:csUnleash(cs)

        base:listAppend(errors, utils:issueNew(utils:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, str))

        base:free(str)

        return null
      /if

      return ctx:contextMatchBuiltin(rsv'ctx, "intptr")
    else
      base:listAppend(errors, utils:issueNew(utils:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, "only difference between two pointers can be allowed"))
      return null
    /if
  /if

  # If we reached this point, then we have an int and a pointer.
  # Let's choose the pointer and then return the type of it.

  return ast:typeIsPtr(ltype) => ltype || rtype
/func


func validateArithExpr(rsv sema:Resolver,
                       pexpr ptr ast:PExpr,
                       ltype,rtype ptr ast:Type,
                       recList,errors ptr base:List) ptr ast:Type

  mut op = pexpr'opType

  if !(ast:typeIsInt(ltype) or ast:typeIsPtr(ltype)) or !(ast:typeIsPtr(rtype) or ast:typeIsInt(rtype))
    base:listAppend(errors, utils:issueNew(utils:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, "arithmetic operations can only involve pointers and integers"))

    return null
  /if

  if ast:typeIsPtr(ltype) or ast:typeIsPtr(rtype)
    return validateArithPtrExpr(rsv, pexpr, ltype, rtype, recList, errors)
  /if

  # In this case, we only have integers, so we just need to evaluate the larger
  # type or resolve to boolean in case of a major/minor comparison.

  return ttypeIsComparison(op) => ctx:contextMatchBuiltin(rsv'ctx, "bool") || (ltype'typeSize > rtype'typeSize => ltype || rtype)
/func


func validateEqDiffExpr(rsv sema:Resolver,
                        pexpr ptr ast:PExpr,
                        ltype,rtype ptr ast:Type,
                        errors ptr base:List) ptr ast:Type

  mut success = true

  if ltype'type != rtype'type
    # the only case in which we can accept a comparison between different types
    # is when we are comparing a pointer with null.
    if !((ast:typeIsNull(ltype) and ast:typeIsPtr(rtype)) or (ast:typeIsPtr(ltype) and ast:typeIsNull(rtype)))
      success = false
    /if
  else
    if !(ast:typeIsPtr(ltype) or ast:typeIsInt(ltype) or ast:typeIsBool(ltype))
      success = false
    /if
  /if

  if !success
    base:listAppend(errors, utils:issueNew(utils:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, "cannot evaluate the equivalence of two incompatible types"))
  /if

  return success => ctx:contextMatchBuiltin(rsv'ctx, "bool") || null
/func


func validateModuleAccessExpr(rsv sema:Resolver,
                              pexpr ptr ast:PExpr,
                              errors ptr base:List) ptr ast:Type

  mut modName = cast<ptr uint8>(cast<ptr ast:PNode>(val base:listGet(pexpr'node'leaves, 0))'value)
  if !ast:prootHasImported(rsv'root, modName)
    mut msg = base:strappend(modName, " has never been imported")
    base:listAppend(errors, utils:issueNew(utils:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, msg))
    base:free(msg)

    return null
  /if

  mut symName = cast<ptr uint8>(cast<ptr ast:PNode>(val base:listGet(pexpr'node'leaves, 1))'value)
  mut type = sema:findSymModule(rsv'ctx, modName, symName)

  if type == null
    mut cs = base:csNew(20)
    base:csAppendStr(cs, "'")
    base:csAppendStr(cs, symName)
    base:csAppendStr(cs, "' is not defined in module '")
    base:csAppendStr(cs, modName)
    base:csAppendStr(cs, "'")

    mut msg = base:csUnleash(cs)

    base:listAppend(errors, utils:issueNew(utils:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, msg))

    base:free(msg)

    return null
  /if

  return type
/func


func resolveRecType(rsv sema:Resolver,
                    type ptr ast:Type) ptr ast:Type

  if type'type != ast:TYPE_RECALIAS
    return type
  /if

  if type'moduleName != null
    return sema:findAliasImport(rsv'ctx, type'moduleName, type'name)
  /if

  return sema:findAliasLocal(cast<ptr ast:PNode>(rsv'root), type'name)
/func


func validateStructureAccessExpr(rsv sema:Resolver,
                                 pexpr ptr ast:PExpr,
                                 ltype ptr ast:Type,
                                 errors ptr base:List) ptr ast:Type

  mut accType = ltype

  if ltype'type == ast:TYPE_PTR
    accType = resolveRecType(rsv, ltype'retType)
  /if

  if !ast:typeIsStruct(accType)
    mut cs = base:csNew(20)
    base:csAppendStr(cs, "'")
    ast:typeSummarize(cs, accType)
    base:csAppendStr(cs, "' is neither a structure nor a pointer to a structure")

    mut msg = base:csUnleash(cs)

    base:listAppend(errors, utils:issueNew(utils:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, msg))

    base:free(msg)

    return null
  /if

  mut field = cast<ptr uint8>(cast<ptr ast:PNode>(val base:listGet(pexpr'node'leaves, 1))'value)

  mut type ptr ast:Type = null

  if !utils:kvGet(accType'members, field, ptr type)
    mut cs = base:csNew(20)
    base:csAppendStr(cs, "no field called '")
    base:csAppendStr(cs, field)
    base:csAppendStr(cs, "' in type ")
    ast:typeSummarize(cs, accType)

    mut msg = base:csUnleash(cs)

    base:listAppend(errors, utils:issueNew(utils:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, msg))

    base:free(msg)

    return null
  /if

  return type
/func


func validateArrayAccess(rsv sema:Resolver,
                         pexpr ptr ast:PExpr,
                         ltype,rtype ptr ast:Type,
                         errors ptr base:List) ptr ast:Type

  if ltype'type != ast:TYPE_PTR and !ast:typeIsLoc(ltype)
    base:listAppend(errors, utils:issueNew(utils:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, "array access is allowed only for pointers and locations"))
  /if

  if !ast:typeIsInt(rtype)
    base:listAppend(errors, utils:issueNew(utils:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, "an expression of integer type is required for array access"))
  /if

  # because of first-step bug with recursive types
  return cast<ptr ast:Type>(ltype'retType)
/func


func normalizeEmptyType(ctx ptr ctx:Context, type ptr ast:Type) ptr ast:Type
  return type != null => type || ctx:contextMatchBuiltin(ctx, "\0")
/func


func validateFunctionCallExpr(rsv sema:Resolver,
                              pexpr ptr ast:PExpr,
                              ltype ptr ast:Type,
                              recList,errors ptr base:List) ptr ast:Type

  mut accType = ltype

  if ltype'type == ast:TYPE_PTR
    accType = ltype'retType
  /if

  if !ast:typeIsFunc(accType)
    base:listAppend(errors, utils:issueNew(utils:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, "expression is neither a function nor a pointer to a function"))

    return null
  /if

  mut expParams = accType'members
  mut expLen = utils:kvLen(expParams)

  mut argsLen = base:listLen(pexpr'node'leaves)

  if argsLen != expLen + 1
    mut cs = base:csNew(20)
    base:csAppendStr(cs, "can't call function ")

    if ltype'name != null
      base:csAppendStr(cs, "'")

      if ltype'moduleName != null
        base:csAppendStr(cs, accType'moduleName)
        base:csAppendStr(cs, ":")
      /if

      base:csAppendStr(cs, accType'name)
      base:csAppendStr(cs, "' ")
    else
      ast:typeSummarize(cs, accType)
    /if

    base:csAppendStr(cs, ": expected ")
    base:csAppendInt(cs, expLen)
    base:csAppendStr(cs, " parameters, got ")
    base:csAppendInt(cs, argsLen - 1)

    mut msg = base:csUnleash(cs)

    base:listAppend(errors, utils:issueNew(utils:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, msg))

    base:free(msg)

    return null
  /if

  mut scope = cast<ptr ast:PNode>(pexpr)
  mut i uintptr = 0

  while i < expLen
    mut gotParam = cast<ptr ast:PExpr>(val base:listGet(scope'leaves, i + 1))
    mut expPair = utils:kvGetAt(expParams, i)

    mut expType = cast<ptr ast:Type>(expPair'value)

    mut gotType = sema:validateExprRecl(rsv, gotParam, recList, errors)
    if gotType == null
      return null
    /if

    if !sema:typeIsAssignable(rsv'ctx, scope, expType, gotType)
      mut cs = base:csNew(20)
      base:csAppendStr(cs, "passing '")

      ast:typeSummarize(cs, gotType)

      base:csAppendStr(cs, "' to parameter '")
      base:csAppendStr(cs, cast<ptr uint8>(expPair'key))
      base:csAppendStr(cs, "' of type '")

      ast:typeSummarize(cs, expType)

      base:csAppendStr(cs, "'")

      mut msg = base:csUnleash(cs)

      base:listAppend(errors, utils:issueNew(utils:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, msg))

      base:free(msg)

      return null
    /if

    i++
  /while

  return normalizeEmptyType(rsv'ctx, cast<ptr ast:Type>(accType'retType))
/func


func validateAssignExpr(rsv sema:Resolver,
                        pexpr,left ptr ast:PExpr,
                        ltype,rtype ptr ast:Type,
                        errors ptr base:List) ptr ast:Type

  if !ttypeCanBeAssignTarget(left'opType, ltype)
    base:listAppend(errors, utils:issueNew(utils:ISSUE_ERR, left'node'begin, rsv'root'fileName, "expression cannot be target of assignment"))
    return null
  /if

  if !sema:typeIsAssignable(rsv'ctx, cast<ptr ast:PNode>(pexpr), ltype, rtype)
    mut cs = base:csNew(20)

    base:csAppendStr(cs, "cannot assign expression of type '")
    ast:typeSummarize(cs, rtype)
    base:csAppendStr(cs, "' to a lvalue of type '")
    ast:typeSummarize(cs, ltype)
    base:csAppendStr(cs, "'")

    mut str = base:csUnleash(cs)

    base:listAppend(errors, utils:issueNew(utils:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, str))

    base:free(str)

    return null
  /if

  return ltype
/func


func validateBinaryExpr(rsv sema:Resolver,
                        pexpr ptr ast:PExpr,
                        recList,errors ptr base:List) ptr ast:Type

  mut op = pexpr'opType

  # handle apos, colon and call operators before because they are special
  # (i.e. no expressions or expressions only on lhs)

  if op == lex:COLON
    return validateModuleAccessExpr(rsv, pexpr, errors)
  /if

  mut left = cast<ptr ast:PExpr>(val base:listGet(pexpr'node'leaves, 0))
  mut ltype = sema:validateExprRecl(rsv, left, recList, errors)

  if ltype == null
    return null
  /if

  # structure field access
  if op == lex:APOS
    return validateStructureAccessExpr(rsv, pexpr, ltype,  errors)
  /if

  # function call
  if op == lex:OPAR
    return validateFunctionCallExpr(rsv, pexpr, ltype, recList, errors)
  /if

  mut right = cast<ptr ast:PExpr>(val base:listGet(pexpr'node'leaves, 1))
  mut rtype = sema:validateExprRecl(rsv, right, recList, errors)

  if rtype == null
    return null
  /if

  # array access
  if op == lex:OBRAC
    return validateArrayAccess(rsv, pexpr, ltype, rtype, errors)
  /if

  if ttypeIsBool(op)
    return validateBoolExpr(rsv, pexpr, ltype, rtype, recList, errors)
  /if

  if ttypeIsArith(op)
    return validateArithExpr(rsv, pexpr, ltype, rtype, recList, errors)
  /if

  if ttypeIsEqDiff(op)
    return validateEqDiffExpr(rsv, pexpr, ltype, rtype, errors)
  /if

  return validateAssignExpr(rsv, pexpr, left, ltype, rtype, errors)
/func


func validateNotExpr(rsv sema:Resolver,
                     pexpr ptr ast:PExpr,
                     atype ptr ast:Type,
                     errors ptr base:List) ptr ast:Type

  if !ast:typeIsBool(atype)
    base:listAppend(errors, utils:issueNew(utils:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, "expression must be boolean"))

    return null
  /if

  # always boolean
  return atype
/func


func validateValExpr(rsv sema:Resolver,
                     pexpr ptr ast:PExpr,
                     atype ptr ast:Type,
                     errors ptr base:List) ptr ast:Type

  if atype'type != ast:TYPE_PTR
    mut cs = base:csNew(20)
    base:csAppendStr(cs, "type '")
    ast:typeSummarize(cs, atype)
    base:csAppendStr(cs, "' is not dereferenceable")

    mut msg = base:csUnleash(cs)

    base:listAppend(errors, utils:issueNew(utils:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, msg))

    base:free(msg)

    return null
  /if

  return cast<ptr ast:Type>(atype'retType)
/func


func validatePtrExpr(rsv sema:Resolver,
                     pexpr ptr ast:PExpr,
                     atype ptr ast:Type,
                     errors ptr base:List) ptr ast:Type

  if ast:typeIsNull(atype)
    base:listAppend(errors, utils:issueNew(utils:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, "can't extract the address of null"))

    return null
  /if

  return ast:typeNewPtr(rsv'root'typePool, null, null, atype)
/func


func validateUMinusExpr(rsv sema:Resolver,
                        pexpr ptr ast:PExpr,
                        atype ptr ast:Type,
                        errors ptr base:List) ptr ast:Type

  if !ast:typeIsInt(atype)
    mut cs = base:csNew(20)
    base:csAppendStr(cs, "cannot apply unary '-' to type '")
    ast:typeSummarize(cs, atype)
    base:csAppendStr(cs, "'")

    mut msg = base:csUnleash(cs)

    base:listAppend(errors, utils:issueNew(utils:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, msg))

    base:free(msg)

    return null
  /if

  if !atype'isSigned
    mut cs = base:csNew(20)
    base:csAppendStr(cs, "cannot apply unary '-' to unsigned type '")
    ast:typeSummarize(cs, atype)
    base:csAppendStr(cs, "'")

    mut msg = base:csUnleash(cs)

    base:listAppend(errors, utils:issueNew(utils:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, msg))

    base:free(msg)

    return null
  /if

  return atype
/func


func validateIncDecExpr(rsv sema:Resolver,
                        pexpr,atarget ptr ast:PExpr,
                        atype ptr ast:Type,
                        errors ptr base:List) ptr ast:Type

  if !ast:typeIsInt(atype) and !ast:typeIsPtr(atype)
    mut cs = base:csNew(20)
    base:csAppendStr(cs, "type '")
    ast:typeSummarize(cs, atype)
    base:csAppendStr(cs, "' is not an integer or pointer type")

    mut msg = base:csUnleash(cs)

    base:listAppend(errors, utils:issueNew(utils:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, msg))

    base:free(msg)

    return null
  /if

  if !ttypeCanBeAssignTarget(atarget'opType, atype)
    base:listAppend(errors, utils:issueNew(utils:ISSUE_ERR, atarget'node'begin, rsv'root'fileName, "expression is not assignable"))

    return null
  /if

  return atype
/func


func validateUnaryExpr(rsv sema:Resolver,
                       pexpr ptr ast:PExpr,
                       recList, errors ptr base:List) ptr ast:Type

  mut op = pexpr'opType

  mut arg = cast<ptr ast:PExpr>(val base:listGet(pexpr'node'leaves, 0))
  mut atype = sema:validateExprRecl(rsv, arg, recList, errors)

  if op == lex:NOT
    return validateNotExpr(rsv, pexpr, atype, errors)
  /if

  if op == lex:VAL
    return validateValExpr(rsv, pexpr, atype, errors)
  /if

  if op == lex:PTR
    return validatePtrExpr(rsv, pexpr, atype, errors)
  /if

  if op == lex:UMINUS
    return validateUMinusExpr(rsv, pexpr, atype, errors)
  /if

  # if we've reached this point then it's '++' or '--'

  return validateIncDecExpr(rsv, pexpr, arg, atype, errors)
/func


func validateTernaryExpr(rsv sema:Resolver,
                         pexpr ptr ast:PExpr,
                         recList, errors ptr base:List) ptr ast:Type

  mut condition = cast<ptr ast:PExpr>(val base:listGet(pexpr'node'leaves, 0))
  mut condType = sema:validateExprRecl(rsv, condition, recList, errors)

  mut left = cast<ptr ast:PExpr>(val base:listGet(pexpr'node'leaves, 1))
  mut leftType = sema:validateExprRecl(rsv, left, recList, errors)

  mut right = cast<ptr ast:PExpr>(val base:listGet(pexpr'node'leaves, 1))
  mut rightType = sema:validateExprRecl(rsv, right, recList, errors)

  if condType == null or leftType == null or rightType == null
    return null
  /if

  if !ast:typeIsBool(condType)
    base:listAppend(errors, utils:issueNew(utils:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, "non boolean ternary condition"))

    return null
  /if

  # This is done on purpose, because "typeIsAssignable" is not commutative:
  # it evalutates that the second argument is assignable to the first, but in a
  # ternary operator the position of the two conditional choices is irrelevant
  # for sake of type determination, so we must run it twice with reversed
  # arguments
  if !sema:typeIsAssignable(rsv'ctx, cast<ptr ast:PNode>(pexpr), leftType, rightType) and !sema:typeIsAssignable(rsv'ctx, cast<ptr ast:PNode>(pexpr), rightType, leftType)
    mut cs = base:csNew(20)
    base:csAppendStr(cs, "ternary expression arguments have incompatible types '")
    ast:typeSummarize(cs, leftType)
    base:csAppendStr(cs, "' and '")
    ast:typeSummarize(cs, rightType)
    base:csAppendStr(cs, "'")

    mut msg = base:csUnleash(cs)

    base:listAppend(errors, utils:issueNew(utils:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, msg))

    base:free(msg)

    return null
  /if

  if ast:typeIsData(leftType) or ast:typeIsData(rightType)
    return ctx:contextMatchBuiltin(rsv'ctx, "data")
  /if

  if ast:typeIsNull(leftType)
    return rightType
  /if

  if ast:typeIsNull(rightType)
    return leftType
  /if

  if ast:typeIsInt(leftType)
    return intTypesFindLargestCompatible(rsv'ctx, leftType, rightType)
  /if

  # left and right type should pretty much the same now
  return leftType
/func


func validateExprRecl(rsv sema:Resolver,
                      pexpr ptr ast:PExpr,
                      recList,errors ptr base:List) ptr ast:Type


  if pexpr'node'validated
    return pexpr'type
  /if

  pexpr'type = null

  mut op = pexpr'opType
  if ttypeIsConst(op)
    return validateExprConst(rsv, pexpr)
  else
    if op == lex:ID
      pexpr'type = validateExprId(rsv, pexpr, recList, errors)
    else
      if op == lex:CAST
        pexpr'type = validateExprCast(rsv, pexpr, recList, errors)
      else
        if op == lex:SIZE
          pexpr'type = validateSizeExpr(rsv, pexpr, errors)
        else
          if ttypeIsTernary(op)
            pexpr'type = validateTernaryExpr(rsv, pexpr, recList, errors)
          else
            if ttypeIsBinary(op)
              pexpr'type = validateBinaryExpr(rsv, pexpr, recList, errors)
            else
              pexpr'type = validateUnaryExpr(rsv, pexpr, recList, errors)
            /if
          /if
        /if
      /if
    /if
  /if

  if pexpr'type != null
    pexpr'node'validated = true
  /if

  return pexpr'type
/func


func validateExpr(rsv sema:Resolver,
                  pexpr ptr ast:PExpr,
                  errors ptr base:List) ptr ast:Type

  return validateExprRecl(rsv, pexpr, null, errors)
/func
