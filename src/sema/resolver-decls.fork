#  libfork, a base library for the Fork language
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2015
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the
#  licenses expressed under Section 1.12 of the MPL v2.


import ast
import kv
import list
import mem
import parser
import sema
import txt
import utils


func findRecAlias(ctx ptr parser:Context, scope ptr ast:PNode, ralias ptr ast:Type) ptr ast:Type
  if ralias'type != ast:TYPE_RECALIAS
    return ralias
  /if

  return ralias'moduleName != null => sema:findAliasImport(ctx, ralias'moduleName, ralias'name) || sema:findAliasLocal(scope, ralias'name)
/func


func findSymModule(ctx ptr parser:Context, moduleName, name ptr uint8) ptr ast:Type
  mut imp = parser:ctxGetImport(ctx, moduleName)
  if imp == null
    return null
  /if

  return ast:stabTypeof(imp'node'syms, name)
/func


func rootDeclsRegister(rsv sema:Resolver, name ptr uint8, type ptr ast:Type, declType uint16)
  ast:stabAdd(rsv'root'node'syms, name, type, declType)

  mut pdecl ptr ast:PDecl

  kv:kvGet(rsv'decls, name, ptr pdecl)

  kv:kvRemove(rsv'decls, name)
/func


# Idea: if we're in a recursive invocation from an expression,
# we only need its type (if possible).
# Otherwise, if inherited from an expression, we must validate it to extract the
# actual type.
func registerDeclReal(rsv sema:Resolver,
                      pdecl ptr ast:PDecl,
                      recursive bool,
                      recList,errors ptr list:List) ptr ast:Type

  mut name = pdecl'sym'name
  mut ptype = pdecl'sym'type

  mut isDecl = pdecl'node'type == ast:PDECL
  mut isEntry = pdecl'node'type == ast:PENTRY
  mut isFunc = pdecl'node'type == ast:PFUNCTION or isEntry


  mut realType ptr ast:Type = ast:findSym(cast<ptr ast:PNode>(pdecl), name)
  mut typeResolved = realType != null
  mut inMap = typeResolved

  # check: if this symbol is present, than it's because it has already been
  # type-resolved (we ensured univocity of declarations while collecting decls)
  # and maybe not validated yet. Return type if validated.
  if typeResolved and pdecl'node'validated
    return realType
  /if

  if ptype != null and !typeResolved
    typeResolved = (realType = sema:resolveType(rsv, ptype, errors)) != null

    if !typeResolved
      return null
    /if
  /if

  # if we are just resolving a type, we shall stop, return the type and
  # validate the rest only when needed.

  if !pdecl'node'validated

    if isFunc

      # register function BEFORE because it can be recursive
      # realType will always be non-null
      if !inMap and !isEntry
        rootDeclsRegister(rsv, name, realType, pdecl'node'type)
        inMap = true
      /if

      if !recursive
        if !sema:validateFunc(rsv, pdecl, realType, errors)
          return null
        /if

        pdecl'node'validated = true
      /if

    else

      mut hasLeaves = list:listLen(pdecl'node'leaves) > 0

      if !hasLeaves and !typeResolved
        list:listAppend(errors, parser:issueNew(parser:ISSUE_ERR, ptype'begin, rsv'root'fileName, "declaration with neither a type nor an initializer"))

        return null
      /if

      if hasLeaves
        if isDecl
          # because we're sure that ptype was null and there's a leaf, then
          # we have a malformed 'decl'
          list:listAppend(errors, parser:issueNew(parser:ISSUE_ERR, ptype'begin, rsv'root'fileName, "decls can't have initializers"))

          return null
        /if

        mut pexpr = cast<ptr ast:PExpr>(val list:listGet(pdecl'node'leaves, 0))

        # if we're are validating the declaration directly and not because of
        # recursive resolution, or if we still have no type, resolve the
        # expression associated with this mut (we are also sure we have a mut)
        if !recursive
          mut valType = sema:validateExprRecl(rsv, pexpr, recList, errors)
          if valType == null
            return null
          /if

          if typeResolved
            if !sema:typeIsAssignable(rsv'ctx, cast<ptr ast:PNode>(pdecl), realType, valType)
              mut cs = txt:csNew(20)
              txt:csAppendStr(cs, "cannot assign an expression of type '")
              ast:typeSummarize(cs, valType)
              txt:csAppendStr(cs, "' to a variable declared as '")
              ast:typeSummarize(cs, realType)
              txt:csAppendStr(cs, "'")

              mut msg = txt:csUnwrap(cs)

              list:listAppend(errors, parser:issueNew(parser:ISSUE_ERR, ptype'begin, rsv'root'fileName, msg))

              mem:free(msg)

              return null
            /if
          else
            if ast:typeIsNull(valType)
              list:listAppend(errors, parser:issueNew(parser:ISSUE_ERR, ptype'begin, rsv'root'fileName, "can't declare a variable with type 'null'"))
              return null
            /if

            realType = valType
          /if
        /if
      /if

      pdecl'node'validated = true
    /if

  /if

  # functions are already registered
  if !inMap and realType != null and pdecl'node'type != ast:PENTRY
    rootDeclsRegister(rsv, name, realType, pdecl'node'type)
  /if

  if isEntry
    rsv'root'entryNode = pdecl
  /if

  return realType
/func


func registerTopDeclReal(rsv sema:Resolver,
                         pdecl ptr ast:PDecl,
                         recList,errors ptr list:List) ptr ast:Type

  list:listPush(recList, cast<ptr uint8>(pdecl'sym'name))

  mut ret = registerDeclReal(rsv, pdecl, false, recList, errors)

  list:listPop(recList)

  return ret
/func


func registerTopDecl(rsv sema:Resolver,
                     pdecl ptr ast:PDecl,
                     errors ptr list:List) ptr ast:Type

  mut recList list:List
  list:listInit(ptr recList)

  mut ret = registerTopDeclReal(rsv, pdecl, ptr recList, errors)

  list:listDeinit(ptr recList)

  return ret
/func

func resolveDeclType(rsv sema:Resolver,
                     name ptr uint8,
                     node ptr ast:PNode,
                     recList,errors ptr list:List) ptr ast:Type

  mut dtype = ast:findSym(node, name)

  if dtype != null
    return dtype
  /if

  # in this case we should look if there is a global declaration value left with
  # this name

  mut whichDecl ptr ast:PDecl

  if kv:kvGet(rsv'decls, name, ptr whichDecl)
    return registerDeclReal(rsv, whichDecl, false, recList, errors)
  /if

  # The declaration is absent

  mut msg = txt:strappend(name, " is not defined in current scope")
  list:listAppend(errors, parser:issueNew(parser:ISSUE_ERR, node'begin, rsv'root'fileName, msg))

  mem:free(msg)

  return null
/func


func registerDecl(rsv sema:Resolver,
                  pdecl ptr ast:PDecl,
                  name ptr uint8,
                  type ptr ast:Type,
                  declType uint16,
                  errors ptr list:List) ptr ast:Type

  mut declNode = cast<ptr ast:PNode>(pdecl)

  mut stab = ast:findStab(declNode)
  if ast:stabTypeof(stab, name) != null
    mut cs = txt:csNew(20)
    txt:csAppendStr(cs, "symbol '")
    txt:csAppendStr(cs, name)
    txt:csAppendStr(cs, "' is already defined")

    mut msg = txt:csUnwrap(cs)

    list:listAppend(errors, parser:issueNew(parser:ISSUE_ERR, declNode'begin, rsv'root'fileName, msg))

    mem:free(msg)

    return null
  /if

  ast:stabAdd(stab, name, type, declType)

  return type
/func
