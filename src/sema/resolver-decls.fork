#  libfork, a base library for the Fork language
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2015
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the
#  licenses expressed under Section 1.12 of the MPL v2.


module sema


import ast
import cs
import hash
import kv
import list
import mem
import parser
import sema
import txt
import utils


func findRecAlias(ctx ptr parser:Parser, scope ptr ast:PNode, ralias ptr ast:Type) ptr ast:Type
  if ralias'type != ast:TYPE_RECALIAS
    return ralias
  /if

  return ralias'moduleName? => sema:findAliasImport(ctx, ralias'moduleName, ralias'name) || sema:findAliasLocal(scope, ralias'name)
/func


func findSymModule(ctx ptr parser:Parser, moduleName, name ptr uint8) ptr ast:Type
  mut imp = ctx.getImport(moduleName)
  if not imp?
    return null
  /if

  return ast:stabTypeof(imp'node'syms, name)
/func


# 'module:Type.method' can be defined 1. in current module 2. in the type's
# module, with this precedence order.
# Otherwise, it's pretty complicated to handle conflicts, and, most important,
# you don't really know who calls what.
func findMethod(rsv sema:Resolver,
                node ptr ast:PNode,
                typeModule,typeName,methodName ptr uint8) ptr ast:Type

  mut name = ast:methodKey(typeModule, typeName,methodName)

  mut ret = ast:findSym(node, name)
  if ret?
    mem:free(name)
    return ret
  /if

  mut root = ast:findPRoot(node)

  # fetch this from the current ford.
  if root'moduleName?
    ret = sema:findSymModule(rsv'ctx, root'moduleName'name, name)
    if ret?
      mem:free(name)
      return ret
    /if
  /if

  # otherwise, lookup in the type's module.

  ret = sema:findSymModule(rsv'ctx, typeModule, name)
  mem:free(name)

  return ret
/func


func rootDeclsRegister(rsv sema:Resolver, name ptr uint8, isDecl bool, type ptr ast:Type, declType uint16)
  ast:stabAdd(rsv'root'node'syms, name, isDecl, type, declType)

  rsv'decls.remove(name)
/func


# Idea: if we're in a recursive invocation from an expression,
# we only need its type (if possible).
# Otherwise, if inherited from an expression, we must validate it to extract the
# actual type.
func registerDeclReal(rsv sema:Resolver,
                      pdecl ptr ast:PDecl,
                      recursive bool,
                      recList,errors ptr list:List) ptr ast:Type

  mut name = ast:declKey(pdecl)
  mut ptype = pdecl'sym'type

  mut isDecl = pdecl'isDecl
  mut isEntry = pdecl'node'type == ast:PENTRY
  mut isMethod = pdecl'node'type == ast:PMETHOD
  mut isFunc = pdecl'node'type == ast:PFUNCTION or isEntry or isMethod


  mut realType ptr ast:Type = ast:findSym(<ptr ast:PNode>(pdecl), name)
  mut typeResolved = realType?
  mut inMap = typeResolved

  # check: if this symbol is present, it's because it has already been
  # type-resolved (we ensured univocity of declarations while collecting decls)
  # and maybe not validated yet. Return type if validated.
  if typeResolved and pdecl'node'validated
    return realType
  /if

  if ptype? and not typeResolved
    typeResolved = (realType = sema:resolveType(rsv, ptype, errors))?

    if not typeResolved
      return null
    /if
  /if

  # if we are just resolving a type, we shall stop, return the type and
  # validate the rest only when needed.

  if not pdecl'node'validated

    if isFunc and not isDecl

      # register function BEFORE because it can be recursive
      # realType will always be non-null
      if not inMap and not isEntry
        rootDeclsRegister(rsv, name, pdecl'isDecl, realType, pdecl'node'type)
        inMap = true
      /if

      if not recursive
        if not sema:validateFunc(rsv, pdecl, realType, errors)
          return null
        /if

        pdecl'node'validated = true
      /if

    else

      if pdecl'node'leaves.len() > 0

        mut pexpr = <ptr ast:PExpr>(val pdecl'node'leaves.get(0))

        if not sema:exprIsCompileConst(pexpr)
          mut msg = "expression is not a compile time constant"

          errors.append(parser:issueNew(parser:ISSUE_ERR, pexpr'node'begin, \
                                          rsv'root'fileName, msg))
        /if

        # if we're are validating the declaration directly and not because of
        # recursive resolution, or if we still have no type, resolve the
        # expression associated with this mut (we are also sure we have a mut)
        if not recursive
          mut valType = sema:validateExprRecl(rsv, pexpr, recList, errors)
          if not valType?
            return null
          /if

          if typeResolved
            if not sema:typeIsAssignable(rsv'ctx, <ptr ast:PNode>(pdecl), realType, valType)
              mut cs = cs:new(20)
              cs.add("cannot assign an expression of type '")
              valType.summarize(cs)
              cs.add("' to a variable declared as '")
              realType.summarize(cs)
              cs.add("'")

              mut msg = cs:unwrap(cs)

              errors.append(parser:issueNew(parser:ISSUE_ERR, ptype'begin, rsv'root'fileName, msg))

              mem:free(msg)

              return null
            /if
          else
            if valType.isNull()
              errors.append(parser:issueNew(parser:ISSUE_ERR, ptype'begin, rsv'root'fileName, "can't declare a variable with type 'null'"))
              return null
            /if

            realType = valType
          /if
        /if
      /if

      pdecl'node'validated = true
    /if

  /if

  # functions are already registered
  if not inMap and realType? and pdecl'node'type != ast:PENTRY
    rootDeclsRegister(rsv, name, pdecl'isDecl, realType, pdecl'node'type)
  /if

  if isEntry
    rsv'root'entryNode = pdecl
  /if

  return realType
/func


func registerTopDeclReal(rsv sema:Resolver,
                         pdecl ptr ast:PDecl,
                         recList,errors ptr list:List) ptr ast:Type

  recList.push(ast:declKey(pdecl))

  mut ret = registerDeclReal(rsv, pdecl, false, recList, errors)

  mem:free(recList.pop())

  return ret
/func


func registerTopDecl(rsv sema:Resolver,
                     pdecl ptr ast:PDecl,
                     errors ptr list:List) ptr ast:Type

  mut recList list:List
  list:init(ptr recList)

  mut ret = registerTopDeclReal(rsv, pdecl, ptr recList, errors)

  list:deinit(ptr recList)

  return ret
/func


func resolveDeclType(rsv sema:Resolver,
                     name ptr uint8,
                     node ptr ast:PNode,
                     recList,errors ptr list:List) ptr ast:Type

  mut dtype = ast:findSym(node, name)

  if dtype?
    return dtype
  /if

  # in this case we should look if there is a global declaration value left with
  # this name

  mut whichDecl = <ptr ast:PDecl>(rsv'decls.get(name))

  if whichDecl?
    return registerDeclReal(rsv, whichDecl, false, recList, errors)
  /if

  # The declaration is absent

  mut msg = txt:strappend(name, " is not defined in current scope")
  errors.append(parser:issueNew(parser:ISSUE_ERR, node'begin, rsv'root'fileName, msg))

  mem:free(msg)

  return null
/func


func registerDecl(rsv sema:Resolver,
                  pdecl ptr ast:PDecl,
                  name ptr uint8,
                  type ptr ast:Type,
                  declType uint16,
                  errors ptr list:List) ptr ast:Type

  mut declNode = <ptr ast:PNode>(pdecl)

  mut stab = ast:findStab(declNode)
  if ast:stabTypeof(stab, name)?
    mut cs = cs:new(20)
    cs.add("symbol '")
    cs.add(name)
    cs.add("' is already defined")

    mut msg = cs:unwrap(cs)

    errors.append(parser:issueNew(parser:ISSUE_ERR, declNode'begin, rsv'root'fileName, msg))

    mem:free(msg)

    return null
  /if

  ast:stabAdd(stab, name, pdecl'isDecl, type, declType)

  return type
/func
