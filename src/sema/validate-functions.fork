#  libfork, a base library for the Fork language
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2015
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the
#  licenses expressed under Section 1.12 of the MPL v2.


module sema


import ast
import astfn
import cs
import kv
import list
import mem
import parser
import proc
import sema
import tty
import txt
import utils


method ast:Symtable.addFuncParams(syms ptr kv:KVList)
  mut len = syms.len()
  mut i uintptr = 0

  while i < len
    mut pair = syms.getAt(i)

    mut name = <ptr uint8>(pair'key)
    mut type = <ptr ast:Type>(pair'value)

    me.add(name, true, true, type, 0) #0 ignored

    i++
  /while
/method


func ensureMethodCorrectness(rsv sema:Resolver,
                             pdecl ptr ast:PDecl,
                             funcType ptr ast:Type,
                             errors ptr list:List) bool

  mut type ptr ast:Type = null

  # the method's type is either defined in the given module, or not defined at all.
  if pdecl'methodTypeModule?
    type = sema:findAliasImport(rsv'ctx, pdecl'methodTypeModule, pdecl'methodType)

    # if it's not present, then it may be possibile that it belongs to the current scope
    # if this file is in the same module of this type.
    if not type?
      if rsv'root'moduleName? and txt:strequals(rsv'root'moduleName'name, pdecl'methodTypeModule)
        type = sema:findAliasLocal(<ptr ast:PNode>(pdecl), pdecl'methodType)
      /if
    /if

    if not type?
      mut cs = cs:new(20)

      cs.add("type ")

      if pdecl'methodTypeModule?
        cs.add(pdecl'methodTypeModule)
        cs.add(":")
      /if

      cs.add(pdecl'methodType)
      cs.add(" is undefined")

      mut msg = cs:unwrap(cs)

      errors.append(parser:issueNew(parser:ISSUE_ERR, pdecl'node'begin, rsv'root'fileName, msg))

      mem:free(msg)
    /if
  else
    type = sema:resolveTypeName(rsv, pdecl'methodType, errors)
  /if

  if not type?
    return false
  /if

  mut pblock = <ptr ast:PBlock>(val pdecl'node'leaves.get(0))
  mut meType = astfn:typeNewPtr(rsv'root'typePool, null, null, type)

  pblock'syms.add("me", true, false, meType, 0)

  return true
/func


func validateBreakContinue(rsv sema:Resolver,
                           stmt ptr ast:PNode,
                           inLoop bool,
                           errors ptr list:List) bool

  if not inLoop
    errors.append(parser:issueNew(parser:ISSUE_ERR, stmt'begin, rsv'root'fileName, "break or continue outside of a loop"))

    return false
  /if

  return true
/func


func validateDecl(rsv sema:Resolver,
                  pdecl ptr ast:PDecl,
                  errors ptr list:List) bool

  mut isDecl = pdecl'isDecl

  mut type ptr ast:Type = null

  if pdecl'sym'type?
    type = sema:resolveType(rsv, pdecl'sym'type, errors)
    if not type?
      return false
    /if
  else
    if isDecl
      errors.append(parser:issueNew(parser:ISSUE_ERR, pdecl'node'begin, rsv'root'fileName, "a decl must have a type"))

      return false
    /if
  /if

  mut leavLen = pdecl'node'leaves.len()

  if leavLen > 0
    mut pexpr = <ptr ast:PExpr>(val pdecl'node'leaves.get(0))
    if isDecl
      errors.append(parser:issueNew(parser:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, "a decl can't have an assignment"))
    /if

    mut exprType = sema:validateExpr(rsv, pexpr, errors)
    if not exprType?
      return false
    /if

    if exprType.isEmpty()
      errors.append(parser:issueNew(parser:ISSUE_ERR, pexpr'node'begin, \
                      rsv'root'fileName, "expression has no type"))
      return false
    /if

    if type?
      if not sema:typeIsAssignable(rsv'ctx, <ptr ast:PNode>(pdecl), type, exprType)
        mut cs = cs:new(20)
        cs.add("cannot assign an expression of type '")
        exprType.summarize(cs)
        cs.add("' to a variable declared as '")
        type.summarize(cs)
        cs.add("'")

        mut msg = cs:unwrap(cs)

        errors.append(parser:issueNew(parser:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, msg))

        mem:free(msg)

        return false
      /if
    else
      if exprType.isNull()
        errors.append(parser:issueNew(parser:ISSUE_ERR, pexpr'node'begin, \
                                  rsv'root'fileName, \
                                  "can't declare a variable with type 'null'"))
        return false
      /if

      type = exprType
    /if
  /if

  if not type?
    errors.append(parser:issueNew(parser:ISSUE_ERR, \
                    pdecl'node'begin, rsv'root'fileName, \
                    "declaration without an explicit or inferrable type"))

    return false
  /if

  return sema:registerDecl(rsv, pdecl, pdecl'sym'name, type, pdecl'node'type, errors)?
/func


func validateMulDecl(rsv sema:Resolver,
                     pmuldecl ptr ast:PMulDecl,
                     errors ptr list:List) bool

  mut pnode = <ptr ast:PNode>(pmuldecl)
  mut exprType ptr ast:Type = null
  mut leavLen = pnode'leaves.len()
  mut len = pmuldecl'syms.len()

  if leavLen > 0
    mut pexpr = <ptr ast:PExpr>(val pnode'leaves.get(0))

    exprType = sema:validateExpr(rsv, pexpr, errors)
    if not exprType?
      return false
    /if

    if not exprType.isStruct()
      mut cs = cs:new(30)
      cs.add("trying to expand non-struct type '")
      exprType.summarize(cs)
      cs.add("'")

      mut msg = cs:unwrap(cs)

      errors.append(parser:issueNew(parser:ISSUE_ERR, pexpr'node'begin, \
                        rsv'root'fileName, msg))
      mem:free(msg)

      return false
    /if

    if exprType'members.len() != len
      mut msg = "trying to expand a struct with a wrong number of variables (use '_' if you don't need one of the fields)"
      errors.append(parser:issueNew(parser:ISSUE_ERR, pexpr'node'begin, \
                        rsv'root'fileName, msg))

      return false
    /if
  /if

  mut i uintptr = 0
  mut stab = pnode.findStab()
  mut newVars = false

  while i < len
    mut sym = <ptr ast:PSymbol>(val pmuldecl'syms.get(i))

    # if _, skip
    if txt:strequals(sym'name, "_")
      i++
      continue
    /if

    mut exists = pnode.findSym(sym'name)

    # Init varType with the (eventual) existing type of the variable (it's null
    # if it doesn't exist)

    mut varType = exists

    mut initType = exprType? => <ptr ast:Type>(exprType'members.getAt(i)'value) || null

    # If we have a sym'type, then exists? will make this function fail;
    # we're safe to assume then that the variable exists and sym'type can't be
    # both non-null at the same time.
    if sym'type?
      if exists?
        mut msg = txt:strappend(sym'name, " has been redeclared")

        errors.append(parser:issueNew(parser:ISSUE_ERR, pnode'begin, rsv'root'fileName, msg))

        mem:free(msg)

        return false
      /if

      varType = sema:resolveType(rsv, sym'type, errors)

      if not varType?
        return false
      /if
    /if

    # Now, we're check if the variable type is compatible with the expression.
    # This can be true only in two cases:
    # 1. the variable does not exist, but there is a type specifier and an expr;
    # 2. the variable exists, there is no type specifier, but there's an expr.

    if varType? and initType?
      if not sema:typeIsAssignable(rsv'ctx, pnode, varType, initType)
        mut cs = cs:new(20)
        cs.add("cannot assign an expression of type '")
        initType.summarize(cs)
        cs.add("' to '")
        cs.add(sym'name)
        cs.add("' declared as '")
        varType.summarize(cs)
        cs.add("'")

        mut msg = cs:unwrap(cs)

        errors.append(parser:issueNew(parser:ISSUE_ERR, pnode'begin, rsv'root'fileName, msg))

        mem:free(msg)

        return false
      /if
    /if

    # The following block creates the variable, if not existent.
    if not exists?
      # type inference: if there is no varType, then use the expression's type.
      # we're pretty safe, because synt won't allow the existence of a mulmut
      # expr with neither full types nor an initialization expression, so they
      # will never be both null.
      varType = varType ?? initType

      # Each variable in a MutExp is still a mut. So they're added as muts.
      stab.add(sym'name, false, false, varType, ast:PMUT)
      newVars = true
    /if

    i++
  /while

  if not newVars
    mut msg = "no new variables in mut statement"
    errors.append(parser:issueNew(parser:ISSUE_ERR, pnode'begin, rsv'root'fileName, msg))

    return false
  /if

  return true
/func


func validateIf(rsv sema:Resolver,
                stmt ptr ast:PNode,
                funcInfo ast:Symbol,
                inLoop bool,
                errors ptr list:List) bool

  mut cond = <ptr ast:PExpr>(val stmt'leaves.get(0))

  mut condType = sema:validateExpr(rsv, cond, errors)
  if not condType?
    return false
  /if

  if not condType.isBool()
    mut cs = cs:new(20)
    cs.add("expected a boolean expression, got type '")
    condType.summarize(cs)
    cs.add("' instead")

    mut msg = cs:unwrap(cs)

    errors.append(parser:issueNew(parser:ISSUE_ERR, cond'node'begin, rsv'root'fileName, msg))

    mem:free(msg)

    return false
  /if

  mut firstBlock = <ptr ast:PBlock>(val stmt'leaves.get(1))
  if not validatePBlock(rsv, firstBlock, funcInfo, inLoop, errors)
    return false
  /if

  if stmt'type == ast:PIFELSE
    mut elseBlock = <ptr ast:PBlock>(val stmt'leaves.get(2))
    if not validatePBlock(rsv, elseBlock, funcInfo, inLoop, errors)
      return false
    /if
  /if

  return true
/func


func validatePBlock(rsv sema:Resolver,
                    pblock ptr ast:PBlock,
                    funcInfo ast:Symbol,
                    inLoop bool,
                    errors ptr list:List) bool

  if not pblock'syms?
    pblock'syms = ast:stabNew()
  /if

  mut len = pblock'node'leaves.len()
  mut i uintptr = 0

  while i < len
    mut stmt = <ptr ast:PNode>(val pblock'node'leaves.get(i))

    if not validateStmt(rsv, stmt, funcInfo, inLoop, errors)
      return false
    /if

    i++
  /while

  return true
/func


func validateReturn(rsv sema:Resolver,
                    stmt ptr ast:PNode,
                    funcInfo ast:Symbol,
                    errors ptr list:List) bool

  mut hasRetExpr = (stmt'leaves.len() == 1)
  mut funcRetTypeEmpty = not funcInfo'type'retType? or funcInfo'type'retType'type == ast:TYPE_EMPTY

  if not hasRetExpr and not funcRetTypeEmpty
    mut cs = cs:new(20)
    cs.add("function '")
    cs.add(funcInfo'name)
    cs.add("' has a return value, but no expression is given to return")

    mut msg = cs:unwrap(cs)

    errors.append(parser:issueNew(parser:ISSUE_ERR, stmt'begin, rsv'root'fileName, msg))

    mem:free(msg)

    return false
  /if

  if hasRetExpr and funcRetTypeEmpty
    mut cs = cs:new(20)
    cs.add("function '")
    cs.add(funcInfo'name)
    cs.add("' has no return value, but an expression is given to return")

    mut msg = cs:unwrap(cs)

    errors.append(parser:issueNew(parser:ISSUE_ERR, stmt'begin, rsv'root'fileName, msg))

    mem:free(msg)

    return false
  /if

  if hasRetExpr
    mut retType = funcInfo'type'retType
    mut retExpr = <ptr ast:PExpr>(val stmt'leaves.get(0))

    mut exprType = sema:validateExpr(rsv, retExpr, errors)
    if not exprType?
      return false
    /if

    if not sema:typeIsAssignable(rsv'ctx, stmt, retType, exprType)
      mut cs = cs:new(20)
      cs.add("cannot return type '")
      exprType.summarize(cs)
      cs.add("' from function ")
      cs.add(funcInfo'name)
      cs.add("(), returning '")
      retType.summarize(cs)
      cs.add("'")

      mut msg = cs:unwrap(cs)

      errors.append(parser:issueNew(parser:ISSUE_ERR, stmt'begin, rsv'root'fileName, msg))

      mem:free(msg)

      return false
    /if
  /if

  return true
/func


func validateStmt(rsv sema:Resolver,
                  stmt ptr ast:PNode,
                  funcInfo ast:Symbol,
                  inLoop bool,
                  errors ptr list:List) bool

  if stmt.isBreakContinue()
    return validateBreakContinue(rsv, stmt, inLoop, errors)
  /if

  if stmt.isDecl()
    return validateDecl(rsv, <ptr ast:PDecl>(stmt), errors)
  /if

  if stmt.isExpr()
    return sema:validateExpr(rsv, <ptr ast:PExpr>(stmt), errors)?
  /if

  if stmt.isIf()
    return validateIf(rsv, stmt, funcInfo, inLoop, errors)
  /if

  if stmt.isMulDecl()
    return validateMulDecl(rsv, <ptr ast:PMulDecl>(stmt), errors)
  /if

  if stmt.isReturn()
    return validateReturn(rsv, stmt, funcInfo, errors)
  /if

  if stmt.isWhile()
    return validateWhile(rsv, stmt, funcInfo, inLoop, errors)
  /if

  # unreachable
  tty:errln("unknown statement type")
  proc:abort()
  return false
/func


func validateWhile(rsv sema:Resolver,
                   stmt ptr ast:PNode,
                   funcInfo ast:Symbol,
                   inLoop bool,
                   errors ptr list:List) bool

  mut cond = <ptr ast:PExpr>(val stmt'leaves.get(0))

  mut condType = sema:validateExpr(rsv, cond, errors)
  if not condType?
    return false
  /if

  if not condType.isBool()
    mut cs = cs:new(20)
    cs.add("expected a boolean expression, got type '")
    condType.summarize(cs)
    cs.add("' instead")

    mut msg = cs:unwrap(cs)

    errors.append(parser:issueNew(parser:ISSUE_ERR, cond'node'begin, rsv'root'fileName, msg))

    mem:free(msg)

    return false
  /if

  mut pblock = <ptr ast:PBlock>(val stmt'leaves.get(1))

  return validatePBlock(rsv, pblock, funcInfo, true, errors)
/func


func validateFunc(rsv sema:Resolver,
                  pdecl ptr ast:PDecl,
                  funcType ptr ast:Type,
                  errors ptr list:List) bool

  mut sym ast:Symbol

  sym'type = funcType
  sym'name = pdecl'sym'name

  mut pblock = <ptr ast:PBlock>(val pdecl'node'leaves.get(0))

  pblock'syms = ast:stabNew()

  pblock'syms.addFuncParams(funcType'members)

  if pdecl'node'type == ast:PMETHOD
    if not ensureMethodCorrectness(rsv, pdecl, funcType, errors)
      return false
    /if
  /if

  return validatePBlock(rsv, pblock, sym, false, errors)
/func
