#  libfork, a base library for the Fork language
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2015
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the
#  licenses expressed under Section 1.12 of the MPL v2.


module sema


import ast
import astfn
import kv
import list
import mem
import parser
import proc
import sema
import tty
import txt
import utils


func addAllSymbolsToStab(stab ptr ast:Symtable, syms ptr kv:KVList)
  mut len = kv:kvLen(syms)
  mut i uintptr = 0

  while i < len
    mut pair = kv:kvGetAt(syms, i)

    mut name = cast<ptr uint8>(pair'key)
    mut type = cast<ptr ast:Type>(pair'value)

    ast:stabAdd(stab, name, true, type, 0) #0 ignored

    i++
  /while
/func


func ensureMethodCorrectness(rsv sema:Resolver,
                             pdecl ptr ast:PDecl,
                             funcType ptr ast:Type,
                             errors ptr list:List) bool

  mut type ptr ast:Type = null

  # the method's type is either defined in the given module, or not defined at all.
  if pdecl'methodTypeModule != null
    type = sema:findAliasImport(rsv'ctx, pdecl'methodTypeModule, pdecl'methodType)

    # if it's not present, then it may be possibile that it belongs to the current scope
    # if this file is in the same module of this type.
    if type == null
      if rsv'root'moduleName != null and txt:strequals(rsv'root'moduleName'name, pdecl'methodTypeModule)
        type = sema:findAliasLocal(cast<ptr ast:PNode>(pdecl), pdecl'methodType)
      /if
    /if

    if type == null
      mut cs = txt:csNew(20)

      txt:csAppendStr(cs, "type ")

      if pdecl'methodTypeModule != null
        txt:csAppendStr(cs, pdecl'methodTypeModule)
        txt:csAppendStr(cs, ":")
      /if

      txt:csAppendStr(cs, pdecl'methodType)
      txt:csAppendStr(cs, " is undefined")

      mut msg = txt:csUnwrap(cs)

      errors.append(parser:issueNew(parser:ISSUE_ERR, pdecl'node'begin, rsv'root'fileName, msg))

      mem:free(msg)
    /if
  else
    type = sema:resolveTypeName(rsv, pdecl'methodType, errors)
  /if

  if type == null
    return false
  /if

  mut pblock = cast<ptr ast:PBlock>(val pdecl'node'leaves.get(0))
  mut meType = astfn:typeNewPtr(rsv'root'typePool, null, null, type)

  ast:stabAdd(pblock'syms, "me", true, meType, 0)

  return true
/func


func validateBreakContinue(rsv sema:Resolver,
                           stmt ptr ast:PNode,
                           inLoop bool,
                           errors ptr list:List) bool

  if not inLoop
    errors.append(parser:issueNew(parser:ISSUE_ERR, stmt'begin, rsv'root'fileName, "break or continue outside of a loop"))

    return false
  /if

  return true
/func


func validateDecl(rsv sema:Resolver,
                  pdecl ptr ast:PDecl,
                  errors ptr list:List) bool

  mut isDecl = pdecl'isDecl

  mut type ptr ast:Type = null

  if pdecl'sym'type != null
    type = sema:resolveType(rsv, pdecl'sym'type, errors)
    if type == null
      return false
    /if
  else
    if isDecl
      errors.append(parser:issueNew(parser:ISSUE_ERR, pdecl'node'begin, rsv'root'fileName, "a decl must have a type"))

      return false
    /if
  /if

  mut leavLen = pdecl'node'leaves.len()

  if leavLen > 0
    mut pexpr = cast<ptr ast:PExpr>(val pdecl'node'leaves.get(0))
    if isDecl
      errors.append(parser:issueNew(parser:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, "a decl can't have an assignment"))
    /if

    mut exprType = sema:validateExpr(rsv, pexpr, errors)
    if exprType == null
      return false
    /if

    if type != null
      if not sema:typeIsAssignable(rsv'ctx, cast<ptr ast:PNode>(pdecl), type, exprType)
        mut cs = txt:csNew(20)
        txt:csAppendStr(cs, "cannot assign an expression of type '")
        ast:typeSummarize(cs, exprType)
        txt:csAppendStr(cs, "' to a variable declared as '")
        ast:typeSummarize(cs, type)
        txt:csAppendStr(cs, "'")

        mut msg = txt:csUnwrap(cs)

        errors.append(parser:issueNew(parser:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, msg))

        mem:free(msg)

        return false
      /if
    else
      if ast:typeIsNull(exprType)
        errors.append(parser:issueNew(parser:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, "can't declare a variable with type 'null'"))
        return false
      /if

      type = exprType
    /if
  /if

  if type == null
    errors.append(parser:issueNew(parser:ISSUE_ERR, pdecl'node'begin, rsv'root'fileName, "declaration without an explicit or inferrable type"))

    return false
  /if

  return sema:registerDecl(rsv, pdecl, pdecl'sym'name, type, pdecl'node'type, errors) != null
/func


func validateFunc(rsv sema:Resolver,
                  pdecl ptr ast:PDecl,
                  funcType ptr ast:Type,
                  errors ptr list:List) bool

  mut sym ast:Symbol

  sym'type = funcType
  sym'name = pdecl'sym'name

  mut pblock = cast<ptr ast:PBlock>(val pdecl'node'leaves.get(0))

  pblock'syms = ast:stabNew()

  addAllSymbolsToStab(pblock'syms, funcType'members)

  if pdecl'node'type == ast:PMETHOD
    if not ensureMethodCorrectness(rsv, pdecl, funcType, errors)
      return false
    /if
  /if

  return validatePBlock(rsv, pblock, sym, false, errors)
/func


func validateIf(rsv sema:Resolver,
                stmt ptr ast:PNode,
                funcInfo ast:Symbol,
                inLoop bool,
                errors ptr list:List) bool

  mut cond = cast<ptr ast:PExpr>(val stmt'leaves.get(0))

  mut condType = sema:validateExpr(rsv, cond, errors)
  if condType == null
    return false
  /if

  if not ast:typeIsBool(condType)
    mut cs = txt:csNew(20)
    txt:csAppendStr(cs, "expected a boolean expression, got type '")
    ast:typeSummarize(cs, condType)
    txt:csAppendStr(cs, "' instead")

    mut msg = txt:csUnwrap(cs)

    errors.append(parser:issueNew(parser:ISSUE_ERR, cond'node'begin, rsv'root'fileName, msg))

    mem:free(msg)

    return false
  /if

  mut firstBlock = cast<ptr ast:PBlock>(val stmt'leaves.get(1))
  if not validatePBlock(rsv, firstBlock, funcInfo, inLoop, errors)
    return false
  /if

  if stmt'type == ast:PIFELSE
    mut elseBlock = cast<ptr ast:PBlock>(val stmt'leaves.get(2))
    if not validatePBlock(rsv, elseBlock, funcInfo, inLoop, errors)
      return false
    /if
  /if

  return true
/func


func validatePBlock(rsv sema:Resolver,
                    pblock ptr ast:PBlock,
                    funcInfo ast:Symbol,
                    inLoop bool,
                    errors ptr list:List) bool

  if pblock'syms == null
    pblock'syms = ast:stabNew()
  /if

  mut len = pblock'node'leaves.len()
  mut i uintptr = 0

  while i < len
    mut stmt = cast<ptr ast:PNode>(val pblock'node'leaves.get(i))

    if not validateStmt(rsv, stmt, funcInfo, inLoop, errors)
      return false
    /if

    i++
  /while

  return true
/func


func validateReturn(rsv sema:Resolver,
                    stmt ptr ast:PNode,
                    funcInfo ast:Symbol,
                    errors ptr list:List) bool

  mut hasRetExpr = (stmt'leaves.len() == 1)
  mut funcRetTypeEmpty = funcInfo'type'retType == null or funcInfo'type'retType'type == ast:TYPE_EMPTY

  if not hasRetExpr and not funcRetTypeEmpty
    mut cs = txt:csNew(20)
    txt:csAppendStr(cs, "function '")
    txt:csAppendStr(cs, funcInfo'name)
    txt:csAppendStr(cs, "' has a return value, but no expression is given to return")

    mut msg = txt:csUnwrap(cs)

    errors.append(parser:issueNew(parser:ISSUE_ERR, stmt'begin, rsv'root'fileName, msg))

    mem:free(msg)

    return false
  /if

  if hasRetExpr and funcRetTypeEmpty
    mut cs = txt:csNew(20)
    txt:csAppendStr(cs, "function '")
    txt:csAppendStr(cs, funcInfo'name)
    txt:csAppendStr(cs, "' has no return value, but an expression is given to return")

    mut msg = txt:csUnwrap(cs)

    errors.append(parser:issueNew(parser:ISSUE_ERR, stmt'begin, rsv'root'fileName, msg))

    mem:free(msg)

    return false
  /if

  if hasRetExpr
    mut retType = funcInfo'type'retType
    mut retExpr = cast<ptr ast:PExpr>(val stmt'leaves.get(0))

    mut exprType = sema:validateExpr(rsv, retExpr, errors)
    if exprType == null
      return false
    /if

    if not sema:typeIsAssignable(rsv'ctx, stmt, retType, exprType)
      mut cs = txt:csNew(20)
      txt:csAppendStr(cs, "cannot return type '")
      ast:typeSummarize(cs, exprType)
      txt:csAppendStr(cs, "' from function ")
      txt:csAppendStr(cs, funcInfo'name)
      txt:csAppendStr(cs, "(), returning '")
      ast:typeSummarize(cs, retType)
      txt:csAppendStr(cs, "'")

      mut msg = txt:csUnwrap(cs)

      errors.append(parser:issueNew(parser:ISSUE_ERR, stmt'begin, rsv'root'fileName, msg))

      mem:free(msg)

      return false
    /if
  /if

  return true
/func


func validateStmt(rsv sema:Resolver,
                  stmt ptr ast:PNode,
                  funcInfo ast:Symbol,
                  inLoop bool,
                  errors ptr list:List) bool

  if ast:pnodeIsBreakContinue(stmt)
    return validateBreakContinue(rsv, stmt, inLoop, errors)
  /if

  if ast:pnodeIsDecl(stmt)
    return validateDecl(rsv, cast<ptr ast:PDecl>(stmt), errors)
  /if

  if ast:pnodeIsExpr(stmt)
    return sema:validateExpr(rsv, cast<ptr ast:PExpr>(stmt), errors) != null
  /if

  if ast:pnodeIsIf(stmt)
    return validateIf(rsv, stmt, funcInfo, inLoop, errors)
  /if

  if ast:pnodeIsReturn(stmt)
    return validateReturn(rsv, stmt, funcInfo, errors)
  /if

  if ast:pnodeIsWhile(stmt)
    return validateWhile(rsv, stmt, funcInfo, inLoop, errors)
  /if

  # unreachable
  tty:errln("unknown statement type")
  proc:abort()
  return false
/func


func validateWhile(rsv sema:Resolver,
                   stmt ptr ast:PNode,
                   funcInfo ast:Symbol,
                   inLoop bool,
                   errors ptr list:List) bool

  mut cond = cast<ptr ast:PExpr>(val stmt'leaves.get(0))

  mut condType = sema:validateExpr(rsv, cond, errors)
  if condType == null
    return false
  /if

  if not ast:typeIsBool(condType)
    mut cs = txt:csNew(20)
    txt:csAppendStr(cs, "expected a boolean expression, got type '")
    ast:typeSummarize(cs, condType)
    txt:csAppendStr(cs, "' instead")

    mut msg = txt:csUnwrap(cs)

    errors.append(parser:issueNew(parser:ISSUE_ERR, cond'node'begin, rsv'root'fileName, msg))

    mem:free(msg)

    return false
  /if

  mut pblock = cast<ptr ast:PBlock>(val stmt'leaves.get(1))

  return validatePBlock(rsv, pblock, funcInfo, true, errors)
/func
