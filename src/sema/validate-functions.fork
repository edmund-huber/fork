#  Second Step - Experimental Fork Compiler
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2014
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the
#  licenses expressed under Section 1.12 of the MPL v2.


import ast
import ctx
import sema
import spring
import utils


decl validatePBlock func(rsv sema:Resolver,
                         pblock ptr ast:PBlock,
                         funcInfo ast:Symbol,
                         inLoop bool,
                         errors ptr spring:List) bool


func validateBreakContinue(rsv sema:Resolver,
                           stmt ptr ast:PNode,
                           inLoop bool,
                           errors ptr spring:List) bool

  if !inLoop
    spring:listAppend(errors, utils:issueNew(utils:ISSUE_ERR, stmt'begin, rsv'root'fileName, "break or continue outside of a loop"))

    return false
  /if

  return true
/func


func validateIf(rsv sema:Resolver,
                stmt ptr ast:PNode,
                funcInfo ast:Symbol,
                inLoop bool,
                errors ptr spring:List) bool

  mut cond = cast<ptr ast:PExpr>(val spring:listGet(stmt'leaves, 0))

  mut condType = sema:validateExpr(rsv, cond, errors)
  if condType == null
    return false
  /if

  if !ast:typeIsBool(condType)
    mut cs = spring:csNew(20)
    spring:csAppendStr(cs, "expected a boolean expression, got type '")
    ast:typeSummarize(cs, condType)
    spring:csAppendStr(cs, "' instead")

    mut msg = spring:csUnleash(cs)

    spring:listAppend(errors, utils:issueNew(utils:ISSUE_ERR, cond'node'begin, rsv'root'fileName, msg))

    spring:free(msg)

    return false
  /if

  mut firstBlock = cast<ptr ast:PBlock>(val spring:listGet(stmt'leaves, 1))
  if !validatePBlock(rsv, firstBlock, funcInfo, inLoop, errors)
    return false
  /if

  if stmt'type == ast:PIFELSE
    mut elseBlock = cast<ptr ast:PBlock>(val spring:listGet(stmt'leaves, 2))
    if !validatePBlock(rsv, elseBlock, funcInfo, inLoop, errors)
      return false
    /if
  /if

/func


func validateStmt(rsv sema:Resolver,
                  stmt ptr ast:PNode,
                  funcInfo ast:Symbol,
                  inLoop bool,
                  errors ptr spring:List) bool

  if ast:pnodeIsBreakContinue(stmt)
    return validateBreakContinue(rsv, stmt, inLoop, errors)
  /if

  if ast:pnodeIsDecl(stmt)

  /if

  if ast:pnodeIsExpr(stmt)
    return sema:validateExpr(rsv, cast<ptr ast:PExpr>(stmt), errors) != null
  /if

  if ast:pnodeIsIf(stmt)
    return validateIf(rsv, stmt, funcInfo, inLoop, errors)
  /if

  if ast:pnodeIsReturn(stmt)

  /if

  if ast:pnodeIsWhile(stmt)

  /if

  # unreachable
  spring:errln("unknown statement type")
  spring:abort()
  return false
/func


func validatePBlock(rsv sema:Resolver,
                    pblock ptr ast:PBlock,
                    funcInfo ast:Symbol,
                    inLoop bool,
                    errors ptr spring:List) bool

  mut len = spring:listLen(pblock'node'leaves)
  mut i uintptr = 0

  while i < len
    mut stmt = cast<ptr ast:PNode>(val spring:listGet(pblock'node'leaves, i))

    if !validateStmt(rsv, stmt, funcInfo, inLoop, errors)
      return false
    /if

    i++
  /while

  return true
/func


func validateFunc(rsv sema:Resolver,
                  pdecl ptr ast:PDecl,
                  funcType ptr ast:Type,
                  errors ptr spring:List) bool

  mut sym ast:Symbol

  sym'type = funcType
  sym'name = pdecl'sym'name

  mut pblock = cast<ptr ast:PBlock>(val spring:listGet(pdecl'node'leaves, 0))

  return validatePBlock(rsv, pblock, sym, false, errors)
/func
