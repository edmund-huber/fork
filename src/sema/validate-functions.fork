#  libfork, a base library for the Fork language
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2015
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the
#  licenses expressed under Section 1.12 of the MPL v2.


module sema


import ast
import kv
import list
import mem
import parser
import proc
import sema
import tty
import txt
import utils


func validateBreakContinue(rsv sema:Resolver,
                           stmt ptr ast:PNode,
                           inLoop bool,
                           errors ptr list:List) bool

  if !inLoop
    list:listAppend(errors, parser:issueNew(parser:ISSUE_ERR, stmt'begin, rsv'root'fileName, "break or continue outside of a loop"))

    return false
  /if

  return true
/func


func validateDecl(rsv sema:Resolver,
                  pdecl ptr ast:PDecl,
                  errors ptr list:List) bool

  mut isDecl = pdecl'node'type == ast:PDECL
  mut type ptr ast:Type = null

  if pdecl'sym'type != null
    type = sema:resolveType(rsv, pdecl'sym'type, errors)
    if type == null
      return false
    /if
  else
    if isDecl
      list:listAppend(errors, parser:issueNew(parser:ISSUE_ERR, pdecl'node'begin, rsv'root'fileName, "a decl must have a type"))

      return false
    /if
  /if

  mut leavLen = list:listLen(pdecl'node'leaves)

  if leavLen > 0
    mut pexpr = cast<ptr ast:PExpr>(val list:listGet(pdecl'node'leaves, 0))
    if isDecl
      list:listAppend(errors, parser:issueNew(parser:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, "a decl can't have an assignment"))
    /if

    mut exprType = sema:validateExpr(rsv, pexpr, errors)
    if exprType == null
      return false
    /if

    if type != null
      if !sema:typeIsAssignable(rsv'ctx, cast<ptr ast:PNode>(pdecl), type, exprType)
        mut cs = txt:csNew(20)
        txt:csAppendStr(cs, "cannot assign an expression of type '")
        ast:typeSummarize(cs, exprType)
        txt:csAppendStr(cs, "' to a variable declared as '")
        ast:typeSummarize(cs, type)
        txt:csAppendStr(cs, "'")

        mut msg = txt:csUnwrap(cs)

        list:listAppend(errors, parser:issueNew(parser:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, msg))

        mem:free(msg)

        return false
      /if
    else
      if ast:typeIsNull(exprType)
        list:listAppend(errors, parser:issueNew(parser:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, "can't declare a variable with type 'null'"))
        return false
      /if

      type = exprType
    /if
  /if

  if type == null
    list:listAppend(errors, parser:issueNew(parser:ISSUE_ERR, pdecl'node'begin, rsv'root'fileName, "declaration without an explicit or inferrable type"))

    return false
  /if

  return sema:registerDecl(rsv, pdecl, pdecl'sym'name, type, pdecl'node'type, errors) != null
/func


func validateIf(rsv sema:Resolver,
                stmt ptr ast:PNode,
                funcInfo ast:Symbol,
                inLoop bool,
                errors ptr list:List) bool

  mut cond = cast<ptr ast:PExpr>(val list:listGet(stmt'leaves, 0))

  mut condType = sema:validateExpr(rsv, cond, errors)
  if condType == null
    return false
  /if

  if !ast:typeIsBool(condType)
    mut cs = txt:csNew(20)
    txt:csAppendStr(cs, "expected a boolean expression, got type '")
    ast:typeSummarize(cs, condType)
    txt:csAppendStr(cs, "' instead")

    mut msg = txt:csUnwrap(cs)

    list:listAppend(errors, parser:issueNew(parser:ISSUE_ERR, cond'node'begin, rsv'root'fileName, msg))

    mem:free(msg)

    return false
  /if

  mut firstBlock = cast<ptr ast:PBlock>(val list:listGet(stmt'leaves, 1))
  if !validatePBlock(rsv, firstBlock, funcInfo, inLoop, errors)
    return false
  /if

  if stmt'type == ast:PIFELSE
    mut elseBlock = cast<ptr ast:PBlock>(val list:listGet(stmt'leaves, 2))
    if !validatePBlock(rsv, elseBlock, funcInfo, inLoop, errors)
      return false
    /if
  /if

  return true
/func


func validateReturn(rsv sema:Resolver,
                    stmt ptr ast:PNode,
                    funcInfo ast:Symbol,
                    errors ptr list:List) bool

  mut hasRetExpr = list:listLen(stmt'leaves) == 1
  mut funcRetTypeEmpty = funcInfo'type'retType == null or funcInfo'type'retType'type == ast:TYPE_EMPTY

  if !hasRetExpr and !funcRetTypeEmpty
    mut cs = txt:csNew(20)
    txt:csAppendStr(cs, "function '")
    txt:csAppendStr(cs, funcInfo'name)
    txt:csAppendStr(cs, "' has a return value, but no expression is given to return")

    mut msg = txt:csUnwrap(cs)

    list:listAppend(errors, parser:issueNew(parser:ISSUE_ERR, stmt'begin, rsv'root'fileName, msg))

    mem:free(msg)

    return false
  /if

  if hasRetExpr and funcRetTypeEmpty
    mut cs = txt:csNew(20)
    txt:csAppendStr(cs, "function '")
    txt:csAppendStr(cs, funcInfo'name)
    txt:csAppendStr(cs, "' has no return value, but an expression is given to return")

    mut msg = txt:csUnwrap(cs)

    list:listAppend(errors, parser:issueNew(parser:ISSUE_ERR, stmt'begin, rsv'root'fileName, msg))

    mem:free(msg)

    return false
  /if

  if hasRetExpr
    mut retType = funcInfo'type'retType
    mut retExpr = cast<ptr ast:PExpr>(val list:listGet(stmt'leaves, 0))

    mut exprType = sema:validateExpr(rsv, retExpr, errors)
    if exprType == null
      return false
    /if

    if !sema:typeIsAssignable(rsv'ctx, stmt, retType, exprType)
      mut cs = txt:csNew(20)
      txt:csAppendStr(cs, "cannot return type '")
      ast:typeSummarize(cs, exprType)
      txt:csAppendStr(cs, "' from function ")
      txt:csAppendStr(cs, funcInfo'name)
      txt:csAppendStr(cs, "(), returning '")
      ast:typeSummarize(cs, retType)
      txt:csAppendStr(cs, "'")

      mut msg = txt:csUnwrap(cs)

      list:listAppend(errors, parser:issueNew(parser:ISSUE_ERR, stmt'begin, rsv'root'fileName, msg))

      mem:free(msg)

      return false
    /if
  /if

  return true
/func


func validateWhile(rsv sema:Resolver,
                   stmt ptr ast:PNode,
                   funcInfo ast:Symbol,
                   inLoop bool,
                   errors ptr list:List) bool

  mut cond = cast<ptr ast:PExpr>(val list:listGet(stmt'leaves, 0))

  mut condType = sema:validateExpr(rsv, cond, errors)
  if condType == null
    return false
  /if

  if !ast:typeIsBool(condType)
    mut cs = txt:csNew(20)
    txt:csAppendStr(cs, "expected a boolean expression, got type '")
    ast:typeSummarize(cs, condType)
    txt:csAppendStr(cs, "' instead")

    mut msg = txt:csUnwrap(cs)

    list:listAppend(errors, parser:issueNew(parser:ISSUE_ERR, cond'node'begin, rsv'root'fileName, msg))

    mem:free(msg)

    return false
  /if

  mut pblock = cast<ptr ast:PBlock>(val list:listGet(stmt'leaves, 1))

  return validatePBlock(rsv, pblock, funcInfo, true, errors)
/func

func validateStmt(rsv sema:Resolver,
                  stmt ptr ast:PNode,
                  funcInfo ast:Symbol,
                  inLoop bool,
                  errors ptr list:List) bool

  if ast:pnodeIsBreakContinue(stmt)
    return validateBreakContinue(rsv, stmt, inLoop, errors)
  /if

  if ast:pnodeIsDecl(stmt)
    return validateDecl(rsv, cast<ptr ast:PDecl>(stmt), errors)
  /if

  if ast:pnodeIsExpr(stmt)
    return sema:validateExpr(rsv, cast<ptr ast:PExpr>(stmt), errors) != null
  /if

  if ast:pnodeIsIf(stmt)
    return validateIf(rsv, stmt, funcInfo, inLoop, errors)
  /if

  if ast:pnodeIsReturn(stmt)
    return validateReturn(rsv, stmt, funcInfo, errors)
  /if

  if ast:pnodeIsWhile(stmt)
    return validateWhile(rsv, stmt, funcInfo, inLoop, errors)
  /if

  # unreachable
  tty:errln("unknown statement type")
  proc:abort()
  return false
/func


func validatePBlock(rsv sema:Resolver,
                    pblock ptr ast:PBlock,
                    funcInfo ast:Symbol,
                    inLoop bool,
                    errors ptr list:List) bool

  if pblock'syms == null
    pblock'syms = ast:stabNew()
  /if

  mut len = list:listLen(pblock'node'leaves)
  mut i uintptr = 0

  while i < len
    mut stmt = cast<ptr ast:PNode>(val list:listGet(pblock'node'leaves, i))

    if !validateStmt(rsv, stmt, funcInfo, inLoop, errors)
      return false
    /if

    i++
  /while

  return true
/func


func addAllSymbolsToStab(stab ptr ast:Symtable, syms ptr kv:KVList)
  mut len = kv:kvLen(syms)
  mut i uintptr = 0

  while i < len
    mut pair = kv:kvGetAt(syms, i)

    mut name = cast<ptr uint8>(pair'key)
    mut type = cast<ptr ast:Type>(pair'value)

    ast:stabAdd(stab, name, type, ast:PDECL)

    i++
  /while
/func


func validateFunc(rsv sema:Resolver,
                  pdecl ptr ast:PDecl,
                  funcType ptr ast:Type,
                  errors ptr list:List) bool

  mut sym ast:Symbol

  sym'type = funcType
  sym'name = pdecl'sym'name

  mut pblock = cast<ptr ast:PBlock>(val list:listGet(pdecl'node'leaves, 0))

  pblock'syms = ast:stabNew()

  addAllSymbolsToStab(pblock'syms, funcType'members)

  return validatePBlock(rsv, pblock, sym, false, errors)
/func
