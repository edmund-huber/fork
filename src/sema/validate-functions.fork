#  libfork, a base library for the Fork language
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2015
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the
#  licenses expressed under Section 1.12 of the MPL v2.


import ast
import base
import ctx
import mem
import sema
import text
import utils


decl validatePBlock func(rsv sema:Resolver,
                         pblock ptr ast:PBlock,
                         funcInfo ast:Symbol,
                         inLoop bool,
                         errors ptr base:List) bool


func validateBreakContinue(rsv sema:Resolver,
                           stmt ptr ast:PNode,
                           inLoop bool,
                           errors ptr base:List) bool

  if !inLoop
    base:listAppend(errors, utils:issueNew(utils:ISSUE_ERR, stmt'begin, rsv'root'fileName, "break or continue outside of a loop"))

    return false
  /if

  return true
/func


func validateDecl(rsv sema:Resolver,
                  pdecl ptr ast:PDecl,
                  errors ptr base:List) bool

  mut isDecl = pdecl'node'type == ast:PDECL
  mut type ptr ast:Type = null

  if pdecl'sym'type != null
    type = sema:resolveType(rsv, pdecl'sym'type, errors)
    if type == null
      return false
    /if
  else
    if isDecl
      base:listAppend(errors, utils:issueNew(utils:ISSUE_ERR, pdecl'node'begin, rsv'root'fileName, "a decl must have a type"))

      return false
    /if
  /if

  mut leavLen = base:listLen(pdecl'node'leaves)

  if leavLen > 0
    mut pexpr = cast<ptr ast:PExpr>(val base:listGet(pdecl'node'leaves, 0))
    if isDecl
      base:listAppend(errors, utils:issueNew(utils:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, "a decl can't have an assignment"))
    /if

    mut exprType = sema:validateExpr(rsv, pexpr, errors)
    if exprType == null
      return false
    /if

    if type != null
      if !sema:typeIsAssignable(rsv'ctx, cast<ptr ast:PNode>(pdecl), type, exprType)
        mut cs = text:csNew(20)
        text:csAppendStr(cs, "cannot assign an expression of type '")
        ast:typeSummarize(cs, exprType)
        text:csAppendStr(cs, "' to a variable declared as '")
        ast:typeSummarize(cs, type)
        text:csAppendStr(cs, "'")

        mut msg = text:csUnwrap(cs)

        base:listAppend(errors, utils:issueNew(utils:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, msg))

        mem:free(msg)

        return false
      /if
    else
      if ast:typeIsNull(exprType)
        base:listAppend(errors, utils:issueNew(utils:ISSUE_ERR, pexpr'node'begin, rsv'root'fileName, "can't declare a variable with type 'null'"))
        return false
      /if

      type = exprType
    /if
  /if

  if type == null
    base:listAppend(errors, utils:issueNew(utils:ISSUE_ERR, pdecl'node'begin, rsv'root'fileName, "declaration without an explicit or inferrable type"))

    return false
  /if

  return sema:registerDecl(rsv, pdecl, pdecl'sym'name, type, pdecl'node'type, errors) != null
/func


func validateIf(rsv sema:Resolver,
                stmt ptr ast:PNode,
                funcInfo ast:Symbol,
                inLoop bool,
                errors ptr base:List) bool

  mut cond = cast<ptr ast:PExpr>(val base:listGet(stmt'leaves, 0))

  mut condType = sema:validateExpr(rsv, cond, errors)
  if condType == null
    return false
  /if

  if !ast:typeIsBool(condType)
    mut cs = text:csNew(20)
    text:csAppendStr(cs, "expected a boolean expression, got type '")
    ast:typeSummarize(cs, condType)
    text:csAppendStr(cs, "' instead")

    mut msg = text:csUnwrap(cs)

    base:listAppend(errors, utils:issueNew(utils:ISSUE_ERR, cond'node'begin, rsv'root'fileName, msg))

    mem:free(msg)

    return false
  /if

  mut firstBlock = cast<ptr ast:PBlock>(val base:listGet(stmt'leaves, 1))
  if !validatePBlock(rsv, firstBlock, funcInfo, inLoop, errors)
    return false
  /if

  if stmt'type == ast:PIFELSE
    mut elseBlock = cast<ptr ast:PBlock>(val base:listGet(stmt'leaves, 2))
    if !validatePBlock(rsv, elseBlock, funcInfo, inLoop, errors)
      return false
    /if
  /if

  return true
/func


func validateReturn(rsv sema:Resolver,
                    stmt ptr ast:PNode,
                    funcInfo ast:Symbol,
                    errors ptr base:List) bool

  mut hasRetExpr = base:listLen(stmt'leaves) == 1
  mut funcRetTypeEmpty = funcInfo'type'retType == null or funcInfo'type'retType'type == ast:TYPE_EMPTY

  if !hasRetExpr and !funcRetTypeEmpty
    mut cs = text:csNew(20)
    text:csAppendStr(cs, "function '")
    text:csAppendStr(cs, funcInfo'name)
    text:csAppendStr(cs, "' has a return value, but no expression is given to return")

    mut msg = text:csUnwrap(cs)

    mem:free(msg)

    return false
  /if

  if hasRetExpr and funcRetTypeEmpty
    mut cs = text:csNew(20)
    text:csAppendStr(cs, "function '")
    text:csAppendStr(cs, funcInfo'name)
    text:csAppendStr(cs, "' has no return value, but an expression is given to return")

    mut msg = text:csUnwrap(cs)

    mem:free(msg)

    return false
  /if

  if hasRetExpr
    mut retType = funcInfo'type'retType
    mut retExpr = cast<ptr ast:PExpr>(val base:listGet(stmt'leaves, 0))

    mut exprType = sema:validateExpr(rsv, retExpr, errors)
    if exprType == null
      return false
    /if

    if !sema:typeIsAssignable(rsv'ctx, stmt, retType, exprType)
      mut cs = text:csNew(20)
      text:csAppendStr(cs, "cannot return type '")
      ast:typeSummarize(cs, exprType)
      text:csAppendStr(cs, "' from '")
      text:csAppendStr(cs, funcInfo'name)
      text:csAppendStr(cs, "', expected '")
      ast:typeSummarize(cs, retType)
      text:csAppendStr(cs, "'")

      mut msg = text:csUnwrap(cs)

      mem:free(msg)

      return false
    /if
  /if

  return true
/func


func validateWhile(rsv sema:Resolver,
                   stmt ptr ast:PNode,
                   funcInfo ast:Symbol,
                   inLoop bool,
                   errors ptr base:List) bool

  mut cond = cast<ptr ast:PExpr>(val base:listGet(stmt'leaves, 0))

  mut condType = sema:validateExpr(rsv, cond, errors)
  if condType == null
    return false
  /if

  if !ast:typeIsBool(condType)
    mut cs = text:csNew(20)
    text:csAppendStr(cs, "expected a boolean expression, got type '")
    ast:typeSummarize(cs, condType)
    text:csAppendStr(cs, "' instead")

    mut msg = text:csUnwrap(cs)

    base:listAppend(errors, utils:issueNew(utils:ISSUE_ERR, cond'node'begin, rsv'root'fileName, msg))

    mem:free(msg)

    return false
  /if

  mut pblock = cast<ptr ast:PBlock>(val base:listGet(stmt'leaves, 1))

  return validatePBlock(rsv, pblock, funcInfo, true, errors)
/func

func validateStmt(rsv sema:Resolver,
                  stmt ptr ast:PNode,
                  funcInfo ast:Symbol,
                  inLoop bool,
                  errors ptr base:List) bool

  if ast:pnodeIsBreakContinue(stmt)
    return validateBreakContinue(rsv, stmt, inLoop, errors)
  /if

  if ast:pnodeIsDecl(stmt)
    return validateDecl(rsv, cast<ptr ast:PDecl>(stmt), errors)
  /if

  if ast:pnodeIsExpr(stmt)
    return sema:validateExpr(rsv, cast<ptr ast:PExpr>(stmt), errors) != null
  /if

  if ast:pnodeIsIf(stmt)
    return validateIf(rsv, stmt, funcInfo, inLoop, errors)
  /if

  if ast:pnodeIsReturn(stmt)
    return validateReturn(rsv, stmt, funcInfo, errors)
  /if

  if ast:pnodeIsWhile(stmt)
    return validateWhile(rsv, stmt, funcInfo, inLoop, errors)
  /if

  # unreachable
  base:errln("unknown statement type")
  base:abort()
  return false
/func


func validatePBlock(rsv sema:Resolver,
                    pblock ptr ast:PBlock,
                    funcInfo ast:Symbol,
                    inLoop bool,
                    errors ptr base:List) bool

  if pblock'syms == null
    pblock'syms = ast:stabNew()
  /if

  mut len = base:listLen(pblock'node'leaves)
  mut i uintptr = 0

  while i < len
    mut stmt = cast<ptr ast:PNode>(val base:listGet(pblock'node'leaves, i))

    if !validateStmt(rsv, stmt, funcInfo, inLoop, errors)
      return false
    /if

    i++
  /while

  return true
/func


func addAllSymbolsToStab(stab ptr ast:Symtable, syms ptr utils:KVList)
  mut len = utils:kvLen(syms)
  mut i uintptr = 0

  while i < len
    mut pair = utils:kvGetAt(syms, i)

    mut name = cast<ptr uint8>(pair'key)
    mut type = cast<ptr ast:Type>(pair'value)

    ast:stabAdd(stab, name, type, ast:PDECL)

    i++
  /while
/func


func validateFunc(rsv sema:Resolver,
                  pdecl ptr ast:PDecl,
                  funcType ptr ast:Type,
                  errors ptr base:List) bool

  mut sym ast:Symbol

  sym'type = funcType
  sym'name = pdecl'sym'name

  mut pblock = cast<ptr ast:PBlock>(val base:listGet(pdecl'node'leaves, 0))

  pblock'syms = ast:stabNew()

  addAllSymbolsToStab(pblock'syms, funcType'members)

  return validatePBlock(rsv, pblock, sym, false, errors)
/func
