#  Second Step - Experimental Fork Compiler
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2014
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the
#  licenses expressed under Section 1.12 of the MPL v2.

import ast
import ctx
import sema
import spring
import utils


func rootAliasRegister(root ptr ast:PRoot, rawAliases ptr utils:KVList, name ptr uint8, type ptr ast:Type)
  type'name = spring:strclone(name)
  type'moduleName = root'moduleName != null => spring:strclone(root'moduleName'name) || null
  ast:stabAdd(root'aliases, name, type)
  utils:kvRemove(rawAliases, name)
/func


func findAliasImport(ctx ptr ctx:Context, moduleName,name ptr uint8) ptr ast:Type
  mut imp = ctx:contextGetImport(ctx, moduleName)
  if imp == null
    return null
  /if

  return ast:stabTypeof(imp'aliases, name)
/func


func findAliasLocal(node ptr ast:PNode, name ptr uint8) ptr ast:Type
  if node == null
    return null
  /if

  if node'type != ast:PROOT
    return findAliasLocal(node'parent, name)
  /if

  mut root = cast<ptr ast:PRoot>(node)

  return ast:stabTypeof(root'aliases, name)
/func


func listContains(list ptr spring:List, value ptr uint8) bool
  mut i uintptr = 0
  mut len = spring:listLen(list)

  while i < len
    mut elem = cast<ptr uint8>(val spring:listGet(list, i))

    if spring:strequals(elem, value)
      return true
    /if

    i++
  /while

  return false
/func


func listDumpHierarchyIntoCS(list ptr spring:List, cs ptr spring:Charstash)
  mut len = spring:listLen(list)

  spring:csAppendStr(cs, "(")

  if len > 1

    mut i = cast<intptr>(len)

    while i > 0
      i--

      spring:csAppendStr(cs, cast<ptr uint8>(val spring:listGet(list, i)))

      spring:csAppendStr(cs, " => ")
    /while

    spring:csAppendStr(cs, cast<ptr uint8>(val spring:listGet(list, len - 1)))
  else
    spring:csAppendStr(cs, "alias of itself")
  /if

  spring:csAppendStr(cs, ")")
/func


func validateModuleAlias(ctx ptr ctx:Context, root ptr ast:PRoot,
    rawAliases ptr utils:KVList, ptype ptr ast:PType,
    errors ptr spring:List) ptr ast:Type


  if !ast:prootHasImported(root, ptype'moduleName)
    mut msg = spring:strappend("no import called ", ptype'moduleName)
    spring:listAppend(errors, utils:issueNew(utils:ISSUE_ERR, ptype'begin, root'fileName, msg))
    spring:free(msg)

    return null
  /if

  mut type = findAliasImport(ctx, ptype'moduleName, ptype'name)
  if type != null
    return type
  /if

  # we could not find the type anywhere in the module.
  # Signal the error to the caller.
  mut cs = spring:csNew(20)
  spring:csAppendStr(cs, "no alias called ")
  spring:csAppendStr(cs, ptype'name)
  spring:csAppendStr(cs, " in module ")
  spring:csAppendStr(cs, ptype'moduleName)

  mut msg = spring:csUnleash(cs)
  spring:listAppend(errors, utils:issueNew(utils:ISSUE_ERR, ptype'begin, root'fileName, msg))
  spring:free(msg)

  return null
/func


decl validateAlias func(ctx ptr ctx:Context, root ptr ast:PRoot,
    rawAliases ptr utils:KVList, ptype ptr ast:PType,
    errors,recList ptr spring:List, canBeFunc,ignoreSize bool) ptr ast:Type


func validateIdAlias(ctx ptr ctx:Context, root ptr ast:PRoot,
    rawAliases ptr utils:KVList, ptype ptr ast:PType,
    errors,recList ptr spring:List, ignoreSize bool) ptr ast:Type

  mut builtin = ctx:contextMatchBuiltin(ctx, ptype'name)
  if builtin != null
    return builtin
  /if

  if listContains(recList, ptype'name)
    if ignoreSize
      return ast:typeNewRecursiveAlias(root'typePool, root'moduleName != null => root'moduleName'name || null, ptype'name)
    /if

    mut cs = spring:csNew(20)
    spring:csAppendStr(cs, "illegal recursive type ")
    spring:csAppendStr(cs, ptype'name)
    spring:csAppend(cs, 32)
    listDumpHierarchyIntoCS(recList, cs)

    mut msg = spring:csUnleash(cs)
    spring:listAppend(errors, utils:issueNew(utils:ISSUE_ERR, ptype'begin, root'fileName, msg))
    spring:free(msg)

    return null
  /if

  # it's not builtin, so it must be a local alias.
  mut type = findAliasLocal(cast<ptr ast:PNode>(root), ptype'name)
  if type != null
    return type
  /if

  # If here, then it's either undefined, or not validated yet.
  # So, we try to find a valid ptype, or otherwise it's an error.

  mut missingPType ptr ast:PType

  if utils:kvGet(rawAliases, ptype'name, ptr missingPType)
    spring:listPush(recList, ptype'name)

    mut ret = validateAlias(ctx, root, rawAliases, missingPType, errors, recList, true, ignoreSize)

    spring:listPop(recList)

    if ret != null
      rootAliasRegister(root, rawAliases, ptype'name, ret)
    /if
    return ret
  /if

  # no match found, error
  mut cs = spring:csNew(20)
  spring:csAppendStr(cs, "no type called ")
  spring:csAppendStr(cs, ptype'name)
  spring:csAppendStr(cs, " in current scope")

  mut msg = spring:csUnleash(cs)
  spring:listAppend(errors, utils:issueNew(utils:ISSUE_ERR, ptype'begin, root'fileName, msg))
  spring:free(msg)

  return null
/func


func validateRetType(ctx ptr ctx:Context, root ptr ast:PRoot,
    rawAliases ptr utils:KVList, retPType ptr ast:PType,
    errors,recList ptr spring:List, isLoc bool) ptr ast:Type

  mut res ptr ast:Type = null

  # if this condition evaluates to true, than we're in the case of a recursive alias.
  if !isLoc and retPType'moduleName == null and retPType'name != null and listContains(recList, retPType'name)
    res = ast:typeNewRecursiveAlias(root'typePool, null, retPType'name)
  else
    # otherwise, this is a normal type. Validate it with validateAlias.
    res = validateAlias(ctx, root, rawAliases, retPType, errors, recList, true, true)
  /if

  return res
/func


# Validates a ptr or a loc type alias.
func validatePtrLocAlias(ctx ptr ctx:Context, root ptr ast:PRoot,
    rawAliases ptr utils:KVList, ptype ptr ast:PType,
    errors,recList ptr spring:List) ptr ast:Type

  mut ptdes = cast<ptr ast:PTypeDescr>(ptype'descr)
  mut isLoc = ptdes'type == ast:PTYPE_LOC

  # validate ptdes'retType
  mut res = validateRetType(ctx, root, rawAliases, ptdes'retType, errors, recList, isLoc)

  if isLoc
    res = ast:typeNewLoc(root'typePool, null, null, ptdes'length, res)
  else
    res = ast:typeNewPtr(root'typePool, null, null, res)
  /if

  return res
/func


func validateSymbolList(ctx ptr ctx:Context, root ptr ast:PRoot,
    rawAliases ptr utils:KVList,
    pargs,errors,recList ptr spring:List, funcArgs bool) ptr spring:List

  mut errLen = spring:listLen(errors)

  mut plen = spring:listLen(pargs)
  mut i uintptr = 0
  mut members = spring:listNew()

  while i < plen
    mut member = cast<ptr ast:PSymbol>(val spring:listGet(pargs, i))
    mut ptype = member'type

    mut type ptr ast:Type = null

    # functions can refer to recursive types, because their arguments and their
    # return types do not affect the size of the function (a function is always sizeless)
    if funcArgs and ptype'moduleName == null and ptype'name != null and listContains(recList, ptype'name)
      type = ast:typeNewRecursiveAlias(root'typePool, null, ptype'name)
    else
      type = validateAlias(ctx, root, rawAliases, ptype, errors, recList, false, false)
    /if

    if type != null
      spring:listAppend(members, ast:symbolNew(member'name, type))
    /if

    i++
  /while

  if spring:listLen(errors) > errLen
    spring:listFreeAll(members, cast<ptr func(i data)>(ptr ast:symbolFree))
    return null
  /if

  return members
/func


func validateStructAlias(ctx ptr ctx:Context, root ptr ast:PRoot,
    rawAliases ptr utils:KVList, ptype ptr ast:PType,
    errors,recList ptr spring:List) ptr ast:Type

  mut ptdes = cast<ptr ast:PTypeDescr>(ptype'descr)

  mut members = validateSymbolList(ctx, root, rawAliases, ptdes'arguments, errors, recList, false)

  return members != null => ast:typeNewStruct(root'typePool, null, null, members) || null
/func


func validateFuncAlias(ctx ptr ctx:Context, root ptr ast:PRoot,
    rawAliases ptr utils:KVList, ptype ptr ast:PType,
    errors,recList ptr spring:List) ptr ast:Type

  mut ptdes = cast<ptr ast:PTypeDescr>(ptype'descr)

  mut retVal ptr ast:Type = null
  if ptdes'retType != null
    retVal = validateRetType(ctx, root, rawAliases, ptdes'retType, errors, recList, false)
    if retVal == null
      return null
    /if
  /if

  mut members = validateSymbolList(ctx, root, rawAliases, ptdes'arguments, errors, recList, true)
  if members == null
    return null
  /if

  return ast:typeNewFunc(root'typePool, null, null, retVal, members)
/func


# Validates an alias.
func validateAlias(ctx ptr ctx:Context, root ptr ast:PRoot,
    rawAliases ptr utils:KVList, ptype ptr ast:PType,
    errors,recList ptr spring:List, canBeFunc,ignoreSize bool) ptr ast:Type

  mut type ptr ast:Type = null

  # first, if the PType refers another module, then it's not our business; just check the module and fetch the type.
  if ptype'moduleName != null

    return validateModuleAlias(ctx, root, rawAliases, ptype, errors)

  else
    # otherwise, it can be a builtin, a local alias or a composite type
    mut ptdes = cast<ptr ast:PTypeDescr>(ptype'descr)

    # if we've found an id, it can be 1. an id type 2. builtin 3. an invalid type
    if ptdes'type == ast:PTYPE_ID
      type = validateIdAlias(ctx, root, rawAliases, ptype, errors, recList, ignoreSize)
    else
      if ptdes'type == ast:PTYPE_PTR or ptdes'type == ast:PTYPE_LOC
        type = validatePtrLocAlias(ctx, root, rawAliases, ptype, errors, recList)
      else
        if ptdes'type == ast:PTYPE_STRUCT
          type = validateStructAlias(ctx, root, rawAliases, ptype, errors, recList)
        else
          if ptdes'type == ast:PTYPE_FUNC
            if !canBeFunc
              # a function is not allowed.
              spring:listAppend(errors, utils:issueNew(utils:ISSUE_ERR, ptype'begin, root'fileName, "a function type is not allowed here"))
              return null
            /if

            type = validateFuncAlias(ctx, root, rawAliases, ptype, errors, recList)
          else
            spring:errln("Unreachable")
            spring:abort()
          /if
        /if
      /if
    /if

  /if

  return type
/func


func collectGlobalAliases(root ptr ast:PRoot, errors ptr spring:List, kv ptr utils:KVList) ptr utils:KVList
  utils:strkvInit(kv)

  mut i uintptr = 0
  mut leaves = root'node'node'leaves
  mut len = spring:listLen(leaves)

  while i < len
    mut pdecl = cast<ptr ast:PDecl>(val spring:listGet(leaves, i))

    if pdecl'node'type == ast:PALIAS
      if utils:kvContains(kv, pdecl'sym'name)
        utils:kvDeinit(kv)

        mut cs = spring:csNew(20)
        spring:csAppendStr(cs, "alias ")
        spring:csAppendStr(cs, pdecl'sym'name)
        spring:csAppendStr(cs, " is already defined")

        spring:listAppend(errors, utils:issueNew(utils:ISSUE_ERR, pdecl'node'begin, root'fileName, spring:csUnleash(cs)))
      /if

      utils:kvPut(kv, pdecl'sym'name, pdecl'sym'type)
    /if

    i++
  /while

  return kv
/func


func populateGlobalAliasTable(ctx ptr ctx:Context, root ptr ast:PRoot, errors ptr spring:List) bool
  mut aliasKV utils:KVList

  collectGlobalAliases(root, errors, ptr aliasKV)

  mut pair ptr spring:Pair
  mut recList spring:List

  spring:listInit(ptr recList)

  while (pair = utils:kvGetAt(ptr aliasKV, 0)) != null
    mut name = cast<ptr uint8>(pair'key)
    mut ptype = cast<ptr ast:PType>(pair'value)

    spring:listPush(ptr recList, name)

    mut type = validateAlias(ctx, root, ptr aliasKV, ptype, errors, ptr recList, true, false)

    spring:listPop(ptr recList)

    if type != null
      rootAliasRegister(root, ptr aliasKV, name, type)
    else
      break
    /if
  /while

  utils:kvDeinit(ptr aliasKV)
  spring:listDeinit(ptr recList)

  return spring:listLen(errors) == 0
/func
