#  Second Step - Experimental Fork Compiler
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2014
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the
#  licenses expressed under Section 1.12 of the MPL v2.

import ast
import ctx
import sema
import spring
import utils

func findAliasImport(ctx ptr ctx:Context, moduleName,name ptr uint8) ptr ast:Type
  mut imp = ctx:contextGetImport(ctx, moduleName)
  if imp == null
    return null
  /if

  return ast:stabTypeof(imp'aliases, name)
/func


func findAliasLocal(node ptr ast:PNode, name ptr uint8) ptr ast:Type
  if node == null
    return null
  /if

  if node'type != ast:PROOT
    return findAliasLocal(node'parent, name)
  /if

  mut root = cast<ptr ast:PRoot>(node)

  return ast:stabTypeof(root'aliases, name)
/func


func listContains(list ptr spring:List, value ptr uint8) bool
  mut i uintptr = 0
  mut len = spring:listLen(list)

  while i < len
    mut elem = cast<ptr uint8>(val spring:listGet(list, i))

    if spring:strequals(elem, value)
      return true
    /if

    i++
  /while
/func


# Validates an alias.
# recursive starts containing the alias name, so it will be treated correctly by validateAlias.
func validateAlias(ctx ptr ctx:Context, root ptr ast:PRoot, rawAliases ptr spring:Map, pair ptr spring:Pair, errors,recList ptr spring:List) bool

  if pair == null
    return false
  /if

  mut name = cast<ptr uint8>(pair'key)
  mut ptype = cast<ptr ast:PType>(pair'value)

  spring:listPush(recList, name)

  # first, if the PType refers another module, then it's not our business; just check the module and fetch the type.
  if ptype'moduleName != null
    if !ast:prootHasImported(root, ptype'moduleName)
      mut msg = spring:strappend("no import called ", ptype'moduleName)
      spring:listAppend(errors, utils:issueNew(utils:ISSUE_ERR, ptype'begin, root'fileName, msg))
      spring:free(msg)

      return false
    /if

    mut type = findAliasImport(ctx, ptype'moduleName, ptype'name)
    if type == null
      mut cs = spring:csNew(20)
      spring:csAppendStr(cs, "no alias called ")
      spring:csAppendStr(cs, ptype'name)
      spring:csAppendStr(cs, " in module ")
      spring:csAppendStr(cs, ptype'moduleName)

      mut msg = spring:csUnleash(cs)
      spring:listAppend(errors, utils:issueNew(utils:ISSUE_ERR, ptype'begin, root'fileName, msg))
      spring:free(msg)

      return false
    /if

    ast:stabAdd(root'aliases, name, type)
    spring:listPop(recList)
    return true
  /if

  # otherwise, it can be a builtin, a local alias or a composite type
  mut ptdes = cast<ptr ast:PTypeDescr>(ptype'descr)

  # if we've found an id, it can be 1. an id type 2. builtin 3. an invalid type
  if ptdes'type == ast:PTYPE_ID

    mut builtin = ctx:contextMatchBuiltin(ctx, ptype'name)
    if builtin != null
      ast:stabAdd(root'aliases, name, builtin)
      spring:listPop(recList)

      return true
    /if

    if listContains(recList, ptype'name)
      mut cs = spring:csNew(20)
      spring:csAppendStr(cs, "illegal recursive type ")
      spring:csAppendStr(cs, ptype'name)

      mut msg = spring:csUnleash(cs)
      spring:listAppend(errors, utils:issueNew(utils:ISSUE_ERR, ptype'begin, root'fileName, msg))
      spring:free(msg)

      return false
    /if

    # it's not builtin, so it must be a local alias.
    mut type = findAliasLocal(cast<ptr ast:PNode>(root), ptype'name)
    if type != null
      ast:stabAdd(root'aliases, name, type)
      spring:listPop(recList)

      return true
    /if

    # If here, then it's either undefined, or not validated yet.
    # So, we try to find a valid ptype, or otherwise it's an error.

    mut missingPType ptr ast:PType

    if spring:mapGet(rawAliases, ptype'name, ptr missingPType)
      mut rp = spring:pairNew(ptype'name, missingPType)

      mut res = validateAlias(ctx, root, rawAliases, rp, errors, recList)

      spring:pairFree(rp)

      spring:listPop(recList)
      return res
    else
      # no match found, error
      mut cs = spring:csNew(20)
      spring:csAppendStr(cs, "no type called ")
      spring:csAppendStr(cs, ptype'name)
      spring:csAppendStr(cs, " in current scope")

      mut msg = spring:csUnleash(cs)
      spring:listAppend(errors, utils:issueNew(utils:ISSUE_ERR, ptype'begin, root'fileName, msg))
      spring:free(msg)

      return false
    /if
  /if

  if ptdes'type == ast:PTYPE_PTR or ptdes'type == ast:PTYPE_LOC

  /if
/func


func collectGlobalAliases(root ptr ast:PRoot, errors ptr spring:List) ptr spring:Map
  mut map = spring:strmapNew()

  mut i uintptr = 0
  mut leaves = root'node'node'leaves
  mut len = spring:listLen(leaves)

  while i < len
    mut pdecl = cast<ptr ast:PDecl>(val spring:listGet(leaves, i))

    if pdecl'node'type == ast:PALIAS
      if spring:mapContains(map, pdecl'sym'name)
        spring:mapFree(map)

        mut cs = spring:csNew(20)
        spring:csAppendStr(cs, "alias ")
        spring:csAppendStr(cs, pdecl'sym'name)
        spring:csAppendStr(cs, " is already defined")

        spring:listAppend(errors, utils:issueNew(utils:ISSUE_ERR, pdecl'node'begin, root'fileName, spring:csUnleash(cs)))
      /if

      spring:mapPut(map, pdecl'sym'name, pdecl'sym'type, spring:FREE_NONE)
    /if

    i++
  /while

  return map
/func


func populateGlobalAliasTable(ctx ptr ctx:Context, root ptr ast:PRoot, errors ptr spring:List) bool
  mut aliasMap = collectGlobalAliases(root, errors)

  mut pair ptr spring:Pair

  while (pair = spring:mapFirst(aliasMap)) != null
    mut recList = spring:listNew()

    mut res = validateAlias(ctx, root, aliasMap, pair, errors, recList)

    spring:pairFree(pair)

    if res
      spring:mapRemove(aliasMap, pair'key)
    else
      break
    /if
  /while

  spring:mapFree(aliasMap)
/func
