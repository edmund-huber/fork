#  Second Step - Experimental Fork Compiler
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2014
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the
#  licenses expressed under Section 1.12 of the MPL v2.

import ast
import ctx
import sema
import spring
import utils


func findAliasImport(ctx ptr ctx:Context, moduleName,name ptr uint8) ptr ast:Type
  mut imp = ctx:contextGetImport(ctx, moduleName)
  if imp == null
    return null
  /if

  return ast:stabTypeof(imp'aliases, name)
/func


func findAliasLocal(node ptr ast:PNode, name ptr uint8) ptr ast:Type
  if node == null
    return null
  /if

  if node'type != ast:PROOT
    return findAliasLocal(node'parent, name)
  /if

  mut root = cast<ptr ast:PRoot>(node)

  return ast:stabTypeof(root'aliases, name)
/func


# Validates an alias.
# recursive starts containing the alias name, so it will be treated correctly by validateAlias.
func validateAlias(ctx ptr ctx:Context, root ptr ast:PRoot, ptype ptr ast:PType, errors,recursive ptr spring:List) ptr ast:Type
  if ptype == null or root == null or errors == null or recursive == null
    return null
  /if

  # first, if the PType refers another module, then it's not our business; just check the module and fetch the type.
  if ptype'moduleName != null
    if !ast:prootHasImported(root, ptype'moduleName)
      mut msg = spring:strappend("no import called ", ptype'moduleName)
      spring:listAppend(errors, utils:issueNew(utils:ISSUE_ERR, ptype'begin, root'fileName, msg))
      spring:free(msg)

      return null
    /if

    mut type = findAliasImport(ctx, ptype'moduleName, ptype'name)
    if type == null
      mut cs = spring:csNew(20)
      spring:csAppendStr(cs, "no alias called ")
      spring:csAppendStr(cs, ptype'name)
      spring:csAppendStr(cs, " in module ")
      spring:csAppendStr(cs, ptype'moduleName)

      mut msg = spring:csUnleash(cs)
      spring:listAppend(errors, utils:issueNew(utils:ISSUE_ERR, ptype'begin, root'fileName, msg))
      spring:free(msg)

      return null
    /if

    return type
  /if

  # otherwise, it can be a builtin, a local alias or a composite type
  mut ptdes = cast<ptr ast:PTypeDescr>(ptype'descr)

  # if we've found an id, it can be 1. an id type 2. builtin 3. an invalid type
  if ptdes'type == ast:PTYPE_ID
    mut builtin = ctx:contextMatchBuiltin(ctx, ptype'name)
    if builtin != null
      return builtin
    /if

    # it's not builtin, so it must be a local alias. Otherwise, this is invalid
    # and can't be admitted

    mut local = findAliasLocal(cast<ptr ast:PNode>(root), ptype'name)
    if local != null
      return local
    /if

    # no match found, error
    mut cs = spring:csNew(20)
    spring:csAppendStr(cs, "no type called ")
    spring:csAppendStr(cs, ptype'name)
    spring:csAppendStr(cs, " in current scope")

    mut msg = spring:csUnleash(cs)
    spring:listAppend(errors, utils:issueNew(utils:ISSUE_ERR, ptype'begin, root'fileName, msg))
    spring:free(msg)

    return null
  /if

/func
