#  Second Step - Experimental Fork Compiler
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2014
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the
#  licenses expressed under Section 1.12 of the MPL v2.

import ast
import ctx
import sema
import spring
import utils

func findAliasImport(ctx ptr ctx:Context, moduleName,name ptr uint8) ptr ast:Type
  mut imp = ctx:contextGetImport(ctx, moduleName)
  if imp == null
    return null
  /if

  return ast:stabTypeof(imp'aliases, name)
/func


func findAliasLocal(node ptr ast:PNode, name ptr uint8) ptr ast:Type
  if node == null
    return null
  /if

  if node'type != ast:PROOT
    return findAliasLocal(node'parent, name)
  /if

  mut root = cast<ptr ast:PRoot>(node)

  return ast:stabTypeof(root'aliases, name)
/func


func listContains(list ptr spring:List, value ptr uint8) bool
  mut i uintptr = 0
  mut len = spring:listLen(list)

  while i < len
    mut elem = cast<ptr uint8>(val spring:listGet(list, i))

    if spring:strequals(elem, value)
      return true
    /if

    i++
  /while
/func


func validateModuleAlias(ctx ptr ctx:Context, root ptr ast:PRoot,
    rawAliases ptr spring:Map, ptype ptr ast:PType,
    errors ptr spring:List) ptr ast:Type


  if !ast:prootHasImported(root, ptype'moduleName)
    mut msg = spring:strappend("no import called ", ptype'moduleName)
    spring:listAppend(errors, utils:issueNew(utils:ISSUE_ERR, ptype'begin, root'fileName, msg))
    spring:free(msg)

    return null
  /if

  mut type = findAliasImport(ctx, ptype'moduleName, ptype'name)
  if type != null
    return type
  /if

  # we could not find the type anywhere in the module.
  # Signal the error to the caller.
  mut cs = spring:csNew(20)
  spring:csAppendStr(cs, "no alias called ")
  spring:csAppendStr(cs, ptype'name)
  spring:csAppendStr(cs, " in module ")
  spring:csAppendStr(cs, ptype'moduleName)

  mut msg = spring:csUnleash(cs)
  spring:listAppend(errors, utils:issueNew(utils:ISSUE_ERR, ptype'begin, root'fileName, msg))
  spring:free(msg)

  return null
/func


func registerType()

/func


decl validateAlias func(ctx ptr ctx:Context, root ptr ast:PRoot,
    rawAliases ptr spring:Map, ptype ptr ast:PType,
    errors,recList ptr spring:List) ptr ast:Type


func validateIdAlias(ctx ptr ctx:Context, root ptr ast:PRoot,
    rawAliases ptr spring:Map, ptype ptr ast:PType,
    errors,recList ptr spring:List) ptr ast:Type

  mut builtin = ctx:contextMatchBuiltin(ctx, ptype'name)
  if builtin != null
    return builtin
  /if

  if listContains(recList, ptype'name)
    mut cs = spring:csNew(20)
    spring:csAppendStr(cs, "illegal recursive type ")
    spring:csAppendStr(cs, ptype'name)

    mut msg = spring:csUnleash(cs)
    spring:listAppend(errors, utils:issueNew(utils:ISSUE_ERR, ptype'begin, root'fileName, msg))
    spring:free(msg)

    return null
  /if

  # it's not builtin, so it must be a local alias.
  mut type = findAliasLocal(cast<ptr ast:PNode>(root), ptype'name)
  if type != null
    return type
  /if

  # If here, then it's either undefined, or not validated yet.
  # So, we try to find a valid ptype, or otherwise it's an error.

  mut missingPType ptr ast:PType

  if spring:mapGet(rawAliases, ptype'name, ptr missingPType)
    spring:listPush(recList, ptype'name)
    return validateAlias(ctx, root, rawAliases, ptype, errors, recList)
    spring:listPop(recList)
  /if

  # no match found, error
  mut cs = spring:csNew(20)
  spring:csAppendStr(cs, "no type called ")
  spring:csAppendStr(cs, ptype'name)
  spring:csAppendStr(cs, " in current scope")

  mut msg = spring:csUnleash(cs)
  spring:listAppend(errors, utils:issueNew(utils:ISSUE_ERR, ptype'begin, root'fileName, msg))
  spring:free(msg)

  return null
/func


# Validates a ptr or a loc type alias.
func validatePtrLocAlias(ctx ptr ctx:Context, root ptr ast:PRoot,
    rawAliases ptr spring:Map, ptype ptr ast:PType,
    errors,recList ptr spring:List) ptr ast:Type

  mut ptdes = cast<ptr ast:PTypeDescr>(ptype'descr)

  # validate ptdes'retType

  mut retPType = ptdes'retType
  mut res ptr ast:Type = null

  # if this condition evaluates to true, than we're in the case of a recursive pointer alias.
  if retPType'moduleName == null and retPType'name != null and listContains(recList, retPType'name)
    res = ast:typeNewRecursiveAlias(root'typePool, root'moduleName'name, retPType'name)
  else
    # otherwise, this is a normal type. Validate it with validateAlias.
    res = validateAlias(ctx, root, rawAliases, retPType, errors, recList)
  /if

  if ptdes'type == ast:PTYPE_LOC
    res = ast:typeNewLoc(root'typePool, null, null, ptdes'length, res)
  else
    res = ast:typeNewPtr(root'typePool, null, null, res)
  /if

  return res
/func


# Validates an alias.
func validateAlias(ctx ptr ctx:Context, root ptr ast:PRoot,
    rawAliases ptr spring:Map, ptype ptr ast:PType,
    errors,recList ptr spring:List) ptr ast:Type

  if ptype == null
    return null
  /if

  mut type ptr ast:Type = null

  # first, if the PType refers another module, then it's not our business; just check the module and fetch the type.
  if ptype'moduleName != null

    return validateModuleAlias(ctx, root, rawAliases, ptype, errors)

  else
    # otherwise, it can be a builtin, a local alias or a composite type
    mut ptdes = cast<ptr ast:PTypeDescr>(ptype'descr)

    # if we've found an id, it can be 1. an id type 2. builtin 3. an invalid type
    if ptdes'type == ast:PTYPE_ID
      type = validateIdAlias(ctx, root, rawAliases, ptype, errors, recList)
    else
      if ptdes'type == ast:PTYPE_PTR or ptdes'type == ast:PTYPE_LOC
        type = validatePtrLocAlias(ctx, root, rawAliases, ptype, errors, recList)
      /if
    /if

  /if

  return type
/func


func collectGlobalAliases(root ptr ast:PRoot, errors ptr spring:List) ptr spring:Map
  mut map = spring:strmapNew()

  mut i uintptr = 0
  mut leaves = root'node'node'leaves
  mut len = spring:listLen(leaves)

  while i < len
    mut pdecl = cast<ptr ast:PDecl>(val spring:listGet(leaves, i))

    if pdecl'node'type == ast:PALIAS
      if spring:mapContains(map, pdecl'sym'name)
        spring:mapFree(map)

        mut cs = spring:csNew(20)
        spring:csAppendStr(cs, "alias ")
        spring:csAppendStr(cs, pdecl'sym'name)
        spring:csAppendStr(cs, " is already defined")

        spring:listAppend(errors, utils:issueNew(utils:ISSUE_ERR, pdecl'node'begin, root'fileName, spring:csUnleash(cs)))
      /if

      spring:mapPut(map, pdecl'sym'name, pdecl'sym'type, spring:FREE_NONE)
    /if

    i++
  /while

  return map
/func


func populateGlobalAliasTable(ctx ptr ctx:Context, root ptr ast:PRoot, errors ptr spring:List) bool
  mut aliasMap = collectGlobalAliases(root, errors)

  mut pair ptr spring:Pair

  while (pair = spring:mapFirst(aliasMap)) != null
    mut recList = spring:listNew()
    mut name = cast<ptr uint8>(pair'key)
    mut ptype = cast<ptr ast:PType>(pair'value)

    spring:listPush(recList, name)

    mut type = validateAlias(ctx, root, aliasMap, ptype, errors, recList)

    spring:listPop(recList)

    spring:pairFree(pair)

    if type != null
      ast:stabAdd(root'aliases, name, type)
      spring:mapRemove(aliasMap, name)
    else
      break
    /if
  /while

  spring:mapFree(aliasMap)
/func
