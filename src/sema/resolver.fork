#  Second Step - Experimental Fork Compiler
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2014
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the
#  licenses expressed under Section 1.12 of the MPL v2.


import ast
import base
import ctx
import sema
import utils


func resolverDeinit(rsv sema:Resolver)
  utils:kvFree(rsv'aliases)
  utils:kvFree(rsv'decls)
/func


func resolverCollect(rsv ptr sema:Resolver,
                     ctx ptr ctx:Context,
                     root ptr ast:PRoot,
                     errors ptr base:List) ptr utils:KVList

  rsv'aliases = utils:strkvNew()
  rsv'decls = utils:strkvNew()
  rsv'root = root
  rsv'ctx = ctx

  mut ret = utils:strkvNew()

  utils:kvSetFreeFuncs(ret, ptr base:free, null)

  mut len = base:listLen(root'node'node'leaves)
  mut i uintptr = 0
  mut entryNode ptr ast:PDecl = null

  while i < len
    mut pdecl = cast<ptr ast:PDecl>(val base:listGet(root'node'node'leaves, i))
    mut ntype = pdecl'node'type
    mut name = pdecl'sym'name
    mut kv ptr utils:KVList = null

    if ntype == ast:PDECL or ntype == ast:PMUT or ntype == ast:PFUNCTION
      mut existent ptr ast:PDecl

      if utils:kvGet(rsv'decls, name, ptr existent)
        if pdecl'node'type != ast:PDECL and existent'node'type != ast:PDECL
          resolverDeinit(val rsv)

          mut cs = base:csNew(20)
          base:csAppendStr(cs, "symbol ")
          base:csAppendStr(cs, name)
          base:csAppendStr(cs, " defined twice")

          mut str = base:csUnleash(cs)
          base:listAppend(errors, utils:issueNew(utils:ISSUE_ERR, pdecl'node'begin, root'fileName, str))

          base:free(str)

          return null

        else

          # ignore the decl, reset the value
          if pdecl'node'type == ast:PDECL
            pdecl = existent
          /if
        /if
      /if

      kv = rsv'decls

    else

      if ntype == ast:PALIAS
        if utils:kvContains(rsv'aliases, name)
          resolverDeinit(val rsv)

          mut cs = base:csNew(20)
          base:csAppendStr(cs, "alias ")
          base:csAppendStr(cs, name)
          base:csAppendStr(cs, " is already defined")

          base:listAppend(errors, utils:issueNew(utils:ISSUE_ERR, pdecl'node'begin, root'fileName, base:csUnleash(cs)))

          return null
        /if

        kv = rsv'aliases
      else

        if ntype == ast:PENTRY
          if entryNode == null
            entryNode = pdecl
          else
            base:listAppend(errors, utils:issueNew(utils:ISSUE_ERR, pdecl'node'begin, root'fileName, "entry declared twice in same file"))
            resolverDeinit(val rsv)

            return null
          /if
        else
          base:errln("Unreachable: invalid pdecl value")
          base:abort()
        /if
      /if
    /if

    if ntype != ast:PENTRY
      utils:kvPut(kv, name, pdecl)
    /if

    utils:kvPut(ret, base:strclone(name), pdecl)

    i++
  /while

  return ret
/func
