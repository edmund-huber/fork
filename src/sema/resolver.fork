#  libfork, a base library for the Fork language
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2015
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the
#  licenses expressed under Section 1.12 of the MPL v2.


module sema


import ast
import cs
import kv
import list
import mem
import parser
import proc
import sema
import tty
import utils


func resolverDeinit(rsv ptr sema:Resolver)
  kv:free(rsv'aliases)
  kv:free(rsv'decls)
/func


method sema:Resolver.setCurrentRoot(root ptr ast:PRoot)
  me'curRoot = root
/method


method sema:Resolver.collectAlias(pdecl ptr ast:PDecl,
                                  root ptr ast:PRoot) bool

  mut name = pdecl'sym'name

  if me'aliases.contains(name)

    mut cs = cs:new(20)
    cs.add("alias ")
    cs.add(name)
    cs.add(" is already defined")

    me'issues.error(pdecl'node'begin, root'fileName, cs:unwrap(cs))

    return false
  /if

  me'aliases.put(name, pdecl)

  return true
/method


method sema:Resolver.collectDecls(pdecl ptr ast:PDecl,
                                  root ptr ast:PRoot) bool

  mut name = ast:declKey(pdecl)
  mut existent = <ptr ast:PDecl>(me'decls.get(name))

  if existent?
    mut cs = cs:new(20)
    cs.add("symbol ")
    cs.add(name)
    cs.add(" defined twice in current module")

    mut str = cs:unwrap(cs)
    me'issues.error(pdecl'node'begin, root'fileName, str)

    mem:free(str)
    mem:free(name)

    return false
  /if

  #search for method in module

  me'decls.put(name, pdecl)
  return true
/method


method sema:Resolver.collectPDecl(pnode ptr ast:PNode,
                                  root ptr ast:PRoot,
                                  entryNode ptr ptr ast:PDecl) bool



  if pnode.isMulDecl()
    mut msg = "mut struct expansion is not allowed on global scope"
    me'issues.error(pnode'begin, root'fileName, msg)

    return false
  /if

  # Once we're sure that this isn't a multiple declaration, we are certain it
  # is a PDecl
  mut pdecl = <ptr ast:PDecl>(pnode)

  mut ntype = pdecl'node'type

  if ntype == ast:PMUT or ntype == ast:PFUNCTION or ntype == ast:PMETHOD
    if not me.collectDecls(pdecl, root)
      return false
    /if
  else

    if ntype == ast:PALIAS
      if not me.collectAlias(pdecl, root)
        return false
      /if
    else

      if ntype == ast:PENTRY
        if not (val entryNode)?
          val entryNode = pdecl
        else
          me'issues.error(pdecl'node'begin, root'fileName, \
                          "entry declared twice in same module")

          return false
        /if
      else
        proc:panic("unreachable: invalid pdecl value")
      /if
    /if
  /if

  return true
/method


method sema:Resolver.collectFromRoot(root ptr ast:PRoot,
                                     values ptr kv:KVList,
                                     entryNode ptr ptr ast:PDecl) bool

  mut len = root'node'node'leaves.len()
  mut i uintptr = 0

  while i < len
    mut pnode = <ptr ast:PNode>(val root'node'node'leaves.get(i))

    if not me.collectPDecl(pnode, root, entryNode)

      return false
    /if

    mut pdecl = <ptr ast:PDecl>(pnode)
    values.put(ast:declKey(pdecl), pdecl)

    i++
  /while

  return true
/method


method sema:Resolver.collect(prs ptr parser:Parser,
                             pmod ptr ast:PModule,
                             issues ptr ast:Issues) ptr kv:KVList

  me'aliases = kv:strnew(5)
  me'decls = kv:strnew(10)
  me'issues = issues

  me'prs = prs

  mut ret = kv:strnew(20)

  ret.setFreeFuncs(ptr mem:free, null)

  pmod'entryNode = null

  mut i uintptr = 0
  mut len = pmod'roots.len()

  while i < len
    mut root = <ptr ast:PRoot>(val pmod'roots.get(i))

    if not me.collectFromRoot(root, ret, <ptr ptr ast:PDecl>(ptr pmod'entryNode))
      kv:free(ret)

      return null
    /if

    i++
  /while

  return ret
/method
