#  libfork, a base library for the Fork language
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2015
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the
#  licenses expressed under Section 1.12 of the MPL v2.


import ast
import kv
import list
import mem
import parser
import proc
import sema
import text
import tty
import utils


func resolverDeinit(rsv sema:Resolver)
  kv:kvFree(rsv'aliases)
  kv:kvFree(rsv'decls)
/func


func resolverCollect(rsv ptr sema:Resolver,
                     ctx ptr parser:Context,
                     root ptr ast:PRoot,
                     errors ptr list:List) ptr kv:KVList

  rsv'aliases = kv:strkvNew()
  rsv'decls = kv:strkvNew()
  rsv'root = root
  rsv'ctx = ctx

  mut ret = kv:strkvNew()

  kv:kvSetFreeFuncs(ret, ptr mem:free, null)

  mut len = list:listLen(root'node'node'leaves)
  mut i uintptr = 0
  mut entryNode ptr ast:PDecl = null

  while i < len
    mut pdecl = cast<ptr ast:PDecl>(val list:listGet(root'node'node'leaves, i))
    mut ntype = pdecl'node'type
    mut name = pdecl'sym'name
    mut kv ptr kv:KVList = null

    if ntype == ast:PDECL or ntype == ast:PMUT or ntype == ast:PFUNCTION
      mut existent ptr ast:PDecl

      if kv:kvGet(rsv'decls, name, ptr existent)
        if pdecl'node'type != ast:PDECL and existent'node'type != ast:PDECL
          resolverDeinit(val rsv)

          mut cs = text:csNew(20)
          text:csAppendStr(cs, "symbol ")
          text:csAppendStr(cs, name)
          text:csAppendStr(cs, " defined twice")

          mut str = text:csUnwrap(cs)
          list:listAppend(errors, parser:issueNew(parser:ISSUE_ERR, pdecl'node'begin, root'fileName, str))

          mem:free(str)

          return null

        else

          # ignore the decl, reset the value
          if pdecl'node'type == ast:PDECL
            pdecl = existent
          /if
        /if
      /if

      kv = rsv'decls

    else

      if ntype == ast:PALIAS
        if kv:kvContains(rsv'aliases, name)
          resolverDeinit(val rsv)

          mut cs = text:csNew(20)
          text:csAppendStr(cs, "alias ")
          text:csAppendStr(cs, name)
          text:csAppendStr(cs, " is already defined")

          list:listAppend(errors, parser:issueNew(parser:ISSUE_ERR, pdecl'node'begin, root'fileName, text:csUnwrap(cs)))

          return null
        /if

        kv = rsv'aliases
      else

        if ntype == ast:PENTRY
          if entryNode == null
            entryNode = pdecl
          else
            list:listAppend(errors, parser:issueNew(parser:ISSUE_ERR, pdecl'node'begin, root'fileName, "entry declared twice in same file"))
            resolverDeinit(val rsv)

            return null
          /if
        else
          tty:errln("Unreachable: invalid pdecl value")
          proc:abort()
        /if
      /if
    /if

    if ntype != ast:PENTRY
      kv:kvPut(kv, name, pdecl)
    /if

    kv:kvPut(ret, text:strclone(name), pdecl)

    i++
  /while

  return ret
/func
