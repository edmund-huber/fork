#  libfork, a base library for the Fork language
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2015
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the
#  licenses expressed under Section 1.12 of the MPL v2.


module sema


import ast
import kv
import list
import mem
import parser
import proc
import sema
import tty
import txt
import utils


func resolverDeinit(rsv ptr sema:Resolver)
  kv:free(rsv'aliases)
  kv:free(rsv'decls)
/func


func resolverCollectAlias(rsv ptr sema:Resolver,
                          pdecl ptr ast:PDecl,
                          root ptr ast:PRoot,
                          errors ptr list:List) bool

  mut name = pdecl'sym'name

  if rsv'aliases.contains(name)

    mut cs = txt:csNew(20)
    txt:csAppendStr(cs, "alias ")
    txt:csAppendStr(cs, name)
    txt:csAppendStr(cs, " is already defined")

    errors.append(parser:issueNew(parser:ISSUE_ERR, pdecl'node'begin, root'fileName, txt:csUnwrap(cs)))

    return false
  /if

  rsv'aliases.put(name, pdecl)

  return true
/func


func resolverCollectDecls(rsv ptr sema:Resolver,
                          pdecl ptr ast:PDecl,
                          root ptr ast:PRoot,
                          errors ptr list:List) bool

  mut name = ast:declKey(pdecl)
  mut existent = cast<ptr ast:PDecl>(rsv'decls.get(name))

  if existent?
    mut cs = txt:csNew(20)
    txt:csAppendStr(cs, "symbol ")
    txt:csAppendStr(cs, name)
    txt:csAppendStr(cs, " defined twice")

    mut str = txt:csUnwrap(cs)
    errors.append(parser:issueNew(parser:ISSUE_ERR, pdecl'node'begin, root'fileName, str))

    mem:free(str)
    mem:free(name)

    return false
  /if

  #search for method in module

  rsv'decls.put(name, pdecl)
  return true
/func


func resolverCollect(rsv ptr sema:Resolver,
                     ctx ptr parser:Parser,
                     root ptr ast:PRoot,
                     errors ptr list:List) ptr kv:KVList

  rsv'aliases = kv:strnew(5)
  rsv'decls = kv:strnew(10)

  rsv'root = root
  rsv'ctx = ctx

  mut ret = kv:strnew(20)

  ret.setFreeFuncs(ptr mem:free, null)

  mut len = root'node'node'leaves.len()
  mut i uintptr = 0
  mut entryNode ptr ast:PDecl = null
  mut failure = false

  while i < len
    mut pdecl = cast<ptr ast:PDecl>(val root'node'node'leaves.get(i))
    mut ntype = pdecl'node'type

    if ntype == ast:PMUT or ntype == ast:PFUNCTION or ntype == ast:PMETHOD
      if not resolverCollectDecls(rsv, pdecl, root, errors)
        failure = true
        break
      /if
    else

      if ntype == ast:PALIAS
        if not resolverCollectAlias(rsv, pdecl, root, errors)
          failure = true
          break
        /if
      else

        if ntype == ast:PENTRY
          if entryNode == null
            entryNode = pdecl
          else
            errors.append(parser:issueNew(parser:ISSUE_ERR, pdecl'node'begin, root'fileName, "entry declared twice in same file"))

            failure = true
            break
          /if
        else
          tty:errln("Unreachable: invalid pdecl value")
          proc:abort()
        /if
      /if
    /if

    ret.put(ast:declKey(pdecl), pdecl)

    i++
  /while

  if failure
    kv:free(ret)
    resolverDeinit(rsv)

    return null
  /if

  return ret
/func
