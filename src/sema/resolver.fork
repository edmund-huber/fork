#  libfork, a base library for the Fork language
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2015
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the
#  licenses expressed under Section 1.12 of the MPL v2.


module sema


import ast
import kv
import list
import mem
import parser
import proc
import sema
import tty
import txt
import utils


func resolverDeinit(rsv ptr sema:Resolver)
  kv:kvFree(rsv'aliases)
  kv:kvFree(rsv'decls)
/func


func resolverCollectAlias(rsv ptr sema:Resolver,
                          pdecl ptr ast:PDecl,
                          root ptr ast:PRoot,
                          errors ptr list:List) bool

  mut name = pdecl'sym'name

  if kv:kvContains(rsv'aliases, name)

    mut cs = txt:csNew(20)
    txt:csAppendStr(cs, "alias ")
    txt:csAppendStr(cs, name)
    txt:csAppendStr(cs, " is already defined")

    list:listAppend(errors, parser:issueNew(parser:ISSUE_ERR, pdecl'node'begin, root'fileName, txt:csUnwrap(cs)))

    return false
  /if

  kv:kvPut(rsv'aliases, name, pdecl)

  return true
/func


func resolverCollectDecls(rsv ptr sema:Resolver,
                          pdecl ptr ast:PDecl,
                          root ptr ast:PRoot,
                          errors ptr list:List) bool

  mut existent ptr ast:PDecl
  mut name = ast:declKey(pdecl)

  if kv:kvGet(rsv'decls, name, ptr existent)
    mut cs = txt:csNew(20)
    txt:csAppendStr(cs, "symbol ")
    txt:csAppendStr(cs, name)
    txt:csAppendStr(cs, " defined twice")

    mut str = txt:csUnwrap(cs)
    list:listAppend(errors, parser:issueNew(parser:ISSUE_ERR, pdecl'node'begin, root'fileName, str))

    mem:free(str)
    mem:free(name)

    return false
  /if

  #search for method in module

  kv:kvPut(rsv'decls, name, pdecl)
  return true
/func


func resolverCollect(rsv ptr sema:Resolver,
                     ctx ptr parser:Context,
                     root ptr ast:PRoot,
                     errors ptr list:List) ptr kv:KVList

  rsv'aliases = kv:strkvNew(5)
  rsv'decls = kv:strkvNew(10)

  rsv'root = root
  rsv'ctx = ctx

  mut ret = kv:strkvNew(20)

  kv:kvSetFreeFuncs(ret, ptr mem:free, null)

  mut len = list:listLen(root'node'node'leaves)
  mut i uintptr = 0
  mut entryNode ptr ast:PDecl = null
  mut failure = false

  while i < len
    mut pdecl = cast<ptr ast:PDecl>(val list:listGet(root'node'node'leaves, i))
    mut ntype = pdecl'node'type

    if ntype == ast:PMUT or ntype == ast:PFUNCTION or ntype == ast:PMETHOD
      if !resolverCollectDecls(rsv, pdecl, root, errors)
        failure = true
        break
      /if
    else

      if ntype == ast:PALIAS
        if !resolverCollectAlias(rsv, pdecl, root, errors)
          failure = true
          break
        /if
      else

        if ntype == ast:PENTRY
          if entryNode == null
            entryNode = pdecl
          else
            list:listAppend(errors, parser:issueNew(parser:ISSUE_ERR, pdecl'node'begin, root'fileName, "entry declared twice in same file"))

            failure = true
            break
          /if
        else
          tty:errln("Unreachable: invalid pdecl value")
          proc:abort()
        /if
      /if
    /if

    kv:kvPut(ret, ast:declKey(pdecl), pdecl)

    i++
  /while

  if failure
    kv:kvFree(ret)
    resolverDeinit(rsv)

    return null
  /if

  return ret
/func
