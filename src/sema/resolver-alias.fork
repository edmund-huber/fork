#  Second Step - Experimental Fork Compiler
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2014
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the
#  licenses expressed under Section 1.12 of the MPL v2.


import ast
import ctx
import sema
import spring
import utils


func rootAliasRegister(rsv sema:Resolver, name ptr uint8, type ptr ast:Type)
  type'name = spring:strclone(name)
  type'moduleName = rsv'root'moduleName != null => spring:strclone(rsv'root'moduleName'name) || null
  ast:stabAdd(rsv'root'aliases, name, type)

  mut pdecl ptr ast:PDecl

  utils:kvGet(rsv'aliases, name, ptr pdecl)

  pdecl'node'validated = true

  utils:kvRemove(rsv'aliases, name)
/func


func checkNotFuncType(rsv sema:Resolver, type ptr ast:Type) ptr utils:Issue
  return type'type == ast:TYPE_FUNC => utils:issueNew(utils:ISSUE_ERR, type'begin, rsv'root'fileName, "a function type is not allowed here") || null
/func


decl registerAliasReal func(rsv sema:Resolver,
                           name ptr uint8,
                           ptype ptr ast:PType,
                           recList,errors ptr spring:List,
                           ignoreSize bool) ptr ast:Type

decl resolveTypeReal func(rsv sema:Resolver,
                          ptype ptr ast:PType,
                          recList,errors ptr spring:List,
                          ignSize bool) ptr ast:Type


func convertRetType(rsv sema:Resolver,
                    retPType ptr ast:PType,
                    errors,recList ptr spring:List,
                    isLoc,isPtr bool) ptr ast:Type

  mut res ptr ast:Type = null

  # if this condition evaluates to true, than we're in the case of a recursive alias.
  if !isLoc and retPType'moduleName == null and retPType'name != null and utils:listContains(recList, retPType'name)
    res = ast:typeNewRecursiveAlias(rsv'root'typePool, null, retPType'name)
  else
    # otherwise, this is a normal type. Validate it with validateAlias.
    res = resolveTypeReal(rsv, retPType, errors, recList, isPtr)
  /if

  # if this is not the retType of a ptr, then it's an error having a function
  if res'type == ast:TYPE_FUNC and !isPtr
    spring:listAppend(errors, utils:issueNew(utils:ISSUE_ERR, retPType'begin, rsv'root'fileName, "function types are abstract - use pointers to them"))

    return null
  /if

  return res
/func


# Validates a ptr or a loc type.
func convertPtrLocType(rsv sema:Resolver,
                        ptype ptr ast:PType,
                        errors,recList ptr spring:List) ptr ast:Type

  mut ptdes = cast<ptr ast:PTypeDescr>(ptype'descr)
  mut isLoc = ptdes'type == ast:PTYPE_LOC

  # validate ptdes'retType
  mut res = convertRetType(rsv, ptdes'retType, errors, recList, isLoc, !isLoc)

  if isLoc
    res = ast:typeNewLoc(rsv'root'typePool, null, null, ptdes'length, res)
  else
    res = ast:typeNewPtr(rsv'root'typePool, null, null, res)
  /if

  return res
/func


func convertSymbolList(rsv sema:Resolver,
                       pargs,errors,recList ptr spring:List,
                       funcArgs bool) ptr utils:KVList

  mut errLen = spring:listLen(errors)

  mut plen = spring:listLen(pargs)
  mut i uintptr = 0
  mut members = utils:strkvNew()
  utils:kvSetFreeFuncs(members, ptr spring:free, cast<ptr func(item data)>(ptr ast:typeFree))

  while i < plen
    mut member = cast<ptr ast:PSymbol>(val spring:listGet(pargs, i))
    mut ptype = member'type

    mut type ptr ast:Type = null

    # functions can refer to recursive types, because their arguments and their
    # return types do not affect the size of the function (a function is always sizeless)
    if funcArgs and ptype'moduleName == null and ptype'name != null and utils:listContains(recList, ptype'name)
      type = ast:typeNewRecursiveAlias(rsv'root'typePool, null, ptype'name)
    else
      type = resolveTypeReal(rsv, ptype, errors, recList, false)
    /if

    if type != null
      # if this is not the retType of a ptr, then it's an error having a function
      if type'type == ast:TYPE_FUNC
        spring:listAppend(errors, utils:issueNew(utils:ISSUE_ERR, ptype'begin, rsv'root'fileName, "function types are abstract - use pointers to them"))

        return null
      /if

      utils:kvPut(members, member'name, type)
    /if

    i++
  /while

  if spring:listLen(errors) > errLen
    utils:kvFree(members)
    return null
  /if

  return members
/func


func convertStructType(rsv sema:Resolver,
                       ptype ptr ast:PType,
                       errors,recList ptr spring:List) ptr ast:Type

  mut ptdes = cast<ptr ast:PTypeDescr>(ptype'descr)

  mut members = convertSymbolList(rsv, ptdes'arguments, errors, recList, false)

  return members != null => ast:typeNewStruct(rsv'root'typePool, null, null, members) || null
/func


func convertFuncType(rsv sema:Resolver,
                     ptype ptr ast:PType,
                     errors,recList ptr spring:List) ptr ast:Type

  mut ptdes = cast<ptr ast:PTypeDescr>(ptype'descr)

  mut retVal ptr ast:Type = null
  if ptdes'retType != null
    retVal = convertRetType(rsv, ptdes'retType, errors, recList, false, false)
    if retVal == null
      return null
    /if
  /if

  mut members = convertSymbolList(rsv, ptdes'arguments, errors, recList, true)
  if members == null
    return null
  /if

  return ast:typeNewFunc(rsv'root'typePool, null, null, retVal, members)
/func


func findAliasImport(ctx ptr ctx:Context, moduleName,name ptr uint8) ptr ast:Type
  mut imp = ctx:contextGetImport(ctx, moduleName)
  if imp == null
    return null
  /if

  return ast:stabTypeof(imp'aliases, name)
/func


func findAliasLocal(node ptr ast:PNode, name ptr uint8) ptr ast:Type
  if node == null
    return null
  /if

  if node'type != ast:PROOT
    return findAliasLocal(node'parent, name)
  /if

  mut root = cast<ptr ast:PRoot>(node)

  return ast:stabTypeof(root'aliases, name)
/func


func resolveModuleAlias(rsv sema:Resolver,
                        ptype ptr ast:PType,
                        errors ptr spring:List) ptr ast:Type


  if !ast:prootHasImported(rsv'root, ptype'moduleName)
    mut msg = spring:strappend("no import called ", ptype'moduleName)
    spring:listAppend(errors, utils:issueNew(utils:ISSUE_ERR, ptype'begin, rsv'root'fileName, msg))
    spring:free(msg)

    return null
  /if

  mut type = sema:findAliasImport(rsv'ctx, ptype'moduleName, ptype'name)
  if type != null
    return type
  /if

  # we could not find the type anywhere in the module.
  # Signal the error to the caller.
  mut cs = spring:csNew(20)
  spring:csAppendStr(cs, "no alias called ")
  spring:csAppendStr(cs, ptype'name)
  spring:csAppendStr(cs, " in module ")
  spring:csAppendStr(cs, ptype'moduleName)

  mut msg = spring:csUnleash(cs)
  spring:listAppend(errors, utils:issueNew(utils:ISSUE_ERR, ptype'begin, rsv'root'fileName, msg))
  spring:free(msg)

  return null
/func


func resolveIdType(rsv sema:Resolver,
                    ptype ptr ast:PType,
                    errors, recList ptr spring:List,
                    ignoreSize bool) ptr ast:Type

  mut builtin = ctx:contextMatchBuiltin(rsv'ctx, ptype'name)
  if builtin != null
    return builtin
  /if

  if recList != null and utils:listContains(recList, ptype'name)
    if ignoreSize
      return ast:typeNewRecursiveAlias(rsv'root'typePool, rsv'root'moduleName != null => rsv'root'moduleName'name || null, ptype'name)
    /if

    mut cs = spring:csNew(20)
    spring:csAppendStr(cs, "alias declaration makes type ")
    spring:csAppendStr(cs, ptype'name)
    spring:csAppendStr(cs, " recursive")
    spring:csAppend(cs, 32)
    utils:listDumpHierarchyIntoCS(recList, cs)

    mut msg = spring:csUnleash(cs)
    spring:listAppend(errors, utils:issueNew(utils:ISSUE_ERR, ptype'begin, rsv'root'fileName, msg))
    spring:free(msg)

    return null
  /if

  # it's not builtin, so it must be a local alias.
  mut type = sema:findAliasLocal(cast<ptr ast:PNode>(rsv'root), ptype'name)
  if type != null
    return type
  /if

  # If here, then it's either undefined, or not validated yet.
  # So, we try to find a valid ptype, or otherwise it's an error.

  mut whichDecl ptr ast:PDecl
  mut missingPType ptr ast:PType

  if utils:kvGet(rsv'aliases, ptype'name, ptr whichDecl)
    if whichDecl'node'validated
      spring:errln("This should not be reachable")
      spring:abort()
    /if

    return registerAliasReal(rsv, ptype'name, whichDecl'sym'type, recList, errors, ignoreSize)
  /if

  # no match found, error
  mut cs = spring:csNew(20)
  spring:csAppendStr(cs, "no type called ")
  spring:csAppendStr(cs, ptype'name)
  spring:csAppendStr(cs, " in current scope")

  mut msg = spring:csUnleash(cs)
  spring:listAppend(errors, utils:issueNew(utils:ISSUE_ERR, ptype'begin, rsv'root'fileName, msg))
  spring:free(msg)

  return null
/func


func convertType(rsv sema:Resolver,
                 ptype ptr ast:PType,
                 recList,errors ptr spring:List,
                 ignoreSize bool) ptr ast:Type

  mut ptdes = cast<ptr ast:PTypeDescr>(ptype'descr)

  # if we've found an id, it can be 1. an id type 2. builtin 3. an invalid type
  if ptdes'type == ast:PTYPE_ID
    return resolveIdType(rsv, ptype, errors, recList, ignoreSize)
  else
    if ptdes'type == ast:PTYPE_PTR or ptdes'type == ast:PTYPE_LOC
      return convertPtrLocType(rsv, ptype, errors, recList)
    else
      if ptdes'type == ast:PTYPE_STRUCT
        return convertStructType(rsv, ptype, errors, recList)
      else
        if ptdes'type == ast:PTYPE_FUNC
          return convertFuncType(rsv, ptype, errors, recList)
        else
          spring:errln("Unreachable")
          spring:abort()
        /if
      /if
    /if
  /if

  # unreachable
  return null
/func


func resolveTypeReal(rsv sema:Resolver,
                     ptype ptr ast:PType,
                     recList,errors ptr spring:List,
                     ignSize bool) ptr ast:Type

  return ptype'moduleName != null => resolveModuleAlias(rsv, ptype, errors) || convertType(rsv, ptype, recList, errors, ignSize)
/func


func registerAliasReal(rsv sema:Resolver,
                      name ptr uint8,
                      ptype ptr ast:PType,
                      recList,errors ptr spring:List,
                      ignSize bool) ptr ast:Type

  mut needsList = recList == null

  if needsList
    recList = spring:listNew()
  /if


  spring:listPush(recList, name)
  mut ret = resolveTypeReal(rsv, ptype, recList, errors, ignSize)
  spring:listPop(recList)

  if ret != null
    rootAliasRegister(rsv, name, ret)
  /if


  if needsList
    spring:listFree(recList)
  /if

  return ret
/func


func registerAlias(rsv sema:Resolver,
                  pdecl ptr ast:PDecl,
                  errors ptr spring:List) ptr ast:Type

  mut recList spring:List
  spring:listInit(ptr recList)

  mut ret = registerAliasReal(rsv, pdecl'sym'name, pdecl'sym'type, ptr recList, errors, false)

  spring:listDeinit(ptr recList)

  return ret
/func


func resolveType(rsv sema:Resolver,
                 ptype ptr ast:PType,
                 errors ptr spring:List) ptr ast:Type

  return resolveTypeReal(rsv, ptype, null, errors, false)
/func
