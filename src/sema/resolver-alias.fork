#  libfork, a base library for the Fork language
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2015
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the
#  licenses expressed under Section 1.12 of the MPL v2.


import ast
import astfn
import kv
import list
import mem
import parser
import proc
import sema
import text
import tty
import utils


func rootAliasRegister(rsv sema:Resolver, name ptr uint8, type ptr ast:Type)
  type'name = text:strclone(name)
  type'moduleName = rsv'root'moduleName != null => text:strclone(rsv'root'moduleName'name) || null
  ast:stabAdd(rsv'root'aliases, name, type, ast:PALIAS)

  mut pdecl ptr ast:PDecl

  kv:kvGet(rsv'aliases, name, ptr pdecl)

  pdecl'node'validated = true

  kv:kvRemove(rsv'aliases, name)
/func


func checkNotFuncType(rsv sema:Resolver, type ptr ast:Type) ptr parser:Issue
  return type'type == ast:TYPE_FUNC => parser:issueNew(parser:ISSUE_ERR, type'begin, rsv'root'fileName, "a function type is not allowed here") || null
/func


decl registerAliasReal func(rsv sema:Resolver,
                           name ptr uint8,
                           ptype ptr ast:PType,
                           recList,errors ptr list:List,
                           ignoreSize bool) ptr ast:Type

decl resolveTypeReal func(rsv sema:Resolver,
                          ptype ptr ast:PType,
                          recList,errors ptr list:List,
                          ignSize bool) ptr ast:Type


func convertRetType(rsv sema:Resolver,
                    retPType ptr ast:PType,
                    errors,recList ptr list:List,
                    isLoc,isPtr bool) ptr ast:Type

  mut res ptr ast:Type = null

  # if this condition evaluates to true, than we're in the case of a recursive alias.
  if !isLoc and retPType'moduleName == null and retPType'name != null and recList != null and utils:listContains(recList, retPType'name)
    res = astfn:typeNewRecursiveAlias(rsv'root'typePool, rsv'root'moduleName'name, retPType'name)
  else
    # otherwise, this is a normal type. Validate it with validateAlias.
    res = resolveTypeReal(rsv, retPType, recList, errors, isPtr)
  /if

  # if this is not the retType of a ptr, then it's an error having a function
  if res != null and res'type == ast:TYPE_FUNC and !isPtr
    list:listAppend(errors, parser:issueNew(parser:ISSUE_ERR, retPType'begin, rsv'root'fileName, "function types are abstract - use pointers to them"))

    return null
  /if

  return res
/func


# Validates a ptr or a loc type.
func convertPtrLocType(rsv sema:Resolver,
                        ptype ptr ast:PType,
                        errors,recList ptr list:List) ptr ast:Type

  mut ptdes = cast<ptr ast:PTypeDescr>(ptype'descr)
  mut isLoc = ptdes'type == ast:PTYPE_LOC

  # validate ptdes'retType
  mut res = convertRetType(rsv, ptdes'retType, errors, recList, isLoc, !isLoc)

  if res == null
    return null
  /if

  if isLoc
    res = astfn:typeNewLoc(rsv'root'typePool, null, null, ptdes'length, res)
  else
    res = astfn:typeNewPtr(rsv'root'typePool, null, null, res)
  /if

  return res
/func


func convertSymbolList(rsv sema:Resolver,
                       pargs,errors,recList ptr list:List,
                       funcArgs bool) ptr kv:KVList


  mut members = kv:strkvNew()

  if pargs == null
    return members
  /if

  mut errLen = list:listLen(errors)

  mut plen = list:listLen(pargs)
  mut i uintptr = 0
  kv:kvSetFreeFuncs(members, ptr mem:free, null)

  while i < plen
    mut member = cast<ptr ast:PSymbol>(val list:listGet(pargs, i))
    mut ptype = member'type

    mut type ptr ast:Type = null

    # functions can refer to recursive types, because their arguments and their
    # return types do not affect the size of the function (a function is always sizeless)
    if funcArgs and ptype'moduleName == null and ptype'name != null and recList != null and utils:listContains(recList, ptype'name)
      type = astfn:typeNewRecursiveAlias(rsv'root'typePool, rsv'root'moduleName'name, ptype'name)
    else
      type = resolveTypeReal(rsv, ptype, recList, errors, false)
    /if

    if type != null
      # if this is not the retType of a ptr, then it's an error having a function
      if type'type == ast:TYPE_FUNC
        list:listAppend(errors, parser:issueNew(parser:ISSUE_ERR, ptype'begin, rsv'root'fileName, "function types are abstract - use pointers to them"))

        return null
      /if

      kv:kvPut(members, member'name, type)
    /if

    i++
  /while

  if list:listLen(errors) > errLen
    kv:kvFree(members)
    return null
  /if

  return members
/func


func convertStructType(rsv sema:Resolver,
                       ptype ptr ast:PType,
                       errors,recList ptr list:List) ptr ast:Type

  mut ptdes = cast<ptr ast:PTypeDescr>(ptype'descr)

  mut members = convertSymbolList(rsv, ptdes'arguments, errors, recList, false)

  return members != null => astfn:typeNewStruct(rsv'root'typePool, null, null, members) || null
/func


func convertFuncType(rsv sema:Resolver,
                     ptype ptr ast:PType,
                     errors,recList ptr list:List) ptr ast:Type

  mut ptdes = cast<ptr ast:PTypeDescr>(ptype'descr)

  mut retVal ptr ast:Type = null
  if ptdes'retType != null
    retVal = convertRetType(rsv, ptdes'retType, errors, recList, false, false)
    if retVal == null
      return null
    /if
  /if

  mut members = convertSymbolList(rsv, ptdes'arguments, errors, recList, true)
  if members == null
    return null
  /if

  return astfn:typeNewFunc(rsv'root'typePool, null, null, retVal, members)
/func


func findAliasImport(ctx ptr parser:Context, moduleName,name ptr uint8) ptr ast:Type
  mut imp = parser:ctxGetImport(ctx, moduleName)
  if imp == null
    return null
  /if

  return ast:stabTypeof(imp'aliases, name)
/func


func findAliasLocal(node ptr ast:PNode, name ptr uint8) ptr ast:Type
  if node == null
    return null
  /if

  if node'type != ast:PROOT
    return findAliasLocal(node'parent, name)
  /if

  mut root = cast<ptr ast:PRoot>(node)

  return ast:stabTypeof(root'aliases, name)
/func


func resolveModuleAlias(rsv sema:Resolver,
                        ptype ptr ast:PType,
                        errors ptr list:List) ptr ast:Type


  if !ast:prootHasImported(rsv'root, ptype'moduleName)
    mut msg = text:strappend("no import called ", ptype'moduleName)
    list:listAppend(errors, parser:issueNew(parser:ISSUE_ERR, ptype'begin, rsv'root'fileName, msg))
    mem:free(msg)

    return null
  /if

  mut type = sema:findAliasImport(rsv'ctx, ptype'moduleName, ptype'name)
  if type != null
    return astfn:typeClone(rsv'root'typePool, type)
  /if

  # we could not find the type anywhere in the module.
  # Signal the error to the caller.
  mut cs = text:csNew(20)
  text:csAppendStr(cs, "no alias called ")
  text:csAppendStr(cs, ptype'name)
  text:csAppendStr(cs, " in module ")
  text:csAppendStr(cs, ptype'moduleName)

  mut msg = text:csUnwrap(cs)
  list:listAppend(errors, parser:issueNew(parser:ISSUE_ERR, ptype'begin, rsv'root'fileName, msg))
  mem:free(msg)

  return null
/func


func resolveIdType(rsv sema:Resolver,
                    ptype ptr ast:PType,
                    errors, recList ptr list:List,
                    ignoreSize bool) ptr ast:Type

  mut builtin = parser:ctxMatchBuiltin(rsv'ctx, ptype'name)
  if builtin != null
    return astfn:typeClone(rsv'root'typePool, builtin)
  /if

  if recList != null and utils:listContains(recList, ptype'name)
    if ignoreSize
      return astfn:typeNewRecursiveAlias(rsv'root'typePool, rsv'root'moduleName != null => rsv'root'moduleName'name || null, ptype'name)
    /if

    mut cs = text:csNew(20)
    text:csAppendStr(cs, "alias declaration makes type ")
    text:csAppendStr(cs, ptype'name)
    text:csAppendStr(cs, " recursive")
    text:csAppend(cs, 32)
    utils:listDumpHierarchyIntoCS(recList, cs)

    mut msg = text:csUnwrap(cs)
    list:listAppend(errors, parser:issueNew(parser:ISSUE_ERR, ptype'begin, rsv'root'fileName, msg))
    mem:free(msg)

    return null
  /if

  # it's not builtin, so it must be a local alias.
  mut type = sema:findAliasLocal(cast<ptr ast:PNode>(rsv'root), ptype'name)
  if type != null
    return astfn:typeClone(rsv'root'typePool, type)
  /if

  # If here, then it's either undefined, or not validated yet.
  # So, we try to find a valid ptype, or otherwise it's an error.

  mut whichDecl ptr ast:PDecl
  mut missingPType ptr ast:PType

  if kv:kvGet(rsv'aliases, ptype'name, ptr whichDecl)
    if whichDecl'node'validated
      tty:errln("This should not be reachable")
      proc:abort()
    /if

    return registerAliasReal(rsv, ptype'name, whichDecl'sym'type, recList, errors, ignoreSize)
  /if

  # no match found, error
  mut cs = text:csNew(20)
  text:csAppendStr(cs, "no type called ")
  text:csAppendStr(cs, ptype'name)
  text:csAppendStr(cs, " in current scope")

  mut msg = text:csUnwrap(cs)
  list:listAppend(errors, parser:issueNew(parser:ISSUE_ERR, ptype'begin, rsv'root'fileName, msg))
  mem:free(msg)

  return null
/func


func convertType(rsv sema:Resolver,
                 ptype ptr ast:PType,
                 recList,errors ptr list:List,
                 ignoreSize bool) ptr ast:Type

  mut ptdes = cast<ptr ast:PTypeDescr>(ptype'descr)

  # if we've found an id, it can be 1. an id type 2. builtin 3. an invalid type
  if ptdes'type == ast:PTYPE_ID
    return resolveIdType(rsv, ptype, errors, recList, ignoreSize)
  else
    if ptdes'type == ast:PTYPE_PTR or ptdes'type == ast:PTYPE_LOC
      return convertPtrLocType(rsv, ptype, errors, recList)
    else
      if ptdes'type == ast:PTYPE_STRUCT
        return convertStructType(rsv, ptype, errors, recList)
      else
        if ptdes'type == ast:PTYPE_FUNC
          return convertFuncType(rsv, ptype, errors, recList)
        else
          tty:errln("Unreachable")
          proc:abort()
        /if
      /if
    /if
  /if

  # unreachable
  return null
/func


func resolveTypeReal(rsv sema:Resolver,
                     ptype ptr ast:PType,
                     recList,errors ptr list:List,
                     ignSize bool) ptr ast:Type

  return ptype'moduleName != null => resolveModuleAlias(rsv, ptype, errors) || convertType(rsv, ptype, recList, errors, ignSize)
/func


func registerAliasReal(rsv sema:Resolver,
                      name ptr uint8,
                      ptype ptr ast:PType,
                      recList,errors ptr list:List,
                      ignSize bool) ptr ast:Type

  mut needsList = recList == null

  if needsList
    recList = list:listNew()
  /if


  list:listPush(recList, name)
  mut ret = resolveTypeReal(rsv, ptype, recList, errors, ignSize)
  list:listPop(recList)

  if ret != null
    rootAliasRegister(rsv, name, ret)
  /if


  if needsList
    list:listFree(recList)
  /if

  return ret
/func


func registerAlias(rsv sema:Resolver,
                  pdecl ptr ast:PDecl,
                  errors ptr list:List) ptr ast:Type

  mut recList list:List
  list:listInit(ptr recList)

  mut ret = registerAliasReal(rsv, pdecl'sym'name, pdecl'sym'type, ptr recList, errors, false)

  list:listDeinit(ptr recList)

  return ret
/func


func resolveType(rsv sema:Resolver,
                 ptype ptr ast:PType,
                 errors ptr list:List) ptr ast:Type

  return resolveTypeReal(rsv, ptype, null, errors, false)
/func
