#  libfork, a base library for the Fork language
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2015
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the
#  licenses expressed under Section 1.12 of the MPL v2.


module sema


import ast
import astfn
import kv
import list
import mem
import parser
import proc
import sema
import tty
import txt
import utils


func rootAliasRegister(rsv sema:Resolver, name ptr uint8, type ptr ast:Type)
  type'name = txt:strclone(name)
  type'moduleName = rsv'root'moduleName != null => txt:strclone(rsv'root'moduleName'name) || null
  ast:stabAdd(rsv'root'aliases, name, false, type, ast:PALIAS)

  mut pdecl = cast<ptr ast:PDecl>(rsv'aliases.get(name))

  pdecl'node'validated = true

  rsv'aliases.remove(name)
/func


func checkNotFuncType(rsv sema:Resolver, type ptr ast:Type) ptr parser:Issue
  return type'type == ast:TYPE_FUNC => parser:issueNew(parser:ISSUE_ERR, type'begin, rsv'root'fileName, "a function type is not allowed here") || null
/func


func convertRetType(rsv sema:Resolver,
                    retPType ptr ast:PType,
                    errors,recList ptr list:List,
                    isLoc,isPtr bool) ptr ast:Type

  mut res ptr ast:Type = null

  # if this condition evaluates to true, than we're in the case of a recursive alias.
  if not isLoc and retPType'moduleName == null and retPType'name != null and recList != null and utils:listContains(recList, retPType'name)
    res = astfn:typeNewRecursiveAlias(rsv'root'typePool, rsv'root'moduleName'name, retPType'name)
  else
    # otherwise, this is a normal type. Validate it with validateAlias.
    res = resolveTypeReal(rsv, retPType, recList, errors, isPtr)
  /if

  # if this is not the retType of a ptr, then it's an error having a function
  if res != null and res'type == ast:TYPE_FUNC and not isPtr
    errors.append(parser:issueNew(parser:ISSUE_ERR, retPType'begin, rsv'root'fileName, "function types are abstract - use pointers to them"))

    return null
  /if

  return res
/func


# Validates a ptr or a loc type.
func convertPtrLocType(rsv sema:Resolver,
                        ptype ptr ast:PType,
                        errors,recList ptr list:List) ptr ast:Type

  mut ptdes = ptype'descr
  mut isLoc = ptdes'type == ast:PTYPE_LOC

  # validate ptdes'retType
  mut res = convertRetType(rsv, ptdes'retType, errors, recList, isLoc, not isLoc)

  if res == null
    return null
  /if

  if isLoc
    res = astfn:typeNewLoc(rsv'root'typePool, null, null, ptdes'length, res)
  else
    res = astfn:typeNewPtr(rsv'root'typePool, null, null, res)
  /if

  return res
/func


func convertSymbolList(rsv sema:Resolver,
                       pargs,errors,recList ptr list:List,
                       funcArgs bool) ptr kv:KVList



  if pargs == null
    return kv:strnew(0)
  /if

  mut plen = pargs.len()
  mut errLen = errors.len()
  mut i uintptr = 0

  mut members = kv:strnew(plen)
  members.setFreeFuncs(ptr mem:free, null)

  while i < plen
    mut member = cast<ptr ast:PSymbol>(val pargs.get(i))
    mut ptype = member'type

    mut type ptr ast:Type = null

    # functions can refer to recursive types, because their arguments and their
    # return types do not affect the size of the function (a function is always sizeless)
    if funcArgs and ptype'moduleName == null and ptype'name != null and recList != null and utils:listContains(recList, ptype'name)
      type = astfn:typeNewRecursiveAlias(rsv'root'typePool, rsv'root'moduleName'name, ptype'name)
    else
      type = resolveTypeReal(rsv, ptype, recList, errors, false)
    /if

    if type?
      # if this is not the retType of a ptr, then it's an error having a function
      if type'type == ast:TYPE_FUNC
        errors.append(parser:issueNew(parser:ISSUE_ERR, ptype'begin, rsv'root'fileName, "function types are abstract - use pointers to them"))

        return null
      /if

      members.put(txt:strclone(member'name), type)
    /if

    i++
  /while

  if errors.len() > errLen
    kv:free(members)
    return null
  /if

  return members
/func


func convertStructType(rsv sema:Resolver,
                       ptype ptr ast:PType,
                       errors,recList ptr list:List) ptr ast:Type

  mut ptdes = ptype'descr

  mut members = convertSymbolList(rsv, ptdes'arguments, errors, recList, false)

  return members? => astfn:typeNewStruct(rsv'root'typePool, null, null, members) || null
/func


func convertFuncType(rsv sema:Resolver,
                     ptype ptr ast:PType,
                     errors,recList ptr list:List) ptr ast:Type

  mut ptdes = ptype'descr

  mut retVal ptr ast:Type = null
  if ptdes'retType?
    retVal = convertRetType(rsv, ptdes'retType, errors, recList, false, false)
    if not retVal?
      return null
    /if
  /if

  mut members = convertSymbolList(rsv, ptdes'arguments, errors, recList, true)
  if not members?
    return null
  /if

  return astfn:typeNewFunc(rsv'root'typePool, null, null, retVal, members)
/func


func findAliasImport(ctx ptr parser:Parser, moduleName,name ptr uint8) ptr ast:Type
  mut imp = ctx.getImport(moduleName)
  if not imp?
    return null
  /if

  return ast:stabTypeof(imp'aliases, name)
/func


func findAliasLocal(node ptr ast:PNode, name ptr uint8) ptr ast:Type
  if not node?
    return null
  /if

  if node'type != ast:PROOT
    return findAliasLocal(node'parent, name)
  /if

  mut root = cast<ptr ast:PRoot>(node)

  return ast:stabTypeof(root'aliases, name)
/func


func resolveModuleAlias(rsv sema:Resolver,
                        ptype ptr ast:PType,
                        errors ptr list:List) ptr ast:Type


  if not ast:prootHasImported(rsv'root, ptype'moduleName)
    mut msg = txt:strappend("no import called ", ptype'moduleName)
    errors.append(parser:issueNew(parser:ISSUE_ERR, ptype'begin, rsv'root'fileName, msg))
    mem:free(msg)

    return null
  /if

  mut type = sema:findAliasImport(rsv'ctx, ptype'moduleName, ptype'name)
  if type?
    return astfn:typeClone(rsv'root'typePool, type)
  /if

  # we could not find the type anywhere in the module.
  # Signal the error to the caller.
  mut cs = txt:csNew(20)
  txt:csAppendStr(cs, "no alias called ")
  txt:csAppendStr(cs, ptype'name)
  txt:csAppendStr(cs, " in module ")
  txt:csAppendStr(cs, ptype'moduleName)

  mut msg = txt:csUnwrap(cs)
  errors.append(parser:issueNew(parser:ISSUE_ERR, ptype'begin, rsv'root'fileName, msg))
  mem:free(msg)

  return null
/func


func resolveIdType(rsv sema:Resolver,
                    ptype ptr ast:PType,
                    errors, recList ptr list:List,
                    ignoreSize bool) ptr ast:Type

  mut builtin = rsv'ctx.matchBuiltin(ptype'name)
  if builtin?
    return astfn:typeClone(rsv'root'typePool, builtin)
  /if

  if recList != null and utils:listContains(recList, ptype'name)
    if ignoreSize
      return astfn:typeNewRecursiveAlias(rsv'root'typePool, rsv'root'moduleName != null => rsv'root'moduleName'name || null, ptype'name)
    /if

    mut cs = txt:csNew(20)
    txt:csAppendStr(cs, "alias declaration makes type ")
    txt:csAppendStr(cs, ptype'name)
    txt:csAppendStr(cs, " recursive")
    txt:csAppend(cs, 32)
    utils:listDumpHierarchyIntoCS(recList, cs)

    mut msg = txt:csUnwrap(cs)
    errors.append(parser:issueNew(parser:ISSUE_ERR, ptype'begin, rsv'root'fileName, msg))
    mem:free(msg)

    return null
  /if

  # it's not builtin, so it must be a local alias.
  mut type = sema:findAliasLocal(cast<ptr ast:PNode>(rsv'root), ptype'name)
  if type?
    return astfn:typeClone(rsv'root'typePool, type)
  /if

  # If here, then it's either undefined, or not validated yet.
  # So, we try to find a valid ptype, or otherwise it's an error.

  mut missingPType ptr ast:PType
  mut whichDecl = cast<ptr ast:PDecl>(rsv'aliases.get(ptype'name))

  if whichDecl?
    if whichDecl'node'validated
      tty:errln("This should not be reachable")
      proc:abort()
    /if

    return registerAliasReal(rsv, ptype'name, whichDecl'sym'type, recList, errors, ignoreSize)
  /if

  # no match found, error
  mut cs = txt:csNew(20)
  txt:csAppendStr(cs, "no type called ")
  txt:csAppendStr(cs, ptype'name)
  txt:csAppendStr(cs, " in current scope")

  mut msg = txt:csUnwrap(cs)
  errors.append(parser:issueNew(parser:ISSUE_ERR, ptype'begin, rsv'root'fileName, msg))
  mem:free(msg)

  return null
/func


func convertType(rsv sema:Resolver,
                 ptype ptr ast:PType,
                 recList,errors ptr list:List,
                 ignoreSize bool) ptr ast:Type

  mut ptdes = ptype'descr

  # if we've found an id, it can be 1. an id type 2. builtin 3. an invalid type
  if ptdes'type == ast:PTYPE_ID
    return resolveIdType(rsv, ptype, errors, recList, ignoreSize)
  else
    if ptdes'type == ast:PTYPE_PTR or ptdes'type == ast:PTYPE_LOC
      return convertPtrLocType(rsv, ptype, errors, recList)
    else
      if ptdes'type == ast:PTYPE_STRUCT
        return convertStructType(rsv, ptype, errors, recList)
      else
        if ptdes'type == ast:PTYPE_FUNC
          return convertFuncType(rsv, ptype, errors, recList)
        else
          tty:errln("Unreachable")
          proc:abort()
        /if
      /if
    /if
  /if

  # unreachable
  return null
/func


func resolveTypeReal(rsv sema:Resolver,
                     ptype ptr ast:PType,
                     recList,errors ptr list:List,
                     ignSize bool) ptr ast:Type

  return ptype'moduleName != null => resolveModuleAlias(rsv, ptype, errors) || convertType(rsv, ptype, recList, errors, ignSize)
/func


func registerAliasReal(rsv sema:Resolver,
                      name ptr uint8,
                      ptype ptr ast:PType,
                      recList,errors ptr list:List,
                      ignSize bool) ptr ast:Type

  mut needsList = recList == null

  if needsList
    recList = list:new()
  /if


  recList.push(name)
  mut ret = resolveTypeReal(rsv, ptype, recList, errors, ignSize)
  recList.pop()

  if ret != null
    rootAliasRegister(rsv, name, ret)
  /if


  if needsList
    list:free(recList)
  /if

  return ret
/func


func registerAlias(rsv sema:Resolver,
                  pdecl ptr ast:PDecl,
                  errors ptr list:List) ptr ast:Type

  mut recList list:List
  list:init(ptr recList)

  mut ret = registerAliasReal(rsv, pdecl'sym'name, pdecl'sym'type, ptr recList, errors, false)

  list:deinit(ptr recList)

  return ret
/func


func resolveType(rsv sema:Resolver,
                 ptype ptr ast:PType,
                 errors ptr list:List) ptr ast:Type

  return resolveTypeReal(rsv, ptype, null, errors, false)
/func


func resolveTypeName(rsv sema:Resolver,
                     name ptr uint8,
                     errors ptr list:List) ptr ast:Type

  mut ptd = astfn:ptypeDescrNew(ast:PTYPE_ID, null, null)
  mut ptype = astfn:ptypeNew(name, null, ptd)

  mut ret = sema:resolveType(rsv, ptype, errors)

  mem:decRef(ptype)

  return ret
/func
