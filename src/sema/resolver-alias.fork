#  libfork, a base library for the Fork language
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2015
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the
#  licenses expressed under Section 1.12 of the MPL v2.


module sema


import ast
import astfn
import cs
import kv
import list
import mem
import parser
import proc
import sema
import tty
import txt
import utils


method ast:PNode.findAliasLocal(name ptr uint8) ptr ast:Type
  return me.findPRoot()'aliases.typeof(name)
/method


method sema:Resolver.rootAliasRegister(name ptr uint8, type ptr ast:Type)
  type'name = txt:strclone(name)
  type'moduleName = me'curRoot'moduleName? => txt:strclone(me'curRoot'moduleName'name) || null
  me'curRoot'aliases.add(name, false, false, type, ast:PALIAS)

  mut pdecl = <ptr ast:PDecl>(me'aliases.get(name))

  pdecl'node'validated = true

  me'aliases.remove(name)
/method


method sema:Resolver.checkNotFuncType(type ptr ast:Type) ptr parser:Issue
  return type'type == ast:TYPE_FUNC => parser:issueNew(parser:ISSUE_ERR, type'begin, me'curRoot'fileName, "a function type is not allowed here") || null
/method


method sema:Resolver.convertRetType(retPType ptr ast:PType,
                                    recList ptr list:List,
                                    isLoc,isPtr bool) ptr ast:Type

  mut res ptr ast:Type = null

  # if this condition evaluates to true, than we're in the case of a recursive alias.
  if not isLoc and not retPType'moduleName? and retPType'name? and recList? and utils:listContains(recList, retPType'name)
    res = astfn:typeNewRecursiveAlias(me'curRoot'typePool, me'curRoot'moduleName'name, retPType'name)
  else
    # otherwise, this is a normal type. Validate it with validateAlias.
    res = me.resolveTypeReal(retPType, recList, isPtr)
  /if

  # if this is not the retType of a ptr, then it's an error having a function
  if res? and res'type == ast:TYPE_FUNC and not isPtr
    me'errs.append(parser:issueNew(parser:ISSUE_ERR, retPType'begin, me'curRoot'fileName, "function types are abstract - use pointers to them"))

    return null
  /if

  return res
/method


# Validates a ptr or a loc type.
method sema:Resolver.convertPtrLocType(ptype ptr ast:PType,
                                       recList ptr list:List) ptr ast:Type

  mut ptdes = ptype'descr
  mut isLoc = ptdes'type == ast:PTYPE_LOC

  # validate ptdes'retType
  mut res = me.convertRetType(ptdes'retType, recList, isLoc, not isLoc)

  if not res?
    return null
  /if

  if isLoc
    res = astfn:typeNewLoc(me'curRoot'typePool, null, null, ptdes'length, res)
  else
    res = astfn:typeNewPtr(me'curRoot'typePool, null, null, res)
  /if

  return res
/method


method sema:Resolver.convertSymbolList(pargs,recList ptr list:List,
                                       funcArgs bool) ptr kv:KVList

  if not pargs?
    return kv:strnew(0)
  /if

  mut plen = pargs.len()
  mut errLen = me'errs.len()
  mut i uintptr = 0

  mut members = kv:strnew(plen)
  members.setFreeFuncs(ptr mem:free, null)

  while i < plen
    mut member = <ptr ast:PSymbol>(val pargs.get(i))
    mut ptype = member'type

    mut type ptr ast:Type = null

    # functions can refer to recursive types, because their arguments and their
    # return types do not affect the size of the function (a function is always sizeless)
    if funcArgs and not ptype'moduleName? and ptype'name? and recList? and utils:listContains(recList, ptype'name)
      type = astfn:typeNewRecursiveAlias(me'curRoot'typePool, me'curRoot'moduleName'name, ptype'name)
    else
      type = me.resolveTypeReal(ptype, recList, false)
    /if

    if type?
      # if this is not the retType of a ptr, then it's an error having a function
      if type'type == ast:TYPE_FUNC
        me'errs.append(parser:issueNew(parser:ISSUE_ERR, ptype'begin, me'curRoot'fileName, "function types are abstract - use pointers to them"))

        kv:free(members)

        return null
      /if

      members.put(txt:strclone(member'name), type)
    /if

    i++
  /while

  if me'errs.len() > errLen
    kv:free(members)
    return null
  /if

  return members
/method


method sema:Resolver.convertStructType(ptype ptr ast:PType,
                                       recList ptr list:List) ptr ast:Type

  mut ptdes = ptype'descr

  mut members = me.convertSymbolList(ptdes'arguments, recList, false)

  return members? => astfn:typeNewStruct(me'curRoot'typePool, null, null, members) || null
/method


method sema:Resolver.convertFuncType(ptype ptr ast:PType,
                                     recList ptr list:List) ptr ast:Type

  mut ptdes = ptype'descr

  mut retVal ptr ast:Type = null
  if ptdes'retType?
    retVal = me.convertRetType(ptdes'retType, recList, false, false)
    if not retVal?
      return null
    /if
  /if

  mut members = me.convertSymbolList(ptdes'arguments, recList, true)
  if not members?
    return null
  /if

  return astfn:typeNewFunc(me'curRoot'typePool, null, null, retVal, members)
/method


method sema:Resolver.findAliasImport(moduleName,name ptr uint8) ptr ast:Type
  mut imp = me'prs.getImport(moduleName)
  if not imp?
    return null
  /if

  return imp'aliases.typeof(name)
/method


method sema:Resolver.resolveModuleAlias(ptype ptr ast:PType) ptr ast:Type

  if not me'curRoot.hasImported(ptype'moduleName)
    mut msg = txt:strappend("no import called ", ptype'moduleName)
    me'errs.append(parser:issueNew(parser:ISSUE_ERR, ptype'begin, me'curRoot'fileName, msg))
    mem:free(msg)

    return null
  /if

  mut type = me.findAliasImport(ptype'moduleName, ptype'name)
  if type?
    return astfn:typeClone(me'curRoot'typePool, type)
  /if

  # we could not find the type anywhere in the module.
  # Signal the error to the caller.
  mut cs = cs:new(20)
  cs.add("no alias called ")
  cs.add(ptype'name)
  cs.add(" in module ")
  cs.add(ptype'moduleName)

  mut msg = cs:unwrap(cs)
  me'errs.append(parser:issueNew(parser:ISSUE_ERR, ptype'begin, me'curRoot'fileName, msg))
  mem:free(msg)

  return null
/method


method sema:Resolver.resolveIdType(ptype ptr ast:PType,
                                   recList ptr list:List,
                                   ignoreSize bool) ptr ast:Type

  mut builtin = me'prs.matchBuiltin(ptype'name)
  if builtin?
    return astfn:typeClone(me'curRoot'typePool, builtin)
  /if

  if recList? and utils:listContains(recList, ptype'name)
    if ignoreSize
      return astfn:typeNewRecursiveAlias(me'curRoot'typePool, me'curRoot'moduleName? => me'curRoot'moduleName'name || null, ptype'name)
    /if

    mut cs = cs:new(20)
    cs.add("alias declaration makes type ")
    cs.add(ptype'name)
    cs.add(" recursive")
    cs.addChar(32)
    utils:listDumpHierarchyIntoCS(recList, cs)

    mut msg = cs:unwrap(cs)
    me'errs.append(parser:issueNew(parser:ISSUE_ERR, ptype'begin, me'curRoot'fileName, msg))
    mem:free(msg)

    return null
  /if

  # it's not builtin, so it must be a local alias.
  mut type = <ptr ast:PNode>(me'curRoot).findAliasLocal(ptype'name)
  if type?
    return astfn:typeClone(me'curRoot'typePool, type)
  /if

  # If here, then it's either undefined, or not validated yet.
  # So, we try to find a valid ptype, or otherwise it's an error.

  mut missingPType ptr ast:PType
  mut whichDecl = <ptr ast:PDecl>(me'aliases.get(ptype'name))

  if whichDecl?
    if whichDecl'node'validated
      proc:panic("This should not be reachable")
    /if

    return me.registerAliasReal(ptype'name, whichDecl'sym'type, recList, ignoreSize)
  /if

  # no match found, error
  mut cs = cs:new(20)
  cs.add("no type called ")
  cs.add(ptype'name)
  cs.add(" in current scope")

  mut msg = cs:unwrap(cs)
  me'errs.append(parser:issueNew(parser:ISSUE_ERR, ptype'begin, me'curRoot'fileName, msg))
  mem:free(msg)

  return null
/method


method sema:Resolver.convertType(ptype ptr ast:PType,
                                 recList ptr list:List,
                                 ignoreSize bool) ptr ast:Type

  mut ptdes = ptype'descr

  # if we've found an id, it can be 1. an id type 2. builtin 3. an invalid type
  if ptdes'type == ast:PTYPE_ID
    return me.resolveIdType(ptype, recList, ignoreSize)
  else
    if ptdes'type == ast:PTYPE_PTR or ptdes'type == ast:PTYPE_LOC
      return me.convertPtrLocType(ptype, recList)
    else
      if ptdes'type == ast:PTYPE_STRUCT
        return me.convertStructType(ptype, recList)
      else
        if ptdes'type == ast:PTYPE_FUNC
          return me.convertFuncType(ptype, recList)
        else
          proc:panic("unreachable")
        /if
      /if
    /if
  /if

  # unreachable
  return null
/method


method sema:Resolver.resolveTypeReal(ptype ptr ast:PType,
                                     recList ptr list:List,
                                     ignSize bool) ptr ast:Type

  return ptype'moduleName? => me.resolveModuleAlias(ptype) || me.convertType(ptype, recList, ignSize)
/method


method sema:Resolver.registerAliasReal(name ptr uint8,
                                       ptype ptr ast:PType,
                                       recList ptr list:List,
                                       ignSize bool) ptr ast:Type

  mut needsList = not recList?

  if needsList
    recList = list:new()
  /if


  recList.push(name)
  mut ret = me.resolveTypeReal(ptype, recList, ignSize)
  recList.pop()

  if ret?
    me.rootAliasRegister(name, ret)
  /if


  if needsList
    list:free(recList)
  /if

  return ret
/method


method sema:Resolver.registerAlias(pdecl ptr ast:PDecl) ptr ast:Type

  mut recList list:List
  list:init(ptr recList)

  mut ret = me.registerAliasReal(pdecl'sym'name, pdecl'sym'type, ptr recList, false)

  list:deinit(ptr recList)

  return ret
/method


method sema:Resolver.resolveType(ptype ptr ast:PType) ptr ast:Type

  return me.resolveTypeReal(ptype, null, false)
/method


method sema:Resolver.resolveTypeName(name ptr uint8) ptr ast:Type

  mut ptd = astfn:ptypeDescrNew(ast:PTYPE_ID, null, null)
  mut ptype = astfn:ptypeNew(name, null, ptd)

  mut ret = me.resolveType(ptype)

  mem:decRef(ptype)

  return ret
/method
