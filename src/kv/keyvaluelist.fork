#  libfork, a base library for the Fork language
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2014, 2015
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the
#  licenses expressed under Section 1.12 of the MPL v2.

# KVList'list contains (key, data) pairs; contents are there freed itereratively.
# KVList'hash contains (key, (index,data)) pairs; the only freed thing there is
# the (index, data) pair itself (data is left untouched because it has been
# freed before)

module kv


import hash
import kv
import list
import mem
import pair
import sort
import tty
import txt
import utils


# KVList init/deinit functions

func deinit(kv ptr kv:KVList)
  kv.freeContents()

  hash:deinit(ptr kv'hash)
  list:deinitAll(ptr kv'list, ptr pair:pairFree)
/func


func free(kv ptr kv:KVList)
  if kv?
    kv:deinit(kv)
    mem:free(kv)
  /if
/func


func init(kv ptr kv:KVList, cap uintptr, hf hash:hashfn) ptr kv:KVList
  mem:set(kv, 0, size(kv:KVList))

  hash:init(ptr kv'hash, cap, hf)

  kv'hash.setFreeFuncs(null, ptr hashFreePairs)

  list:init(ptr kv'list)

  return kv
/func


func new(cap uintptr, hf hash:hashfn) ptr kv:KVList
  return kv:init(<ptr kv:KVList>(mem:alloc(size(kv:KVList))), cap, hf)
/func


func strinit(kv ptr kv:KVList, cap uintptr) ptr kv:KVList
  return kv:init(kv, cap, ptr txt:strhash)
/func


func strnew(cap uintptr) ptr kv:KVList
  return kv:new(cap, ptr txt:strhash)
/func


# KVList methods

method kv:KVList.clone() ptr kv:KVList
  mut ret = kv:new(me'hash'buckets'cap, me'hash'hf)

  mut len = me.len()
  mut i uintptr = 0

  while i < len
    mut elem = me.getAt(i)
    ret.put(elem'key, elem'value)

    i++
  /while

  return ret
/method


method kv:KVList.contains(key data) bool
  return me'hash.contains(key)
/method


method kv:KVList.first() ptr pair:Pair
  return me'list.len() > 0 => <ptr pair:Pair>(val me'list.get(0)) || null
/method


method kv:KVList.fixIndices(pos uintptr)
  mut len = me'list.len()

  while pos < len
    mut pair = me.getAt(pos)
    mut indexValue = <ptr pair:Pair>(me'hash.get(pair'key))

    indexValue'key = <data>(pos)

    pos++
  /while
/method


method kv:KVList.freePairContents(pair ptr pair:Pair)
  if me'freeKey?
    me'freeKey(pair'key)
  /if

  if me'freeVal?
    me'freeVal(pair'value)
  /if
/method


method kv:KVList.freeContents()
  mut len = me.len()
  mut i uintptr = 0

  while i < len
    me.freePairContents(me.getAt(i))

    i++
  /while
/method


method kv:KVList.get(key data) data
  mut indexValue = <ptr pair:Pair>(me'hash.get(key))

  return indexValue? => indexValue'value || null
/method


method kv:KVList.getAt(index uintptr) ptr pair:Pair
  mut ret = me'list.get(index)
  return ret? => <ptr pair:Pair>(val ret) || null
/method


method kv:KVList.getPos(key data) intptr
  mut indexValue = <ptr pair:Pair>(me'hash.get(key))

  return indexValue? => <intptr>(indexValue'key) || -1
/method


method kv:KVList.len() uintptr
  return me'list.len()
/method


method kv:KVList.print()

  tty:out("[ ")

  mut len = me.len()
  mut i uintptr = 0

  while i < len
    if i > 0
      tty:out(", ")
    /if

    mut pair = me.getAt(i)

    tty:out(<ptr uint8>(pair'key))
    tty:out(": ")
    tty:out(<ptr uint8>(pair'value))

    i++
  /while

  tty:out(" ]")

/method


method kv:KVList.put(key data, value data)
  mut indexValue = <ptr pair:Pair>(me'hash.get(key))

  # if no key matches, then create a new element in list and hash
  # The index of this element will be the current length of the list (obviously).
  if not indexValue?
    indexValue = pair:pairNew(<data>(me'list.len()), value)

    me'hash.put(key, indexValue)
    me'list.append(pair:pairNew(key, value))
  else
    mut index = <uintptr>(indexValue'key)
    mut pair = <ptr pair:Pair>(val me'list.get(index))

    me.freePairContents(pair)
    # bug: check for double frees. Won't fix because it's better to improve the
    # language with destructors and methods, then making hacks.
    pair'key = key
    pair'value = indexValue'value = value
  /if
/method


method kv:KVList.remove(key data) bool

  # pair value will be discarded.
  mut pos = me.getPos(key)

  if pos >= 0
    mut pair = <ptr pair:Pair>(val me'list.get(pos))

    me.freePairContents(pair)

    me'list.remove(pos, ptr pair:pairFree)

    me'hash.remove(key)

    me.fixIndices(pos)

    return true
  /if

  return false
/method


method kv:KVList.setFreeFuncs(freeKey,freeVal ptr func(item data))
  me'freeKey = freeKey
  me'freeVal = freeVal
/method


func hashFreePairs(pairV data)
  mut pair = <ptr pair:Pair>(pairV)

  pair:pairFree(pair)
/func
