#  libfork, a base library for the Fork language
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2014, 2015
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the
#  licenses expressed under Section 1.12 of the MPL v2.

# KVList'list contains (key, data) pairs; contents are there freed itereratively.
# KVList'hash contains (key, (index,data)) pairs; the only freed thing there is
# the (index, data) pair itself (data is left untouched because it has been
# freed before)

module kv


import hash
import kv
import list
import mem
import pair
import sort
import tty
import txt
import utils


func kvClone(kv ptr kv:KVList) ptr kv:KVList
  mut ret = kv:kvNew(kv'hash'buckets'cap, kv'hash'hf)

  mut len = kv:kvLen(kv)
  mut i uintptr = 0

  while i < len
    mut elem = kv:kvGetAt(kv, i)
    kv:kvPut(ret, elem'key, elem'value)

    i++
  /while

  return ret
/func


func kvContains(kv ptr kv:KVList, key data) bool
  return hash:hashContains(ptr kv'hash, key)
/func


func kvDeinit(kv ptr kv:KVList)
  kvFreeContents(kv)

  hash:hashDeinit(ptr kv'hash)
  list:listDeinitAll(ptr kv'list, ptr pair:pairFree)
/func


func kvFirst(kv ptr kv:KVList) ptr pair:Pair
  return list:listLen(ptr kv'list) > 0 => cast<ptr pair:Pair>(val list:listGet(ptr kv'list, 0)) || null
/func


func kvFixIndices(kv ptr kv:KVList, pos uintptr)
  mut len = list:listLen(ptr kv'list)

  while pos < len
    mut pair = kv:kvGetAt(kv, pos)
    mut indexValue ptr pair:Pair = null

    hash:hashGet(ptr kv'hash, pair'key, ptr indexValue)

    indexValue'key = cast<data>(pos)

    pos++
  /while
/func


func kvFree(kv ptr kv:KVList)
  if kv != null
    kv:kvDeinit(kv)
    mem:free(kv)
  /if
/func


func kvFreePairContents(kv ptr kv:KVList, pair ptr pair:Pair)
  if kv'freeKey != null
    kv'freeKey(pair'key)
  /if

  if kv'freeVal != null
    kv'freeVal(pair'value)
  /if
/func


func kvFreeContents(kv ptr kv:KVList)
  mut len = kv:kvLen(kv)
  mut i uintptr = 0

  while i < len
    kvFreePairContents(kv, kv:kvGetAt(kv, i))

    i++
  /while
/func


func kvGet(kv ptr kv:KVList, key data, value ptr data) bool
  mut indexValue ptr pair:Pair = null
  mut res = hash:hashGet(ptr kv'hash, key, ptr indexValue)

  val value = res => indexValue'value || null

  return res
/func


func kvGetAt(kv ptr kv:KVList, index uintptr) ptr pair:Pair
  mut ret = list:listGet(ptr kv'list, index)
  return ret != null => cast<ptr pair:Pair>(val ret) || null
/func


func kvGetPos(kv ptr kv:KVList, key data, value ptr data) intptr
  mut indexValue ptr pair:Pair = null
  mut res = hash:hashGet(ptr kv'hash, key, ptr indexValue)

  val value = res => indexValue'value || null

  return res => cast<intptr>(indexValue'key) || -1
/func


func kvHashFreePairs(pairV data)
  mut pair = cast<ptr pair:Pair>(pairV)

  pair:pairFree(pair)
/func


func kvInit(kv ptr kv:KVList, cap uintptr, hf hash:hashfn) ptr kv:KVList
  mem:set(kv, 0, size(kv:KVList))

  hash:hashInit(ptr kv'hash, cap, hf)

  hash:hashSetFreeFuncs(ptr kv'hash, null, ptr kvHashFreePairs)

  list:listInit(ptr kv'list)

  return kv
/func


func kvLen(kv ptr kv:KVList) uintptr
  return list:listLen(ptr kv'list)
/func


func kvNew(cap uintptr, hf hash:hashfn) ptr kv:KVList
  return kv:kvInit(cast<ptr kv:KVList>(mem:alloc(size(kv:KVList))), cap, hf)
/func


func kvPrint(kv ptr kv:KVList)
  if kv == null
    tty:outln("<null>")
  else

    tty:out("[ ")

    mut len = kv:kvLen(kv)
    mut i uintptr = 0

    while i < len
      if i > 0
        tty:out(", ")
      /if

      mut pair = kv:kvGetAt(kv, i)

      tty:out(cast<ptr uint8>(pair'key))
      tty:out(": ")
      tty:out(cast<ptr uint8>(pair'value))

      i++
    /while

    tty:out(" ]")

  /if
/func


func kvPut(kv ptr kv:KVList, key data, value data)
  mut indexValue ptr pair:Pair
  mut res = hash:hashGet(ptr kv'hash, key, ptr indexValue)

  # if no key matches, then create a new element in list and hash
  # The index of this element will be the current length of the list (obviously).
  if !res
    indexValue = pair:pairNew(cast<data>(list:listLen(ptr kv'list)), value)

    hash:hashPut(ptr kv'hash, key, indexValue)
    list:listAppend(ptr kv'list, pair:pairNew(key, value))
  else
    mut index = cast<uintptr>(indexValue'key)
    mut pair = cast<ptr pair:Pair>(val list:listGet(ptr kv'list, index))

    kvFreePairContents(kv, pair)
    # bug: check for double frees. Won't fix because it's better to improve the
    # language with destructors and methods, then making hacks.
    pair'key = key
    pair'value = indexValue'value = value
  /if
/func


func kvRemove(kv ptr kv:KVList, key data) bool
  mut pair ptr pair:Pair

  # pair value will be discarded.
  mut pos = kv:kvGetPos(kv, key, ptr pair)

  if pos >= 0
    pair = cast<ptr pair:Pair>(val list:listGet(ptr kv'list, pos))

    kvFreePairContents(kv, pair)

    list:listRemove(ptr kv'list, pos, ptr pair:pairFree)
    hash:hashRemove(ptr kv'hash, key)

    kvFixIndices(kv, pos)

    return true
  /if

  return false
/func


func kvSetFreeFuncs(kv ptr kv:KVList, freeKey ptr func(item data), freeVal ptr func(item data))
  kv'freeKey = freeKey
  kv'freeVal = freeVal
/func


func strkvInit(kv ptr kv:KVList, cap uintptr) ptr kv:KVList
  return kv:kvInit(kv, cap, ptr txt:strhash)
/func


func strkvNew(cap uintptr) ptr kv:KVList
  return kv:kvNew(cap, ptr txt:strhash)
/func
