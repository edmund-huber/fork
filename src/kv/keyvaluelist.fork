#  libfork, a base library for the Fork language
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2014, 2015
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the
#  licenses expressed under Section 1.12 of the MPL v2.

# A KeyValueList is a linked list that exports the sametionalities as a map.
# The KeyValueList provides a costant traversal performance and easy deletion
# at the expense of random access time and search.
# The main reason for its usage is that
# 1. the map:Map deletion code has weird bugs
# 2. this structure mantains the insertion order, adding new values at the end
# 3. it's cheap to iterate on it.


module kv


import kv
import list
import mem
import pair
import sort
import tty
import txt
import utils


func kvClone(kv ptr kv:KVList) ptr kv:KVList
  mut ret = kv:kvNew(kv'cmp)

  mut len = kv:kvLen(kv)
  mut i uintptr = 0

  while i < len
    mut elem = kv:kvGetAt(kv, i)
    kv:kvPut(ret, elem'key, elem'value)

    i++
  /while

  return ret
/func


func kvContains(kv ptr kv:KVList, key data) bool
  mut discard data
  return kv:kvGetPos(kv, key, ptr discard) >= 0
/func


func kvDeinit(kv ptr kv:KVList)
  kvFreeContents(kv)
  list:listDeinitAll(ptr kv'list, ptr pair:pairFree)
/func


func kvInit(kv ptr kv:KVList, cmp sort:comparator) ptr kv:KVList
  mem:memset(kv, 0, size(kv:KVList))

  list:listInit(ptr kv'list)
  kv'cmp = cmp

  return kv
/func


func kvNew(cmp sort:comparator) ptr kv:KVList
  return kv:kvInit(cast<ptr kv:KVList>(mem:alloc(size(kv:KVList))), cmp)
/func


func kvFirst(kv ptr kv:KVList) ptr pair:Pair
  return list:listLen(ptr kv'list) > 0 => cast<ptr pair:Pair>(val list:listGet(ptr kv'list, 0)) || null
/func


func kvFree(kv ptr kv:KVList)
  if kv != null
    kv:kvDeinit(kv)
    mem:free(kv)
  /if
/func


func kvFreePairContents(kv ptr kv:KVList, pair ptr pair:Pair)
  if kv'freeKey != null
    kv'freeKey(pair'key)
  /if

  if kv'freeVal != null
    kv'freeVal(pair'value)
  /if
/func


func kvFreeContents(kv ptr kv:KVList)
  mut len = kv:kvLen(kv)
  mut i uintptr = 0

  while i < len
    kvFreePairContents(kv, kv:kvGetAt(kv, i))

    i++
  /while
/func


func kvGet(kv ptr kv:KVList, key data, value ptr data) bool
  return kv:kvGetPos(kv, key, value) >= 0
/func


func kvGetAt(kv ptr kv:KVList, index uintptr) ptr pair:Pair
  mut ret = list:listGet(ptr kv'list, index)
  return ret != null => cast<ptr pair:Pair>(val ret) || null
/func


func kvGetPairAndPos(kv ptr kv:KVList, key data, pair ptr ptr pair:Pair) intptr
  mut len = kv:kvLen(kv)
  mut i intptr = 0

  while i < len
    mut keyValuePair = kv:kvGetAt(kv, i)

    if kv'cmp(keyValuePair'key, key) == 0
      val pair = keyValuePair

      return i
    /if

    i++
  /while

  return -1
/func


func kvGetPos(kv ptr kv:KVList, key data, value ptr data) intptr
  mut pair ptr pair:Pair
  mut pos = kvGetPairAndPos(kv, key, ptr pair)

  if pos < 0
    return -1
  /if

  val value = pair'value

  return pos
/func


func kvLen(kv ptr kv:KVList) uintptr
  return list:listLen(ptr kv'list)
/func


func kvPrint(kv ptr kv:KVList)
  if kv == null
    tty:outln("<null>")
  else

    tty:out("[ ")

    mut len = kv:kvLen(kv)
    mut i uintptr = 0

    while i < len
      if i > 0
        tty:out(", ")
      /if

      mut pair = kv:kvGetAt(kv, i)

      tty:out(cast<ptr uint8>(pair'key))
      tty:out(": ")
      tty:out(cast<ptr uint8>(pair'value))

      i++
    /while

    tty:out(" ]")

  /if
/func


func kvPut(kv ptr kv:KVList, key data, value data)
  mut pair ptr pair:Pair
  mut pos = kvGetPairAndPos(kv, key, ptr pair)

  if pos < 0
    list:listAppend(ptr kv'list, pair:pairNew(key, value))
  else
    kvFreePairContents(kv, pair)

    pair'key = key
    pair'value = value
  /if
/func


func kvRemove(kv ptr kv:KVList, key data) bool
  mut pair ptr pair:Pair

  mut pos = kvGetPairAndPos(kv, key, ptr pair)

  if pos >= 0
    kvFreePairContents(kv, pair)

    list:listRemove(ptr kv'list, pos, ptr pair:pairFree)

    return true
  /if

  return false
/func


func kvSetFreeFuncs(kv ptr kv:KVList, freeKey ptr func(item data), freeVal ptr func(item data))
  kv'freeKey = freeKey
  kv'freeVal = freeVal
/func


func strkvInit(kv ptr kv:KVList) ptr kv:KVList
  return kv:kvInit(kv, ptr txt:strcompare)
/func


func strkvNew() ptr kv:KVList
  return kv:kvNew(ptr txt:strcompare)
/func
