program ::= [module], {import}, { definition }
module ::= 'module', id
import ::= 'import', id
definition ::= entry | function | mut | alias | decl | method
entry ::= 'entry', stmtEnd, body, '/entry'
funcHead ::= 'func', id, '(', argList, ')', [type]
function ::= funcHead, stmtEnd, body, '/func'
methodHead ::= 'method', idname, '.', 'id', '(', argList, ')', [type]
method ::= methodHead, stmtEnd, body, '/method'
argList ::= {argTypeList, ','}, argTypeList
argTypeList ::= {id, ','}, id, type
body ::= {stmt}
stmt ::= (if | while | mut | decl | expr | return | 'break' | 'continue'), stmtEnd
return ::= 'return', expr
if ::= 'if', expr, stmtEnd, body, [elseBlock], '/if'
while ::= 'while', expr, stmtEnd, breakBody, '/while'
elseBlock ::= 'else', body
mut ::= 'mut', (singleVar | structExpansion)
decl ::= 'decl', (funcHead | mut | methodHead)
stmtEnd ::= newLine | ';'
singleVar ::= assign | declType
structExpansion ::= '{', {seItem, ','}, seItem, '}', '=', expr
seItem ::= id, [type]
declType ::= id, type
alias ::= 'alias', id, type
typeModifier ::= 'val' | 'ptr' | ('[', number, ']')
funcType ::= 'func', '(', [type,{',', type}], ')', [type]
structType ::= newStruct | oldStruct
oldStruct ::= 'struct', '(', argList, ')'
newStruct ::= '{', argList, '}'
type ::= [typeModifier], (id | funcType | structType)
idname ::= id | ( idname, ':', id)
id ::= letter, {(letter | cipher)}
expr ::= assignExpr
assignExpr ::= assign | conditional
assign ::= unary, assignOp, assignExpr
assignOp ::= '=' | '+=' | '-=' | '*=' | '/=' | '&=' | '|=' | '^=' | '**='
idname ::= id, [':', id]
conditional ::= (coalesc, '=>', expr, '||', conditional) | coalesc
coalesc ::= (coalesc, '??', or) | or
or ::= ( or, 'or', and ) | and
and ::= ( and, 'and', binOr ) | binOr
binOr ::= ( binOr, '|', binAnd ) | binAnd
binAnd ::= ( binAnd, '&', equality ) | equality
equality ::= ( equality, ( '==' | '!=' ), comparison) | comparison
comparison ::= ( comparison, compOp, shift ) | shift
compOp ::= '>' | '<' | '>=' | '<='
shift ::= ( shift, ('sh<' | 'sh>'), addition) | addition
addition ::= ( addition, ('+' | '-'), multiplication ) | multiplication
multiplication ::= ( multiplication, ( '*', '/', 'mod' ), cast ) | cast
unary ::= postfix | (unaryOp, unary)
unaryOp ::= '-' | 'not' | 'ptr' | 'val'
postfix ::= primary | postfixTerm
postfixTerm ::= access | call | field | inc | dot | quest
primary ::= idname | constant | ( '(', expr, ')' ) | cast | size | structLiteral
structLiteral ::= '{', [exprList], '}'
size ::= 'size', '(', type, ')'
cast ::= ['cast'], '<', type, '>', '(', expr, ')'
access ::= postfix, '[', expr, ']'
call ::= postfix, '(', [ exprList ], ')'
# mixList ::= mixArg | ( mixList, ',', mixArg)
# mixArg ::= namedArg | assignExpr
# namedArg ::= ''', id, '=', assignExpr, [type]
exprList := assignExpr | ( exprList, ',', assignExpr )
field ::= postfix, ''', id
dot ::= postfix, '.', id
inc ::= postfix, ('++' | '--')
quest ::= postfix, '?'
constant ::= number | boolVal | 'null' | string | 'me'
boolVal ::= 'true' | 'false'
string ::= '"', {letter}, '"'
number ::= decNumber | binNumber | hexNumber
decNumber ::= ? decimal number ?
hexNumber ::= ? hexadecimal number like 0xAF, letters A-F and x can be both cases ?
binNumber ::= ? binary number like 0b10101, b can be both cases ?
letter ::= ? any Unicode letter ?
cipher ::= ? any cipher ?
newLine ::= ? new line delimiter ?
