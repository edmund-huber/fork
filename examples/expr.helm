import lex
import spring

mut next ptr lex:Token

mut TYPE_BINARY uint8 = 0
mut TYPE_UNARY uint8 = 2

mut ASSOC_LEFT uint8 = 0
mut ASSOC_RIGHT uint8 = 1

func isBinary(tok ptr lex:Token) bool
  return tok != null and (tok'type mod 10) < 2
/func

func isUnary(tok ptr lex:Token) bool
  return tok != null and !isBinary(tok)
/func

func assocRight(tok ptr lex:Token) bool
  return tok != null and ((tok'type & 1) != 0)
/func

func assocLeft(tok ptr lex:Token) bool
  return tok != null and !assocRight(tok)
/func

func opPrec(tok ptr lex:Token) int16
  if tok != null
    return tok'type / 1000
  /if
  return 0
/func

func isOp(tok ptr lex:Token) bool
  return opPrec(tok) != 0
/func

func isValidInExpr(tok ptr lex:Token) bool
  return tok != null and (isOp(tok) or tok'type == lex:ID or tok'type == lex:NUMBER)
/func

func nextTok(lex ptr lex:Lexer) ptr lex:Token
  if next == null
    next = lex:lexerNext(lex)
  /if

  if lex:lexerError(lex) != null
    return null
  /if

  mut ret = next
  next = lex:lexerNext(lex)

  if lex:lexerError(lex) != null
    return null
  /if

  return ret
/func

alias Op struct(
    tok ptr lex:Token,
    lhs ptr Op,
    rhs ptr Op
)

func opFree(op ptr Op)
  if op != null
    lex:tokenFree(op'tok)
    spring:free(op)
  /if
/func

func opNew(tok ptr lex:Token, lhs,rhs ptr Op) ptr Op
  mut op = cast<ptr Op>(spring:zalloc(size(Op)))
  op'tok = tok
  op'lhs = lhs
  op'rhs = rhs

  return op
/func

func exprParse(lex ptr lex:Lexer, lhs ptr Op, minPri uint16, err ptr ptr spring:Error) ptr Op
  mut curPrec uint16
  mut rhs ptr Op = null
  while (curPrec = opPrec(next)) >= minPri
    if next == null
      break
    /if

    mut op ptr lex:Token = null

    if isUnary(lhs'tok) and assocRight(lhs'tok)
      op = lhs'tok
      spring:free(lhs)
      lhs = null
    else
      op = nextTok(lex)
    /if

    if op == null
      val err = lex:lexerError(lex)
      return null
    /if

    if (!(isUnary(op) and assocLeft(op)))
      mut rhsTok = nextTok(lex)
      if rhsTok == null
        val err = lex:lexerError(lex)
        return null
      /if

      rhs = opNew(rhsTok, null, null)

      while next != null and (opPrec(next) > curPrec or (assocRight(next) and opPrec(next) == curPrec))
        rhs = exprParse(lex, rhs, opPrec(next), err)
        if rhs == null
          return null
        /if
      /while
    /if
    lhs = opNew(op, lhs, rhs)
  /while

  return lhs
/func

func opDump(op ptr Op)
  if op != null
    if op'tok'type == lex:ID
      spring:out(cast<ptr uint8>(op'tok'value))
    else
      if op'tok'type == lex:NUMBER
        spring:outint(op'tok'value)
      else
        spring:out(lex:tokenStr(op'tok))
      /if
    /if

    spring:outch(32)
    opDump(op'lhs)
    opDump(op'rhs)
  /if
/func

func opDump2(op ptr Op, depth uintptr)
  if op != null
    mut i uintptr = 0
    while i < depth
      spring:out("| ")
      i++
    /while

    spring:out("Type: ")
    spring:out(lex:tokenStr(op'tok))
    if op'tok'type == lex:ID
      spring:out(", value: ")
      spring:out(cast<ptr uint8>(op'tok'value))
    /if

    if op'tok'type == lex:NUMBER
      spring:out(", value: ")
      spring:outint(op'tok'value)
    /if

    if isOp(op'tok)
      spring:out(", prec ")
      spring:outint(opPrec(op'tok))
      spring:out(", binary, associates ")

      if assocLeft(op'tok)
        spring:out("left")
      else
        spring:out("right")
      /if
    /if

    spring:outch(10)
    opDump2(op'lhs, depth + 1)
    opDump2(op'rhs, depth + 1)
  /if
/func

entry
  next = null
  mut argv = spring:args()

  if argv'len != 1

    spring:failln("Wrong number of args")
  /if

  mut error ptr spring:Error
  mut lexer = lex:lexerNew(argv'args[0], ptr error)

  if error != null
    spring:err(argv'args[0])
    spring:err(": ")
    spring:failln(error'msg)
  /if

  mut op = exprParse(lexer, opNew(nextTok(lexer), null, null), 0, ptr error)
  if error != null
    spring:failln(error'msg)
  /if
  opDump(op)
  spring:outch(10)
  opDump2(op, 0)

  lex:lexerClose(lexer)

/entry
