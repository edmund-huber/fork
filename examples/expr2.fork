import lex
import spring
import utils

mut next ptr lex:Token

mut TYPE_BINARY uint8 = 0
mut TYPE_UNARY uint8 = 2

mut ASSOC_LEFT uint8 = 0
mut ASSOC_RIGHT uint8 = 1

func isBinary(tok ptr lex:Token) bool
  return tok != null and (tok'type mod 10) < 2
/func

func isUnary(tok ptr lex:Token) bool
  return tok != null and !isBinary(tok)
/func

func assocRight(tok ptr lex:Token) bool
  return tok != null and ((tok'type & 1) != 0)
/func

func assocLeft(tok ptr lex:Token) bool
  return tok != null and !assocRight(tok)
/func

func tokTypePrec(ttype uint16) int16
  if ttype == lex:MINUS
    return tokTypePrec(lex:PLUS)
  /if

  return ttype / 1000
/func

func opPrec(tok ptr lex:Token) int16
  if tok != null
    return tokTypePrec(tok'type)
  /if

  return 0
/func

func isOp(tok ptr lex:Token) bool
  return opPrec(tok) != 0
/func

func isValidInExpr(tok ptr lex:Token) bool
  return tok != null and (isOp(tok) or tok'type == lex:ID or tok'type == lex:NUMBER)
/func

func loadNext(lex ptr lex:Lexer)
  if next == null
    next = lex:lexerNext(lex)
  /if
/func

func nextTok(lex ptr lex:Lexer) ptr lex:Token
  loadNext(lex)

  if lex:lexerError(lex) != null
    return null
  /if

  mut ret = next
  next = lex:lexerNext(lex)

  if lex:lexerError(lex) != null
    return null
  /if

  return ret
/func

func discardTok(lex ptr lex:Lexer)
  lex:tokenFree(nextTok(lex))
/func

alias Op struct(
    tok ptr lex:Token,
    lhs ptr Op,
    rhs ptr Op
)

func opFree(op ptr Op)
  if op != null
    lex:tokenFree(op'tok)
    spring:free(op)
  /if
/func

func opNew(tok ptr lex:Token, lhs,rhs ptr Op) ptr Op
  mut op = cast<ptr Op>(spring:zalloc(size(Op)))
  op'tok = tok
  op'lhs = lhs
  op'rhs = rhs

  return op
/func

func exprParseCastTag(lex ptr lex:Lexer,err ptr ptr spring:Error) ptr Op
  mut castTok = nextTok(lex)

  ## begins stub
  discardTok(lex)

  mut tok ptr lex:Token
  while (tok = nextTok(lex))'type != lex:MAJOR
    lex:tokenFree(tok)
  /while

  lex:tokenFree(tok)
  discardTok(lex) #`(`
  ## end stub

  decl exprParse func(lex ptr lex:Lexer,err ptr ptr spring:Error) ptr Op

  mut expr = exprParse(lex,err)

  ## begins stub
  discardTok(lex) #`)`
  ## end stub

  return opNew(castTok, expr, null)
/func

func exprParseSizeOp(lex ptr lex:Lexer, err ptr ptr spring:Error) ptr Op
  mut sizeTok = nextTok(lex)
  ## begins stub
  discardTok(lex)

  mut tok ptr lex:Token
  while (tok = nextTok(lex))'type != lex:CPAR
    lex:tokenFree(tok)
  /while

  lex:tokenFree(tok)
  ## end stub

  return opNew(sizeTok, null, null)
/func

func tokIsPostfixExpressionSuffixStart(tok ptr lex:Token) bool
  return tok != null and (tok'type == lex:OPAR or tok'type == lex:OBRAC or tok'type == lex:INC or tok'type == lex:DEC)
/func

func exprParseId(lex ptr lex:Lexer, err ptr ptr spring:Error) ptr Op
  mut ret = opNew(nextTok(lex), null, null)
  if next != null and next'type == lex:COLON
    mut colon = nextTok(lex)
    if next == null
      val err = spring:errorNew("unexpected eof in exprParseId")
      return null
    /if

    if next'type != lex:ID
      val err = utils:errorMism(next'lineno, "an identifier", lex:tokenStr(next))
      return null
    /if

    ret = opNew(colon, ret, opNew(nextTok(lex), null, null))
  /if

  return ret
/func

func exprParseGenParens(lex ptr lex:Lexer, err ptr ptr spring:Error, cpar uint16) ptr Op

  decl exprParseAssign func(lex ptr lex:Lexer, err ptr ptr spring:Error) ptr Op
  mut expression = exprParseAssign(lex, err)

  if expression == null
    return null
  /if

  if next == null
    val err = spring:errorNew("Unexpected EOF in exprParseParens")
    return null
  /if

  if next'type != cpar
    val err = utils:errorMism(next'lineno, "a closing parenthesis", lex:tokenStr(next))
    return null
  /if

  discardTok(lex)

  return expression
/func

func exprParseParens(lex ptr lex:Lexer, err ptr ptr spring:Error) ptr Op
  discardTok(lex)
  return exprParseGenParens(lex, err, lex:CPAR)
/func

func exprParsePrimary(lex ptr lex:Lexer, err ptr ptr spring:Error) ptr Op
  if next == null
    val err = spring:errorNew("eof in exprParsePrimary")
    return null
  /if

  if next'type == lex:FALSE or next'type == lex:TRUE or next'type == lex:STRING or next'type == lex:NUMBER
    return opNew(nextTok(lex), null, null)
  /if

  if next'type == lex:ID
    return exprParseId(lex, err)
  /if

  if next'type != lex:OPAR
    val err = utils:errorMism(next'lineno, "an identifier, a costant or an expression between ()", lex:tokenStr(next))
    return null
  /if

  return exprParseParens(lex, err)
/func

func exprParseAccess(lex ptr lex:Lexer, lhs ptr Op, err ptr ptr spring:Error) ptr Op
  mut obrac = nextTok(lex)
  mut expression = exprParseGenParens(lex, err, lex:CBRAC)

  if expression == null
      return null
  /if

  return opNew(obrac, lhs, expression)
/func

func exprParseCall(lex ptr lex:Lexer, lhs ptr Op, err ptr ptr spring:Error) ptr Op
  mut opar = nextTok(lex)
  mut args = spring:vectNew(3)
  decl exprParseAssign func(lex ptr lex:Lexer, err ptr ptr spring:Error) ptr Op

  mut first = true

  while next != null and next'type != lex:CPAR

    if next'type != lex:COMMA and !first
      val err = spring:errorNew("unexpected eof or token not ',' in exprParseCall'")
      return null
    else
    #if it's not the first argument than it is COMMA
      if !first
        discardTok(lex)
      else
        first = false
      /if
    /if

    mut arg = exprParseAssign(lex, err)
    if arg == null
      return null
    /if

    spring:vectAppend(args, arg)

  /while

  if next != null
    discardTok(lex) #this is lex:CPAR
  /if

  return opNew(opar, lhs, cast<ptr Op>(args))
/func

func exprParseField(lex ptr lex:Lexer, lhs ptr Op, err ptr ptr spring:Error) ptr Op
  mut apos = nextTok(lex)

  if next == null
    val err = spring:errorNew("unexpected eof in exprParseCall'")
    return null
  /if

  if next'type != lex:ID
    val err = utils:errorMism(next'lineno, "an identifier", lex:tokenStr(next))
    return null
  /if

  return opNew(apos, lhs, opNew(nextTok(lex), null, null))
/func

func exprParsePostfixSuffix(lex ptr lex:Lexer, primaryLhs ptr Op, err ptr ptr spring:Error) ptr Op
  mut lhs = primaryLhs

  while true
    if next == null
      break
    /if

    if next'type == lex:OBRAC
      lhs = exprParseAccess(lex, lhs, err)
    else
      if next'type == lex:OPAR
        lhs = exprParseCall(lex, lhs, err)
      else
        if next'type == lex:INC or next'type == lex:DEC
          lhs = opNew(nextTok(lex), lhs, null)
        else
          if next'type == lex:APOS
            lhs = exprParseField(lex, lhs, err)
          else
            break
          /if
        /if
      /if
    /if

    if lhs == null
      return null
    /if
  /while

  return lhs
/func

func exprParsePostfix(lex ptr lex:Lexer, err ptr ptr spring:Error) ptr Op
  mut primary = exprParsePrimary(lex, err)

  if primary == null
    return null
  /if

  return exprParsePostfixSuffix(lex, primary, err)
/func

func exprParseUnaryOp(lex ptr lex:Lexer, err ptr ptr spring:Error) ptr Op
  mut operator = nextTok(lex)

  mut result ptr Op

  decl exprParseCast func(lex ptr lex:Lexer, err ptr ptr spring:Error) ptr Op
  if (result = exprParseCast(lex, err)) == null
    return null
  /if

  return opNew(operator, result, null)
/func

func exprParseUnary(lex ptr lex:Lexer, err ptr ptr spring:Error) ptr Op
  if next'type == lex:SIZE
    return exprParseSizeOp(lex, err)
  /if

  if isUnary(next)
    return exprParseUnaryOp(lex, err)
  /if

  return exprParsePostfix(lex, err)
/func

func exprParseCast(lex ptr lex:Lexer, err ptr ptr spring:Error) ptr Op
  if next == null
    val err = spring:errorNew("Null next in exprParseCast")
    return null
  /if

  if next'type == lex:CAST
    return exprParseCastTag(lex,err)
  /if

  return exprParseUnary(lex,err)
/func

func exprParseBinaryRhs(lex ptr lex:Lexer, lhs ptr Op, minPri uint16, err ptr ptr spring:Error) ptr Op
  mut curOpPrec uint16
  mut rhs ptr Op = null
  while next != null and ((curOpPrec = opPrec(next)) >= minPri)
    mut opTok = nextTok(lex)
    rhs = exprParseCast(lex, err)

    if rhs == null
      return null
    /if

    mut nextOpPrec = opPrec(next)

    if next != null and (nextOpPrec > curOpPrec or (assocRight(next) and nextOpPrec == curOpPrec))
      rhs = exprParseBinaryRhs(lex, rhs, nextOpPrec, err)
      if rhs == null
        return null
      /if
    /if

    lhs = opNew(opTok, lhs, rhs)
  /while

  return lhs
/func

func exprParseAssign(lex ptr lex:Lexer, err ptr ptr spring:Error) ptr Op
  mut lhs = exprParseCast(lex, err)

  return exprParseBinaryRhs(lex, lhs, tokTypePrec(lex:ASSIGN), err)
/func

func exprParse(lex ptr lex:Lexer, err ptr ptr spring:Error) ptr Op
  val err = null

  return exprParseAssign(lex, err)
/func

func opDump(op ptr Op)
  if op != null
    if op'tok'type == lex:OPAR
      spring:out("call:")
      opDump(op'lhs)
      spring:outch(32)
      return
    /if

    if op'tok'type == lex:ID
      spring:out(cast<ptr uint8>(op'tok'value))
    else
      if op'tok'type == lex:NUMBER
        spring:outint(op'tok'value)
      else
        spring:out(lex:tokenStr(op'tok))
      /if
    /if

    spring:outch(32)
    opDump(op'lhs)
    opDump(op'rhs)
  /if
/func

func funcDump2(op ptr Op, depth uintptr)
  decl opDump2 func(op ptr Op, depth uintptr)

  if op != null
    mut i uintptr = 0
    while i < depth
      spring:out("| ")
      i++
    /while

    spring:out("Function name: ")
    opDump(op'lhs)
    spring:outch(10)
    mut argVect = cast<ptr spring:Vector>(op'rhs)
    mut len = spring:vectLen(argVect)
    i = 0

    while i < len
      opDump2(cast<ptr Op>(val spring:vectGet(argVect, i)), depth + 1)
      i++
    /while
  /if
/func

func opDump2(op ptr Op, depth uintptr)
  if op != null

    mut i uintptr = 0
    while i < depth
      spring:out("| ")
      i++
    /while

    spring:out("Type: ")
    spring:out(lex:tokenStr(op'tok))

    if op'tok'type == lex:OPAR
      spring:outch(10)
      funcDump2(op, depth + 1)
      return
    /if

    if op'tok'type == lex:ID
      spring:out(", value: ")
      spring:out(cast<ptr uint8>(op'tok'value))
    /if

    if op'tok'type == lex:NUMBER
      spring:out(", value: ")
      spring:outint(op'tok'value)
    /if

    if isOp(op'tok)

      spring:out(", prec ")
      spring:outint(opPrec(op'tok))
      spring:out(", ")
      if isBinary(op'tok)
        spring:out("binary")
      else
        spring:out("unary")
      /if

      spring:out(", associates ")

      if assocLeft(op'tok)
        spring:out("left")
      else
        spring:out("right")
      /if
    /if

    spring:outch(10)
    opDump2(op'lhs, depth + 1)
    opDump2(op'rhs, depth + 1)
  /if
/func

func fileDump(path ptr uint8, err ptr ptr spring:Error)
  mut f = spring:fileOpen(path, err)
  if val err != null
    return
  /if

  mut rd uintptr = 0
  mut buf [512] uint8
  while !spring:streamEnded(f)
    rd = spring:streamRead(f, buf, 511)

    if (val err = spring:streamError(f)) != null
      break
    /if

    buf[rd] = 0

    spring:out(buf)
  /while
  spring:outch(10)
  spring:streamClose(f)
/func

entry
  next = null
  mut argv = spring:args()

  if argv'len != 1

    spring:failln("Wrong number of args")
  /if

  mut error ptr spring:Error
  mut lexer = lex:lexerNew(argv'args[0], ptr error)

  if error != null
    spring:err(argv'args[0])
    spring:err(": ")
    spring:failln(error'msg)
  /if

  loadNext(lexer)

  mut op = exprParse(lexer, ptr error)
  if error != null
    spring:failln(error'msg)
  /if

  spring:outln("File contents: ")
  fileDump(argv'args[0], ptr error)

  if error != null
    spring:failln(error'msg)
  /if

  spring:outln("Polish notation: ")
  opDump(op)
  spring:outch(10)
  spring:outch(10)
  spring:outln("Syntax tree: ")
  opDump2(op, 0)

  lex:lexerClose(lexer)

/entry
