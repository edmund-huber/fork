#  libfork, a base library for the Fork language
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2014
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the
#  licenses expressed under Section 1.12 of the MPL v2.


import ast
import kv
import list
import map
import mem
import pair
import parser
import proc
import sema
import synt
import tty
import txt
import utils


entry
  mut argv = proc:args()
  if argv'len != 1
    tty:errln("Wrong number of arguments, required: 1")
    proc:exit(1)
  /if

  mut ctx = parser:ctxNew()
  mut ast ptr ast:PNode
  mut errors = parser:ctxParseFile(ctx, argv'args[0], ptr ast)

  mut errLen = list:listLen(errors)

  if errLen > 0
    mut i uintptr = 0

    while i < errLen
      mut issue = cast<ptr parser:Issue>(val list:listGet(errors, i))

      parser:issueWriteOut(issue, ptr tty:out)

      i++
    /while

    list:listFree(errors)
    proc:exit(1)
  /if

  mut root = cast<ptr ast:PRoot>(ast)

  tty:out("== IMPORTS: ")
  tty:outint(map:mapLen(ctx'imports))
  tty:outch(10)

  mut iter = map:mapiterStart(ctx'imports)

  mut pair ptr pair:Pair

  while (pair = map:mapiterNext(iter)) != null
    tty:out("Imported ")
    tty:outln(cast<ptr uint8>(pair'key))

    pair:pairFree(pair)
  /while

  map:mapiterFree(iter)

  mut aliases = cast<ptr ast:PRoot>(ast)'aliases'syms

  tty:out("\n\n== ALIASES: ")
  tty:outint(kv:kvLen(aliases))
  tty:outch(10)

  mut i uintptr = 0
  mut len = kv:kvLen(aliases)

  while i < len
    pair = kv:kvGetAt(aliases, i)
    tty:out("alias ")
    tty:outln(cast<ptr uint8>(pair'key))

    i++
  /while

  mut decls = cast<ptr ast:PRoot>(ast)'node'syms'syms

  tty:out("\n\n== DECLS: ")
  tty:outint(kv:kvLen(decls))
  tty:outch(10)

  i = 0
  len = kv:kvLen(decls)

  while i < len
    pair = kv:kvGetAt(decls, i)
    mut dinfo = cast<ptr ast:DeclInfo>(pair'value)
    mut typeStr ptr uint8 = null

    if dinfo'declType == ast:PFUNCTION
      typeStr = "func "
    else
      if dinfo'declType == ast:PENTRY
        typeStr = "entry "
      else
        if dinfo'declType == ast:PDECL
          typeStr = "decl "
        else
          typeStr = "mut "
        /if
      /if
    /if

    tty:out(typeStr)
    tty:out(cast<ptr uint8>(pair'key))

    tty:out(" :: ")

    mut cs = txt:csNew(10)
    ast:typeSummarize(cs, dinfo'type)

    mut des = txt:csUnwrap(cs)

    tty:outln(des)

    mem:free(des)

    i++
  /while

  tty:out("\n\n==> Has entry? ")

  tty:outln(root'entryNode != null => "yes" || "no")

  parser:ctxFree(ctx)

  ast:pnodeFree(ast)
/entry
