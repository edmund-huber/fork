#  Second Step - Experimental Fork Compiler
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2014
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the
#  licenses expressed under Section 1.12 of the MPL v2.

import ast
import ctx
import sema
import spring
import synt
import utils

entry
  mut argv = spring:args()
  if argv'len != 1
    spring:errln("Wrong number of arguments, required: 1")
    spring:exit(1)
  /if

  mut ctx = ctx:contextNew()
  mut ast ptr ast:PNode
  mut errors = sema:semaParse(ctx, argv'args[0], ptr ast)

  mut errLen = spring:listLen(errors)

  if errLen > 0
    mut i uintptr = 0

    while i < errLen
      mut issue = cast<ptr utils:Issue>(val spring:listGet(errors, i))

      utils:issueWriteOut(issue, ptr spring:out)

      i++
    /while

    spring:listFree(errors)
    spring:exit(1)
  /if

  spring:out("== IMPORTS: ")
  spring:outint(spring:mapLen(ctx'imports))
  spring:outch(10)

  mut iter = spring:mapiterStart(ctx'imports)

  mut pair ptr spring:Pair

  while (pair = spring:mapiterNext(iter)) != null
    spring:out("Imported ")
    spring:outln(cast<ptr uint8>(pair'key))

    spring:pairFree(pair)
  /while

  spring:mapiterFree(iter)

  mut aliasesMap = cast<ptr ast:PRoot>(ast)'aliases'syms

  spring:out("\n\n== ALIASES: ")
  spring:outint(spring:mapLen(aliasesMap))
  spring:outch(10)

  iter = spring:mapiterStart(aliasesMap)

  while (pair = spring:mapiterNext(iter)) != null
    spring:out("alias ")
    spring:outln(cast<ptr uint8>(pair'key))

    spring:pairFree(pair)
  /while

  spring:mapiterFree(iter)

  mut declsMap = cast<ptr ast:PRoot>(ast)'node'syms'syms

  spring:out("\n\n== DECLS: ")
  spring:outint(spring:mapLen(declsMap))
  spring:outch(10)

  iter = spring:mapiterStart(declsMap)

  while (pair = spring:mapiterNext(iter)) != null
    mut dinfo = cast<ptr ast:DeclInfo>(pair'value)
    mut typeStr ptr uint8 = null

    if dinfo'declType == ast:PFUNCTION
      typeStr = "func "
    else
      if dinfo'declType == ast:PENTRY
        typeStr = "entry "
      else
        if dinfo'declType == ast:PDECL
          typeStr = "decl "
        else
          typeStr = "mut "
        /if
      /if
    /if

    spring:out(typeStr)
    spring:out(cast<ptr uint8>(pair'key))

    spring:out(" :: ")

    mut cs = spring:csNew(10)
    ast:typeSummarize(cs, dinfo'type)

    mut des = spring:csUnleash(cs)

    spring:outln(des)

    spring:free(des)
    spring:pairFree(pair)
  /while

  spring:mapiterFree(iter)

  ctx:contextFree(ctx)

  ast:pnodeFree(ast)
/entry
