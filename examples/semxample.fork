#  Second Step - Experimental Fork Compiler
#  Copyright (C) Marco Cilloni <marco.cilloni@yahoo.com> 2014
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#  Exhibit B is not attached; this software is compatible with the
#  licenses expressed under Section 1.12 of the MPL v2.

import ast
import ctx
import sema
import base
import synt
import utils

entry
  mut argv = base:args()
  if argv'len != 1
    base:errln("Wrong number of arguments, required: 1")
    base:exit(1)
  /if

  mut ctx = ctx:contextNew()
  mut ast ptr ast:PNode
  mut errors = sema:semaParse(ctx, argv'args[0], ptr ast)

  mut errLen = base:listLen(errors)

  if errLen > 0
    mut i uintptr = 0

    while i < errLen
      mut issue = cast<ptr utils:Issue>(val base:listGet(errors, i))

      utils:issueWriteOut(issue, ptr base:out)

      i++
    /while

    base:listFree(errors)
    base:exit(1)
  /if

  mut root = cast<ptr ast:PRoot>(ast)

  base:out("== IMPORTS: ")
  base:outint(base:mapLen(ctx'imports))
  base:outch(10)

  mut iter = base:mapiterStart(ctx'imports)

  mut pair ptr base:Pair

  while (pair = base:mapiterNext(iter)) != null
    base:out("Imported ")
    base:outln(cast<ptr uint8>(pair'key))

    base:pairFree(pair)
  /while

  base:mapiterFree(iter)

  mut aliasesMap = root'aliases'syms

  base:out("\n\n== ALIASES: ")
  base:outint(base:mapLen(aliasesMap))
  base:outch(10)

  iter = base:mapiterStart(aliasesMap)

  while (pair = base:mapiterNext(iter)) != null
    base:out("alias ")
    base:outln(cast<ptr uint8>(pair'key))

    base:pairFree(pair)
  /while

  base:mapiterFree(iter)

  mut declsMap = cast<ptr ast:PRoot>(ast)'node'syms'syms

  base:out("\n\n== DECLS: ")
  base:outint(base:mapLen(declsMap))
  base:outch(10)

  iter = base:mapiterStart(declsMap)

  while (pair = base:mapiterNext(iter)) != null
    mut dinfo = cast<ptr ast:DeclInfo>(pair'value)
    mut typeStr ptr uint8 = null

    if dinfo'declType == ast:PFUNCTION
      typeStr = "func "
    else
      if dinfo'declType == ast:PENTRY
        typeStr = "entry "
      else
        if dinfo'declType == ast:PDECL
          typeStr = "decl "
        else
          typeStr = "mut "
        /if
      /if
    /if

    base:out(typeStr)
    base:out(cast<ptr uint8>(pair'key))

    base:out(" :: ")

    mut cs = base:csNew(10)
    ast:typeSummarize(cs, dinfo'type)

    mut des = base:csUnleash(cs)

    base:outln(des)

    base:free(des)
    base:pairFree(pair)
  /while

  base:out("\n\n==> Has entry? ")

  base:outln(root'entryNode != null => "yes" || "no")

  base:mapiterFree(iter)

  ctx:contextFree(ctx)

  ast:pnodeFree(ast)
/entry
